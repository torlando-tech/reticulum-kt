---
phase: 12-doze-aware-connection-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/ConnectionPolicy.kt
  - rns-android/src/main/kotlin/network/reticulum/android/ConnectionPolicyProvider.kt
autonomous: true

must_haves:
  truths:
    - "ConnectionPolicy data class combines throttle multiplier, network state, and reason"
    - "ConnectionPolicyProvider combines DozeState, NetworkState, and BatteryInfo into single StateFlow"
    - "Charging state overrides battery throttling (full speed when plugged in)"
    - "Deep Doze applies 5x throttle multiplier"
    - "Low battery (<15%) applies 5x throttle with 3% hysteresis (resume at 18%)"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ConnectionPolicy.kt"
      provides: "ConnectionPolicy data class with throttle multiplier and state"
      min_lines: 20
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ConnectionPolicyProvider.kt"
      provides: "StateFlow combining Doze, network, and battery states"
      min_lines: 60
  key_links:
    - from: "ConnectionPolicyProvider"
      to: "DozeStateObserver, NetworkStateObserver, BatteryMonitor"
      via: "StateFlow combine"
      pattern: "combine\\(.*\\)"
---

<objective>
Create ConnectionPolicy and ConnectionPolicyProvider to combine Doze, network, and battery states into a unified reactive policy flow.

Purpose: Phase 10 built observers for Doze, network, and battery state. This plan creates a single combined StateFlow that downstream components can observe to adjust their behavior based on all power states simultaneously.

Output: Two new Kotlin files providing a unified connection policy that interfaces and Transport can consume.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-doze-aware-connection-management/12-CONTEXT.md
@.planning/phases/12-doze-aware-connection-management/12-RESEARCH.md
@rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt
@rns-android/src/main/kotlin/network/reticulum/android/NetworkStateObserver.kt
@rns-android/src/main/kotlin/network/reticulum/android/BatteryMonitor.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConnectionPolicy data class</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ConnectionPolicy.kt</files>
  <action>
Create ConnectionPolicy.kt with:

1. Data class `ConnectionPolicy` containing:
   - `throttleMultiplier: Float` (1.0 = normal, 2.0 = 2x slower, 5.0 = 5x slower)
   - `shouldThrottle: Boolean` (true when multiplier > 1.0)
   - `networkAvailable: Boolean` (from NetworkState.isAvailable)
   - `reason: String` (human-readable reason for current policy)

2. Add a companion object with constants:
   - `NORMAL_MULTIPLIER = 1.0f`
   - `DOZE_MULTIPLIER = 5.0f` (Deep Doze and low battery)
   - `BATTERY_THROTTLE_THRESHOLD = 15`
   - `BATTERY_RESUME_THRESHOLD = 18` (3% hysteresis)

3. Add factory method `fun create(doze: DozeState, network: NetworkState, batteryLevel: Int, isCharging: Boolean, wasThrottledForBattery: Boolean): Pair<ConnectionPolicy, Boolean>` that returns the policy and the new `wasThrottledForBattery` state for hysteresis tracking.

The factory method implements the priority logic from CONTEXT.md:
- If charging: return normal speed (1.0x)
- If Doze is Dozing: return 5x throttle
- If battery < 15 and not wasThrottled: return 5x throttle, set wasThrottled = true
- If battery >= 18 and wasThrottled: return normal, set wasThrottled = false
- If wasThrottled (battery between 15-18): return 5x throttle
- Otherwise: return normal

Add KDoc explaining the throttle multiplier semantics and hysteresis behavior.
  </action>
  <verify>`./gradlew :rns-android:compileDebugKotlin` succeeds</verify>
  <done>ConnectionPolicy.kt exists with data class, constants, and factory method with hysteresis support</done>
</task>

<task type="auto">
  <name>Task 2: Create ConnectionPolicyProvider</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ConnectionPolicyProvider.kt</files>
  <action>
Create ConnectionPolicyProvider.kt with:

1. Class `ConnectionPolicyProvider` that:
   - Takes constructor parameters: `dozeObserver: DozeStateObserver`, `networkObserver: NetworkStateObserver`, `batteryMonitor: BatteryMonitor`, `scope: CoroutineScope`
   - Creates internal `_policy` MutableStateFlow with initial policy
   - Exposes `policy: StateFlow<ConnectionPolicy>` as read-only

2. Use `combine` to merge the three state sources:
   - `dozeObserver.state` (StateFlow<DozeState>)
   - `networkObserver.state` (StateFlow<NetworkState>)
   - Battery info from BatteryMonitor (use polling or convert listener to Flow)

3. For BatteryMonitor integration:
   - BatteryMonitor uses listener-based API, not StateFlow
   - Create a `batteryFlow` by using `callbackFlow` to convert the listener
   - Or poll `batteryMonitor.getBatteryInfo()` with `ticker` flow at 30-second intervals (battery changes slowly)

4. Track hysteresis state internally (`wasThrottledForBattery: Boolean`)

5. Implement `start()` and `stop()` methods to control observation

6. Add `currentPolicy` property for synchronous access: `get() = policy.value`

Add KDoc explaining the combination logic and battery polling approach.
  </action>
  <verify>`./gradlew :rns-android:compileDebugKotlin` succeeds</verify>
  <done>ConnectionPolicyProvider.kt exists with combined StateFlow, battery polling, and hysteresis tracking</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for ConnectionPolicy</name>
  <files>rns-android/src/test/kotlin/network/reticulum/android/ConnectionPolicyTest.kt</files>
  <action>
Create ConnectionPolicyTest.kt with tests for the ConnectionPolicy factory method:

1. `test charging overrides low battery throttling` - isCharging=true, battery=10 -> multiplier=1.0
2. `test doze mode applies 5x throttle` - DozeState.Dozing -> multiplier=5.0
3. `test low battery triggers 5x throttle` - battery=14, wasThrottled=false -> multiplier=5.0, returns wasThrottled=true
4. `test hysteresis prevents flip-flop` - battery=16, wasThrottled=true -> multiplier=5.0 (stays throttled)
5. `test battery resume at 18 percent` - battery=18, wasThrottled=true -> multiplier=1.0, returns wasThrottled=false
6. `test normal operation` - not dozing, battery=50, not charging -> multiplier=1.0

Use JUnit 5 and simple assertions. This is a pure logic class, no Android dependencies needed for these tests.
  </action>
  <verify>`./gradlew :rns-android:testDebugUnitTest --tests "*.ConnectionPolicyTest"` passes</verify>
  <done>6 unit tests validate throttle logic including hysteresis behavior</done>
</task>

</tasks>

<verification>
1. `./gradlew :rns-android:compileDebugKotlin` - Both new files compile
2. `./gradlew :rns-android:testDebugUnitTest --tests "*.ConnectionPolicyTest"` - All 6 tests pass
3. Inspect ConnectionPolicy.kt - Constants match CONTEXT.md values (5x, 15%, 18%)
4. Inspect ConnectionPolicyProvider.kt - Uses combine() for state merging
</verification>

<success_criteria>
- ConnectionPolicy data class provides throttle multiplier semantics
- ConnectionPolicyProvider combines all state sources with proper hysteresis
- Charging state correctly overrides battery throttling
- 6 unit tests validate core throttle logic
- No new dependencies added (uses existing kotlinx-coroutines)
</success_criteria>

<output>
After completion, create `.planning/phases/12-doze-aware-connection-management/12-01-SUMMARY.md`
</output>
