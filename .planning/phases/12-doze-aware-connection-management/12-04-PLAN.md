---
phase: 12-doze-aware-connection-management
plan: 04
type: execute
wave: 2
depends_on: [12-02]
files_modified:
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt
  - rns-interfaces/src/test/kotlin/network/reticulum/interfaces/tcp/TCPClientInterfaceBackoffTest.kt
autonomous: true

must_haves:
  truths:
    - "TCPClientInterface uses ExponentialBackoff for reconnection delays"
    - "Reconnection delays start at 1 second, max at 60 seconds"
    - "After 10 consecutive failures, interface gives up (logs max attempts reached)"
    - "Network changes trigger backoff reset (optional callback parameter)"
    - "Backoff applies to reconnect loop, not initial connect"
  artifacts:
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt"
      provides: "Exponential backoff reconnection with configurable callback"
      contains: "ExponentialBackoff"
    - path: "rns-interfaces/src/test/kotlin/network/reticulum/interfaces/tcp/TCPClientInterfaceBackoffTest.kt"
      provides: "Tests for backoff behavior in TCPClientInterface"
      min_lines: 30
  key_links:
    - from: "TCPClientInterface.reconnect()"
      to: "ExponentialBackoff.nextDelay()"
      via: "delay() with backoff value"
      pattern: "backoff\\.nextDelay\\(\\)"
---

<objective>
Update TCPClientInterface to use exponential backoff for reconnection.

Purpose: Replace the fixed 5-second RECONNECT_WAIT_MS delay with ExponentialBackoff from Plan 02. This reduces battery drain on flaky networks by progressively backing off, while still allowing quick reconnection on first failure.

Output: Modified TCPClientInterface with intelligent reconnection and optional callback for network change notifications.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-doze-aware-connection-management/12-CONTEXT.md
@.planning/phases/12-doze-aware-connection-management/12-RESEARCH.md
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/backoff/ExponentialBackoff.kt (from Plan 02)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ExponentialBackoff to TCPClientInterface</name>
  <files>rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt</files>
  <action>
Modify TCPClientInterface to use ExponentialBackoff:

1. Add import at top:
   ```kotlin
   import network.reticulum.interfaces.backoff.ExponentialBackoff
   ```

2. Add backoff instance as a property:
   ```kotlin
   // Exponential backoff for reconnection: 1s, 2s, 4s... up to 60s, give up after 10 attempts
   private val backoff = ExponentialBackoff()
   ```

3. Modify the `reconnect()` suspend function to use backoff:
   ```kotlin
   private suspend fun reconnect() {
       if (reconnecting.getAndSet(true)) return

       // Reset backoff on each fresh reconnection cycle start
       // Note: Do NOT reset here - network change handler will reset when appropriate

       while (!online.get() && !detached.get()) {
           val delayMs = backoff.nextDelay()

           if (delayMs == null) {
               log("Max reconnection attempts (${backoff.attemptCount}) reached, giving up")
               detach()
               break
           }

           delay(delayMs)

           // Check if scope still active after delay
           if (!ioScope.isActive) break

           try {
               if (connect()) {
                   if (!neverConnected.get()) {
                       log("Reconnected successfully after ${backoff.attemptCount} attempts")
                   }
                   backoff.reset() // Success - reset for next time
                   break
               }
           } catch (e: CancellationException) {
               break
           } catch (e: Exception) {
               log("Reconnection attempt ${backoff.attemptCount} failed: ${e.message}")
           }
       }

       reconnecting.set(false)
   }
   ```

4. Remove or deprecate the RECONNECT_WAIT_MS constant (it's now unused):
   ```kotlin
   @Deprecated("Use ExponentialBackoff instead", level = DeprecationLevel.WARNING)
   const val RECONNECT_WAIT_MS = 5000L
   ```
  </action>
  <verify>`./gradlew :rns-interfaces:compileKotlin` succeeds</verify>
  <done>TCPClientInterface uses ExponentialBackoff for reconnection delays</done>
</task>

<task type="auto">
  <name>Task 2: Add network change callback for backoff reset</name>
  <files>rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt</files>
  <action>
Add a method to reset backoff on network changes:

1. Add public method for network change notification:
   ```kotlin
   /**
    * Notify the interface that the network has changed.
    *
    * This resets the reconnection backoff counter, allowing quick
    * reconnection attempts on the new network. Call this when:
    * - WiFi <-> cellular handoff occurs
    * - Network becomes available after being offline
    *
    * Per CONTEXT.md: "Network changes reset the backoff counter"
    */
   fun onNetworkChanged() {
       log("Network changed - resetting reconnection backoff")
       backoff.reset()

       // If currently offline and not detached, trigger reconnection
       if (!online.get() && !detached.get() && !reconnecting.get()) {
           ioScope.launch {
               reconnect()
           }
       }
   }
   ```

2. This method can be called by InterfaceManager when NetworkStateObserver reports a change.
   The actual wiring will be done in a future plan (InterfaceManager integration).
  </action>
  <verify>`./gradlew :rns-interfaces:compileKotlin` succeeds</verify>
  <done>onNetworkChanged() method available for backoff reset and reconnection trigger</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for backoff integration</name>
  <files>rns-interfaces/src/test/kotlin/network/reticulum/interfaces/tcp/TCPClientInterfaceBackoffTest.kt</files>
  <action>
Create TCPClientInterfaceBackoffTest.kt with integration tests:

Note: These tests focus on the backoff integration, not network I/O.

1. `test backoff is reset on successful connection` - Verify backoff.attemptCount returns to 0 after success
2. `test onNetworkChanged resets backoff` - Call onNetworkChanged(), verify backoff is fresh
3. `test max attempts logs giving up message` - Mock failure, verify log contains "giving up"

Since TCPClientInterface requires network, use a mock approach:
- Create interface with an invalid host (will fail to connect)
- Start it, let it attempt reconnection
- Verify behavior through logs or exposed state

Alternative: Test the backoff instance directly since TCPClientInterface exposes logging.

```kotlin
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Timeout
import java.util.concurrent.TimeUnit

class TCPClientInterfaceBackoffTest {

    @Test
    @Timeout(5, unit = TimeUnit.SECONDS)
    fun `onNetworkChanged is callable and doesn't throw`() {
        val iface = TCPClientInterface(
            name = "TestBackoff",
            targetHost = "192.0.2.1", // TEST-NET, unreachable
            targetPort = 12345,
            maxReconnectAttempts = 1  // Give up fast for test
        )

        // Should not throw
        iface.onNetworkChanged()

        // Cleanup
        iface.stop()
    }

    @Test
    fun `interface exposes max reconnect attempts via constructor`() {
        val iface = TCPClientInterface(
            name = "TestMaxAttempts",
            targetHost = "192.0.2.1",
            targetPort = 12345,
            maxReconnectAttempts = 5
        )

        // maxReconnectAttempts is still honored by backoff
        // Note: This is a constructor param, not directly testable without running
        assertNotNull(iface)
        iface.stop()
    }
}
```

Keep tests simple since full network tests are complex. The unit tests in ExponentialBackoffTest cover the core logic.
  </action>
  <verify>`./gradlew :rns-interfaces:test --tests "*.TCPClientInterfaceBackoffTest"` passes</verify>
  <done>Basic integration tests verify backoff is wired correctly</done>
</task>

</tasks>

<verification>
1. `./gradlew :rns-interfaces:compileKotlin` - TCPClientInterface compiles with ExponentialBackoff
2. `./gradlew :rns-interfaces:test --tests "*.ExponentialBackoffTest"` - Backoff tests still pass
3. `./gradlew :rns-interfaces:test --tests "*.TCPClientInterfaceBackoffTest"` - Integration tests pass
4. `./gradlew :rns-interfaces:test --tests "*.ScopeInjectionTest"` - Existing scope tests still pass
5. Grep for "ExponentialBackoff" in TCPClientInterface - Import and usage present
</verification>

<success_criteria>
- TCPClientInterface uses ExponentialBackoff instead of fixed delay
- onNetworkChanged() method allows external reset of backoff
- Backoff resets on successful connection
- Max attempts triggers detach() with log message
- Existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/12-doze-aware-connection-management/12-04-SUMMARY.md`
</output>
