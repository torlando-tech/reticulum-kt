---
phase: 20-gatt-client-scanner
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/ble/AndroidBLEDriver.kt
  - rns-android/src/main/kotlin/network/reticulum/android/ble/BleGattServer.kt
  - rns-android/src/main/kotlin/network/reticulum/android/ble/BleAdvertiser.kt
  - rns-android/src/main/kotlin/network/reticulum/android/ble/BleScanner.kt
  - rns-android/src/main/kotlin/network/reticulum/android/ble/BleGattClient.kt

autonomous: true

must_haves:
  truths:
    - "AndroidBLEDriver implements the BLEDriver interface from rns-interfaces"
    - "AndroidBLEDriver.startAdvertising() delegates to BleAdvertiser"
    - "AndroidBLEDriver.stopAdvertising() delegates to BleAdvertiser"
    - "AndroidBLEDriver.startScanning() delegates to BleScanner"
    - "AndroidBLEDriver.stopScanning() delegates to BleScanner"
    - "AndroidBLEDriver.connect(address) delegates to BleGattClient and returns a BLEPeerConnection"
    - "AndroidBLEDriver.disconnect(address) disconnects from both client and server connections"
    - "AndroidBLEDriver.discoveredPeers aggregates BleScanner scan results"
    - "AndroidBLEDriver.incomingConnections emits BLEPeerConnection for each server-side central connect"
    - "AndroidBLEDriver.connectionLost aggregates disconnects from both client and server"
    - "BLE component classes (BleGattClient, BleScanner, BleGattServer, BleAdvertiser) are internal visibility"
    - "AndroidBLEDriver is the only public API from rns-android BLE package"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ble/AndroidBLEDriver.kt"
      provides: "BLEDriver implementation bridging pure-JVM interface with Android BLE stack"
      exports: ["AndroidBLEDriver"]
  key_links:
    - from: "AndroidBLEDriver.kt"
      to: "BLEDriver.kt"
      via: "implements BLEDriver interface (startAdvertising, startScanning, connect, etc.)"
      pattern: "BLEDriver"
    - from: "AndroidBLEDriver.kt"
      to: "BLEPeerConnection"
      via: "creates AndroidBLEPeerConnection implementing BLEPeerConnection for each connection"
      pattern: "BLEPeerConnection"
    - from: "AndroidBLEDriver.kt"
      to: "BleGattClient.kt"
      via: "delegates connect/disconnect/sendData to BleGattClient"
      pattern: "gattClient"
    - from: "AndroidBLEDriver.kt"
      to: "BleGattServer.kt"
      via: "delegates server operations and incoming connections to BleGattServer"
      pattern: "gattServer"
    - from: "AndroidBLEDriver.kt"
      to: "BleScanner.kt"
      via: "delegates scan operations and collects discoveredPeers"
      pattern: "scanner"
    - from: "AndroidBLEDriver.kt"
      to: "BleAdvertiser.kt"
      via: "delegates advertising lifecycle"
      pattern: "advertiser"
---

<objective>
Implement AndroidBLEDriver.kt -- the concrete implementation of the BLEDriver interface that bridges the pure-JVM protocol layer with the Android BLE stack, aggregating all Phase 19 and Phase 20 BLE components. Also mark BLE component classes as `internal` so that only AndroidBLEDriver is public API.

Purpose: AndroidBLEDriver is the single public entry point for the BLE subsystem. It implements the BLEDriver interface from rns-interfaces, delegating to BleGattServer, BleAdvertiser, BleScanner, and BleGattClient. Phase 21's BLEInterface will receive an AndroidBLEDriver instance and interact with it purely through the BLEDriver contract, achieving full separation between protocol logic (pure JVM) and platform implementation (Android).

Output: `AndroidBLEDriver.kt` in `rns-android/src/main/kotlin/network/reticulum/android/ble/`, plus `internal` visibility on BLE component classes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-gatt-client-scanner/20-CONTEXT.md
@.planning/phases/20-gatt-client-scanner/20-01-SUMMARY.md

# The interface being implemented:
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEDriver.kt

# Phase 18 outputs:
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEConstants.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BleOperationQueue.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/DiscoveredPeer.kt

# All BLE components in rns-android (server from Phase 19, client from Plan 01):
@rns-android/src/main/kotlin/network/reticulum/android/ble/BleGattServer.kt
@rns-android/src/main/kotlin/network/reticulum/android/ble/BleAdvertiser.kt
@rns-android/src/main/kotlin/network/reticulum/android/ble/BleScanner.kt
@rns-android/src/main/kotlin/network/reticulum/android/ble/BleGattClient.kt

# Reference for bridge pattern:
@~/repos/columba/reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/bridge/KotlinBLEBridge.kt

# Module structure:
@rns-android/build.gradle.kts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement AndroidBLEDriver.kt</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ble/AndroidBLEDriver.kt</files>
  <action>
Create `AndroidBLEDriver.kt` in `network.reticulum.android.ble`. This implements the BLEDriver interface, bridging the pure-JVM contract with Android BLE components.

**KEY DIFFERENCES from Columba's KotlinBLEBridge:**
- Implements the BLEDriver interface (not a standalone bridge class)
- Returns BLEPeerConnection from connect() (not void with callback)
- No Chaquopy/Python callbacks (pure Kotlin)
- No identity handshake logic (that's Phase 21's concern)
- No MAC sorting (that's Phase 21's concern)
- No dual-connection deduplication (that's Phase 21/22)
- Focus: pure plumbing between BLEDriver interface and Android components

**Class signature:**
```kotlin
class AndroidBLEDriver(
    private val context: Context,
    private val bluetoothManager: BluetoothManager,
    private val scope: CoroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()),
) : BLEDriver
```

**Internal BLE components (shared scope and operation queue):**
```kotlin
private val bluetoothAdapter: BluetoothAdapter = bluetoothManager.adapter
private val operationQueue = BleOperationQueue(scope)
private val gattServer = BleGattServer(context, bluetoothManager, scope)
private val advertiser = BleAdvertiser(context, bluetoothAdapter, scope)
private val scanner = BleScanner(context, bluetoothAdapter, scope)
private val gattClient = BleGattClient(context, bluetoothAdapter, operationQueue, scope)
```

**AndroidBLEPeerConnection (private inner class implementing BLEPeerConnection):**
This wraps the connection state from either BleGattClient (outgoing) or BleGattServer (incoming).

```kotlin
private inner class AndroidBLEPeerConnection(
    override val address: String,
    private val isOutgoing: Boolean, // true = we are central, false = we are peripheral
) : BLEPeerConnection {

    override val mtu: Int
        get() = runBlocking {
            if (isOutgoing) {
                gattClient.getMtu(address) ?: BLEConstants.DEFAULT_MTU
            } else {
                gattServer.getMtu(address) ?: BLEConstants.DEFAULT_MTU
            }
        }

    override var identity: ByteArray? = null

    private val _receivedFragments = MutableSharedFlow<ByteArray>(extraBufferCapacity = 64)
    override val receivedFragments: SharedFlow<ByteArray> = _receivedFragments.asSharedFlow()

    fun emitFragment(data: ByteArray) {
        _receivedFragments.tryEmit(data)
    }

    override suspend fun sendFragment(data: ByteArray) {
        if (isOutgoing) {
            gattClient.sendData(address, data).getOrThrow()
        } else {
            val sent = gattServer.sendNotificationToAddress(address, data)
            if (!sent) throw IllegalStateException("Failed to send notification to $address")
        }
    }

    override suspend fun readIdentity(): ByteArray {
        check(isOutgoing) { "readIdentity only supported on outgoing (central) connections" }
        return gattClient.readCharacteristic(address, BLEConstants.IDENTITY_CHAR_UUID)
    }

    override suspend fun writeIdentity(identity: ByteArray) {
        check(isOutgoing) { "writeIdentity only supported on outgoing (central) connections" }
        // Write our identity to the peer's RX characteristic
        gattClient.sendData(address, identity).getOrThrow()
    }

    override fun close() {
        scope.launch {
            if (isOutgoing) {
                gattClient.disconnect(address)
            } else {
                gattServer.disconnectCentral(address)
            }
        }
    }
}
```

Note: `runBlocking` for the `mtu` property getter is acceptable here because it's a quick Mutex-protected map lookup that won't block. If preferred, make mtu a var that's updated via event collectors instead. Use Claude's discretion on which approach is cleaner.

**Active peer connections:**
```kotlin
private val peerConnections = mutableMapOf<String, AndroidBLEPeerConnection>()
private val peersMutex = Mutex()
```

**Event flow aggregation (init block):**
In the init block, launch collectors that transform component events into BLEDriver interface events.

```kotlin
init {
    // Scanner -> discoveredPeers
    scope.launch {
        scanner.discoveredPeers.collect { peer ->
            _discoveredPeers.tryEmit(peer)
        }
    }

    // GattServer centralConnected -> incomingConnections
    scope.launch {
        gattServer.centralConnected.collect { address ->
            val peerConn = AndroidBLEPeerConnection(address, isOutgoing = false)
            peersMutex.withLock { peerConnections[address] = peerConn }
            _incomingConnections.tryEmit(peerConn)
        }
    }

    // GattServer centralDisconnected -> connectionLost
    scope.launch {
        gattServer.centralDisconnected.collect { address ->
            peersMutex.withLock { peerConnections.remove(address) }
            _connectionLost.tryEmit(address)
        }
    }

    // GattClient disconnected -> connectionLost
    scope.launch {
        gattClient.disconnected.collect { address ->
            peersMutex.withLock { peerConnections.remove(address) }
            _connectionLost.tryEmit(address)
        }
    }

    // GattServer dataReceived -> route to peer connection
    scope.launch {
        gattServer.dataReceived.collect { (address, data) ->
            val peerConn = peersMutex.withLock { peerConnections[address] }
            peerConn?.emitFragment(data)
        }
    }

    // GattClient dataReceived -> route to peer connection
    scope.launch {
        gattClient.dataReceived.collect { (address, data) ->
            val peerConn = peersMutex.withLock { peerConnections[address] }
            peerConn?.emitFragment(data)
        }
    }
}
```

**BLEDriver interface implementation:**

```kotlin
// ---- Lifecycle ----

override suspend fun startAdvertising() {
    gattServer.open().getOrThrow()
    advertiser.startAdvertising().getOrThrow()
    _isRunning = true
}

override suspend fun stopAdvertising() {
    advertiser.stopAdvertising()
    gattServer.close()
}

override suspend fun startScanning() {
    scanner.startScanning().getOrThrow()
    _isRunning = true
}

override suspend fun stopScanning() {
    scanner.stopScanning()
}

override suspend fun connect(address: String): BLEPeerConnection {
    gattClient.connect(address).getOrThrow()

    // Wait for the connected event to know setup is complete
    val (connAddress, mtu) = gattClient.connected.first { it.first == address }

    val peerConn = AndroidBLEPeerConnection(connAddress, isOutgoing = true)
    peersMutex.withLock { peerConnections[connAddress] = peerConn }
    return peerConn
}

override suspend fun disconnect(address: String) {
    val peerConn = peersMutex.withLock { peerConnections.remove(address) }
    if (peerConn != null) {
        peerConn.close()
    } else {
        // Try both client and server disconnect
        gattClient.disconnect(address)
        gattServer.disconnectCentral(address)
    }
}

override fun shutdown() {
    scanner.shutdown()
    advertiser.shutdown()
    gattClient.shutdown()
    gattServer.shutdown()
    operationQueue.shutdown()
    scope.cancel()
    _isRunning = false
}

// ---- Event Flows ----

private val _discoveredPeers = MutableSharedFlow<DiscoveredPeer>(extraBufferCapacity = 64)
override val discoveredPeers: SharedFlow<DiscoveredPeer> = _discoveredPeers.asSharedFlow()

private val _incomingConnections = MutableSharedFlow<BLEPeerConnection>(extraBufferCapacity = 16)
override val incomingConnections: SharedFlow<BLEPeerConnection> = _incomingConnections.asSharedFlow()

private val _connectionLost = MutableSharedFlow<String>(extraBufferCapacity = 16)
override val connectionLost: SharedFlow<String> = _connectionLost.asSharedFlow()

// ---- State ----

override val localAddress: String?
    get() = try { bluetoothAdapter.address } catch (_: SecurityException) { null }

@Volatile
private var _isRunning: Boolean = false
override val isRunning: Boolean get() = _isRunning
```

**Additional public API (not in BLEDriver, but needed by Phase 21):**
```kotlin
/**
 * Set the local transport identity hash.
 * Called by BLEInterface/Transport after Reticulum initialization.
 */
fun setTransportIdentity(identityHash: ByteArray) {
    gattServer.setTransportIdentity(identityHash)
}

/**
 * Get a peer connection by address (for Phase 21 orchestration).
 */
suspend fun getPeerConnection(address: String): BLEPeerConnection? {
    return peersMutex.withLock { peerConnections[address] }
}

/**
 * Restart advertising if needed after OEM auto-stop.
 * Called by gattServer connection state changes.
 */
fun restartAdvertisingIfNeeded() {
    advertiser.restartIfNeeded()
}
```

**Tag for logging:** `"AndroidBLEDriver"`
  </action>
  <verify>
Build rns-android to verify compilation:
```
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
The file should compile and implement BLEDriver correctly.
  </verify>
  <done>
AndroidBLEDriver.kt exists with:
- Implements BLEDriver interface from rns-interfaces
- Creates and owns BleGattServer, BleAdvertiser, BleScanner, BleGattClient, BleOperationQueue
- AndroidBLEPeerConnection inner class implementing BLEPeerConnection
- Event aggregation: scanner -> discoveredPeers, server -> incomingConnections, both -> connectionLost
- Data routing: component dataReceived -> peer connection receivedFragments
- connect() returns BLEPeerConnection after setup completes
- setTransportIdentity() for Phase 21 orchestration
  </done>
</task>

<task type="auto">
  <name>Task 2: Mark BLE components as internal visibility</name>
  <files>
    rns-android/src/main/kotlin/network/reticulum/android/ble/BleGattServer.kt
    rns-android/src/main/kotlin/network/reticulum/android/ble/BleAdvertiser.kt
    rns-android/src/main/kotlin/network/reticulum/android/ble/BleScanner.kt
    rns-android/src/main/kotlin/network/reticulum/android/ble/BleGattClient.kt
  </files>
  <action>
Mark the four BLE component classes as `internal` visibility per CONTEXT.md decision: "BLE classes (BleGattClient, BleScanner, BleGattServer, BleAdvertiser) are internal. Only AndroidBLEDriver is public API."

For each file, change the class declaration from:
```kotlin
class BleGattServer(
```
to:
```kotlin
internal class BleGattServer(
```

Do the same for:
- `BleAdvertiser` -- also its `AdvertiseMode` enum needs `internal` visibility
- `BleScanner` -- also its `ScanMode` enum needs `internal` visibility
- `BleGattClient`

Note: The `internal` modifier restricts visibility to the same Gradle module (`rns-android`). Since AndroidBLEDriver is in the same module, it can still access these classes. But consumers of `rns-android` (like `rns-sample-app`) will only see AndroidBLEDriver.

Do NOT make AndroidBLEDriver internal -- it must remain public (default visibility).
  </action>
  <verify>
Build rns-android to verify compilation still succeeds with internal visibility:
```
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
  </verify>
  <done>
BleGattServer, BleAdvertiser, BleScanner, and BleGattClient all have `internal` visibility. AndroidBLEDriver remains public as the sole BLE API surface from rns-android.
  </done>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin` succeeds
2. AndroidBLEDriver implements BLEDriver (all interface methods present)
3. AndroidBLEDriver.connect() returns a BLEPeerConnection
4. AndroidBLEPeerConnection.sendFragment() routes to gattClient.sendData (outgoing) or gattServer.sendNotification (incoming)
5. AndroidBLEPeerConnection.readIdentity() reads the Identity characteristic via gattClient
6. Event flows are properly aggregated from component flows to BLEDriver flows
7. BleGattServer, BleAdvertiser, BleScanner, BleGattClient all have `internal` visibility
8. AndroidBLEDriver is public (no `internal` modifier)
9. setTransportIdentity() passes through to gattServer
</verification>

<success_criteria>
- rns-android compiles with AndroidBLEDriver implementing BLEDriver
- DRV-03 (AndroidBLEDriver implements BLEDriver) is fully addressed
- Only AndroidBLEDriver is public from the rns-android BLE package
- Phase 21 can interact with BLE subsystem purely through BLEDriver interface
</success_criteria>

<output>
After completion, create `.planning/phases/20-gatt-client-scanner/20-02-SUMMARY.md`
</output>
