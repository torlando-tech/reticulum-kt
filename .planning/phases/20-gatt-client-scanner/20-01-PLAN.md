---
phase: 20-gatt-client-scanner
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/ble/BleScanner.kt
  - rns-android/src/main/kotlin/network/reticulum/android/ble/BleGattClient.kt

autonomous: true

must_haves:
  truths:
    - "Scanner discovers peers advertising Reticulum service UUID via hardware ScanFilter"
    - "Scanner runs as single long-running scan until explicitly stopped (no cycling)"
    - "Scanner emits DiscoveredPeer for each scan result, throttled per device"
    - "Scanner scan mode is user-configurable (LOW_POWER, BALANCED, LOW_LATENCY)"
    - "GATT client connects to peripheral, discovers Reticulum service, finds RX/TX/Identity characteristics"
    - "GATT client requests MTU 517, accepts any negotiated value, stores usable MTU (mtu-3)"
    - "GATT client enables TX notifications via CCCD descriptor write"
    - "All GATT client operations serialized via BleOperationQueue"
    - "GATT error 133 triggers full close + fresh connectGatt with exponential backoff (1s,2s,4s,8s)"
    - "5 retry attempts before temporary blacklist of peer address"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ble/BleScanner.kt"
      provides: "BLE scanner with service UUID filter, configurable scan mode, per-device throttle"
      exports: ["BleScanner"]
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ble/BleGattClient.kt"
      provides: "GATT client with connection, service discovery, MTU, CCCD, data send/receive, error 133 retry"
      exports: ["BleGattClient"]
  key_links:
    - from: "BleScanner.kt"
      to: "BLEConstants.kt"
      via: "imports SERVICE_UUID for ScanFilter, MIN_RSSI_DBM for threshold"
      pattern: "BLEConstants"
    - from: "BleScanner.kt"
      to: "DiscoveredPeer.kt"
      via: "creates DiscoveredPeer from ScanResult for each discovered device"
      pattern: "DiscoveredPeer"
    - from: "BleGattClient.kt"
      to: "BleOperationQueue.kt"
      via: "enqueues all GATT operations (write, read, MTU, CCCD) for serialization"
      pattern: "operationQueue\\.enqueue"
    - from: "BleGattClient.kt"
      to: "BLEConstants.kt"
      via: "imports SERVICE_UUID, RX_CHAR_UUID, TX_CHAR_UUID, IDENTITY_CHAR_UUID, CCCD_UUID, MAX_MTU"
      pattern: "BLEConstants"
---

<objective>
Implement BleScanner.kt and BleGattClient.kt -- the two central-role BLE components for discovering and connecting to Reticulum BLE peripherals.

Purpose: These are the counterparts to Phase 19's peripheral-role components (BleGattServer + BleAdvertiser). The scanner discovers nearby Reticulum devices by service UUID. The GATT client connects, discovers services, negotiates MTU, enables notifications, and provides data send/receive. Together they enable the device to act as a BLE central.

Output: `BleScanner.kt` and `BleGattClient.kt` in `rns-android/src/main/kotlin/network/reticulum/android/ble/`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/20-gatt-client-scanner/20-CONTEXT.md

# Reference implementations (read these for patterns):
@~/repos/columba/reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/client/BleScanner.kt
@~/repos/columba/reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/client/BleGattClient.kt

# Phase 18 outputs (use for constants, types, operation queue):
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEConstants.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEDriver.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BleOperationQueue.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/DiscoveredPeer.kt

# Phase 19 outputs (sibling components in same package):
@rns-android/src/main/kotlin/network/reticulum/android/ble/BleGattServer.kt
@rns-android/src/main/kotlin/network/reticulum/android/ble/BleAdvertiser.kt

# Existing GATT client code in project (NUS-based, different service -- adapt patterns):
@rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/service/BluetoothLeConnection.kt

# Module structure:
@rns-android/build.gradle.kts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement BleScanner.kt</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ble/BleScanner.kt</files>
  <action>
Create `BleScanner.kt` in `network.reticulum.android.ble`. This manages BLE scanning for peer discovery.

**KEY DIFFERENCES from Columba's BleScanner:**
- Single long-running scan (no cycling/intervals) per CONTEXT.md decision
- Emits `DiscoveredPeer` from rns-interfaces (not a custom BleDevice type)
- SharedFlow events instead of nullable callbacks
- Per-device throttle to reduce noise while still updating RSSI
- User-configurable scan mode via enum (similar to BleAdvertiser.AdvertiseMode)
- Hardware service UUID ScanFilter (offloaded to BLE chip)

**Class signature:**
```kotlin
class BleScanner(
    private val context: Context,
    private val bluetoothAdapter: BluetoothAdapter,
    private val scope: CoroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()),
)
```

**Scan mode enum:**
```kotlin
enum class ScanMode(val value: Int) {
    LOW_POWER(ScanSettings.SCAN_MODE_LOW_POWER),
    BALANCED(ScanSettings.SCAN_MODE_BALANCED),
    LOW_LATENCY(ScanSettings.SCAN_MODE_LOW_LATENCY),
}
```

**Per-device throttle:**
Track last emission time per device address. Only emit a new DiscoveredPeer if at least N seconds have passed since last emit for that address. Use 3 seconds as default throttle interval. This reduces scan callback noise while keeping RSSI scoring data fresh.

```kotlin
private val lastEmitTimes = mutableMapOf<String, Long>()
private val throttleMutex = Mutex()
private val throttleIntervalMs = 3_000L
```

**ScanCallback:**
```kotlin
private val scanCallback = object : ScanCallback() {
    override fun onScanResult(callbackType: Int, result: ScanResult) {
        scope.launch { handleScanResult(result) }
    }

    override fun onBatchScanResults(results: List<ScanResult>) {
        scope.launch { results.forEach { handleScanResult(it) } }
    }

    override fun onScanFailed(errorCode: Int) {
        Log.e(TAG, "BLE scan failed: errorCode=$errorCode")
        _isScanning.value = false
    }
}
```

**handleScanResult:**
- Filter results below BLEConstants.MIN_RSSI_DBM
- Check throttle: skip if last emit for this address was < throttleIntervalMs ago
- Create DiscoveredPeer(address, rssi, lastSeen=now)
- Emit to SharedFlow

**Public API:**
- `suspend fun startScanning(mode: ScanMode = ScanMode.BALANCED): Result<Unit>`
  - Check bluetooth enabled, permission, scanner availability
  - Build ScanFilter with SERVICE_UUID
  - Build ScanSettings with user-chosen mode, CALLBACK_TYPE_ALL_MATCHES, reportDelay=0
  - Start scan (single long-running, no cycling)
  - Note: Do NOT use MATCH_MODE_STICKY -- let the hardware report all matches

- `suspend fun stopScanning()`
  - Stop scan via BluetoothLeScanner.stopScan
  - Set _isScanning to false

- `fun shutdown()` -- stop scanning, cancel scope

**Event flows (SharedFlow, replay=0, extraBufferCapacity=64):**
- `val discoveredPeers: SharedFlow<DiscoveredPeer>` -- emits for each scan result (throttled per device)

**State:**
- `val isScanning: StateFlow<Boolean>` -- current scan state

**Permission check:**
Check BLUETOOTH_SCAN on API 31+, ACCESS_FINE_LOCATION on API 30-.

**Tag for logging:** `"BleScanner"`
  </action>
  <verify>
Build rns-android to verify compilation:
```
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
The file should compile and import DiscoveredPeer from rns-interfaces.
  </verify>
  <done>
BleScanner.kt exists with:
- Single long-running scan with hardware service UUID ScanFilter
- User-configurable ScanMode enum (LOW_POWER, BALANCED, LOW_LATENCY)
- Per-device throttle (3s default) to reduce noise
- DiscoveredPeer emitted via SharedFlow
- RSSI filtering at BLEConstants.MIN_RSSI_DBM
- Proper permission checks for API 31+ and 30-
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement BleGattClient.kt</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ble/BleGattClient.kt</files>
  <action>
Create `BleGattClient.kt` in `network.reticulum.android.ble`. This handles central-mode GATT operations.

**KEY DIFFERENCES from Columba's BleGattClient:**
- Uses the rns-interfaces BleOperationQueue (generic suspend-based) instead of Columba's Android-coupled BleOperationQueue
- SharedFlow events instead of nullable callbacks
- No identity handshake or keepalive logic (that's Phase 21's BLEInterface concern)
- No MAC sorting (that's Phase 21)
- Simpler flow: connect -> discover services -> request MTU -> enable CCCD -> ready
- Connection-level state uses a per-address ConnectionData class

**IMPORTANT: BleOperationQueue usage pattern.**
Our BleOperationQueue is a generic suspend-function serializer. It does NOT have completeOperationByKey() like Columba's. Instead, each GATT callback completes a CompletableDeferred that the enqueued operation is awaiting. The pattern is:

```kotlin
// In the enqueued operation:
operationQueue.enqueue {
    val deferred = CompletableDeferred<Int>()
    // Store deferred so callback can find it
    pendingMtuDeferred = deferred
    // Start GATT operation
    gatt.requestMtu(BLEConstants.MAX_MTU)
    // Suspend until callback completes it
    deferred.await()
}

// In onMtuChanged callback:
pendingMtuDeferred?.complete(mtu)
```

This is the same CompletableDeferred pattern used by BleGattServer for notification serialization.

**Class signature:**
```kotlin
class BleGattClient(
    private val context: Context,
    private val bluetoothAdapter: BluetoothAdapter,
    private val operationQueue: BleOperationQueue,
    private val scope: CoroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()),
)
```

**ConnectionData (private inner class):**
```kotlin
private data class ConnectionData(
    val gatt: BluetoothGatt,
    val address: String,
    var mtu: Int = BLEConstants.MIN_MTU,
    var rxCharacteristic: BluetoothGattCharacteristic? = null,
    var txCharacteristic: BluetoothGattCharacteristic? = null,
    var identityCharacteristic: BluetoothGattCharacteristic? = null,
    var retryCount: Int = 0,
    var connectionJob: Job? = null,
)
```

**Active connections:**
```kotlin
private val connections = mutableMapOf<String, ConnectionData>()
private val connectionsMutex = Mutex()
```

**Pending deferreds for GATT callback bridge (one active at a time via operationQueue):**
```kotlin
private var pendingServiceDiscovery: CompletableDeferred<Boolean>? = null
private var pendingMtuDeferred: CompletableDeferred<Int>? = null
private var pendingWriteDeferred: CompletableDeferred<Int>? = null
private var pendingReadDeferred: CompletableDeferred<ByteArray>? = null
private var pendingDescriptorWriteDeferred: CompletableDeferred<Int>? = null
```

**BluetoothGattCallback (per-connection):**
Create a named inner class `GattCallback(address: String)` extending BluetoothGattCallback.
ALL callbacks dispatch to `scope.launch { ... }`.

1. **onConnectionStateChange(gatt, status, newState):**
   - `GATT_SUCCESS + STATE_CONNECTED`: Cancel timeout job, request CONNECTION_PRIORITY_HIGH, start service discovery sequence via `setupConnection(address, gatt)`.
   - `status == 133 (GATT_ERROR_133)`: Call `handleError133(address, gatt)`.
   - `STATE_DISCONNECTED`: Remove from connections map, close gatt, emit disconnect event.

2. **onServicesDiscovered(gatt, status):**
   - Complete pendingServiceDiscovery with success/failure.

3. **onMtuChanged(gatt, mtu, status):**
   - Complete pendingMtuDeferred with the mtu value.
   - Also update the connection's usable MTU (mtu - 3) and emit mtuChanged event.

4. **onCharacteristicChanged(gatt, characteristic, value):**
   - If TX characteristic: emit (address, data) on dataReceived SharedFlow.

5. **onCharacteristicWrite(gatt, characteristic, status):**
   - Complete pendingWriteDeferred with status.

6. **onCharacteristicRead(gatt, characteristic, value, status):**
   - Complete pendingReadDeferred with value (or exception on failure).

7. **onDescriptorWrite(gatt, descriptor, status):**
   - Complete pendingDescriptorWriteDeferred with status.

**setupConnection(address, gatt) -- the post-connect sequence:**
This runs as a single coroutine after onConnectionStateChange reports STATE_CONNECTED.
All GATT operations go through operationQueue to serialize with any other connections.

```kotlin
private suspend fun setupConnection(address: String, gatt: BluetoothGatt) {
    try {
        // 1. Discover services
        operationQueue.enqueue(timeoutMs = BLEConstants.OPERATION_TIMEOUT_MS) {
            val deferred = CompletableDeferred<Boolean>()
            pendingServiceDiscovery = deferred
            withContext(Dispatchers.Main) { gatt.discoverServices() }
            val success = deferred.await()
            if (!success) throw IllegalStateException("Service discovery failed")
        }

        // 2. Find Reticulum service and characteristics
        val service = gatt.getService(BLEConstants.SERVICE_UUID)
            ?: throw IllegalStateException("Reticulum service not found")
        val rxChar = service.getCharacteristic(BLEConstants.RX_CHAR_UUID)
            ?: throw IllegalStateException("RX characteristic not found")
        val txChar = service.getCharacteristic(BLEConstants.TX_CHAR_UUID)
            ?: throw IllegalStateException("TX characteristic not found")
        val identityChar = service.getCharacteristic(BLEConstants.IDENTITY_CHAR_UUID)

        connectionsMutex.withLock {
            connections[address]?.apply {
                rxCharacteristic = rxChar
                txCharacteristic = txChar
                identityCharacteristic = identityChar
            }
        }

        // 3. Request MTU
        operationQueue.enqueue(timeoutMs = BLEConstants.OPERATION_TIMEOUT_MS) {
            val deferred = CompletableDeferred<Int>()
            pendingMtuDeferred = deferred
            withContext(Dispatchers.Main) { gatt.requestMtu(BLEConstants.MAX_MTU) }
            deferred.await() // value stored via onMtuChanged
        }

        // 4. Enable TX notifications: setCharacteristicNotification locally
        withContext(Dispatchers.Main) {
            gatt.setCharacteristicNotification(txChar, true)
        }

        // 5. Write CCCD descriptor to enable remote notifications
        val cccd = txChar.getDescriptor(BLEConstants.CCCD_UUID)
            ?: throw IllegalStateException("CCCD descriptor not found on TX characteristic")

        operationQueue.enqueue(timeoutMs = BLEConstants.OPERATION_TIMEOUT_MS) {
            val deferred = CompletableDeferred<Int>()
            pendingDescriptorWriteDeferred = deferred
            withContext(Dispatchers.Main) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    gatt.writeDescriptor(cccd, BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE)
                } else {
                    @Suppress("DEPRECATION")
                    cccd.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
                    @Suppress("DEPRECATION")
                    gatt.writeDescriptor(cccd)
                }
            }
            val status = deferred.await()
            if (status != BluetoothGatt.GATT_SUCCESS) {
                throw IllegalStateException("CCCD write failed: status=$status")
            }
        }

        // Connection setup complete -- emit connected event
        val mtu = connectionsMutex.withLock { connections[address]?.mtu ?: BLEConstants.MIN_MTU }
        _connected.tryEmit(address to mtu)

    } catch (e: Exception) {
        Log.e(TAG, "Connection setup failed for $address", e)
        // Clean up failed connection
        connectionsMutex.withLock { connections.remove(address) }
        withContext(Dispatchers.Main) {
            gatt.disconnect()
            gatt.close()
        }
        _connectionFailed.tryEmit(address to (e.message ?: "Setup failed"))
    }
}
```

**GATT error 133 handling (CLI-05):**
```kotlin
private suspend fun handleError133(address: String, gatt: BluetoothGatt) {
    Log.e(TAG, "GATT error 133 for $address")

    // Full teardown -- close immediately (no graceful disconnect per CONTEXT.md)
    withContext(Dispatchers.Main) { gatt.close() }

    val retryCount = connectionsMutex.withLock {
        val conn = connections.remove(address)
        conn?.retryCount ?: 0
    }

    if (retryCount < MAX_RETRIES) {
        val nextRetry = retryCount + 1
        val backoffMs = INITIAL_BACKOFF_MS * (1L shl retryCount) // 1s, 2s, 4s, 8s, 16s
        Log.d(TAG, "Retrying $address (attempt $nextRetry/$MAX_RETRIES) in ${backoffMs}ms")

        scope.launch {
            delay(backoffMs)
            val result = connect(address, retryCount = nextRetry)
            if (result.isFailure) {
                _connectionFailed.tryEmit(address to "GATT 133: max retries after $nextRetry attempts")
            }
        }
    } else {
        Log.e(TAG, "Max retries exceeded for $address, blacklisting temporarily")
        // Add to temporary blacklist
        blacklistedAddresses[address] = System.currentTimeMillis()
        _connectionFailed.tryEmit(address to "GATT 133: max retries exceeded, blacklisted")
    }
}
```

**Temporary blacklist:**
```kotlin
private val blacklistedAddresses = mutableMapOf<String, Long>()
private val blacklistDurationMs = 60_000L // 1 minute cooldown

private fun isBlacklisted(address: String): Boolean {
    val blacklistedAt = blacklistedAddresses[address] ?: return false
    if (System.currentTimeMillis() - blacklistedAt > blacklistDurationMs) {
        blacklistedAddresses.remove(address)
        return false
    }
    return true
}
```

**Public API:**
- `suspend fun connect(address: String, retryCount: Int = 0): Result<Unit>`
  - Check not already connected, not blacklisted
  - Check permission
  - Get remote device via bluetoothAdapter.getRemoteDevice
  - Start connection timeout job (BLEConstants.CONNECTION_TIMEOUT_MS)
  - Call device.connectGatt(context, false, GattCallback(address), TRANSPORT_LE)
  - Store ConnectionData with retryCount
  - Return Result.success (actual setup is async via setupConnection)

- `suspend fun disconnect(address: String)`
  - Remove from connections, cancel timeout job, gatt.disconnect(), gatt.close()
  - Emit disconnect event

- `suspend fun sendData(address: String, data: ByteArray): Result<Unit>`
  - Get ConnectionData and rxCharacteristic
  - Enqueue write via operationQueue:
    ```
    operationQueue.enqueue {
        val deferred = CompletableDeferred<Int>()
        pendingWriteDeferred = deferred
        withContext(Dispatchers.Main) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                gatt.writeCharacteristic(rxChar, data, BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT)
            } else {
                rxChar.value = data
                rxChar.writeType = BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT
                gatt.writeCharacteristic(rxChar)
            }
        }
        val status = deferred.await()
        if (status != BluetoothGatt.GATT_SUCCESS) throw Exception("Write failed: $status")
    }
    ```

- `suspend fun readCharacteristic(address: String, characteristicUuid: UUID): ByteArray`
  - Get ConnectionData, find characteristic
  - Enqueue read via operationQueue with CompletableDeferred<ByteArray>

- `suspend fun getMtu(address: String): Int?`
  - Return usable MTU from ConnectionData

- `suspend fun isConnected(address: String): Boolean`

- `fun shutdown()` -- disconnect all, cancel scope

**Event flows (SharedFlow, replay=0, extraBufferCapacity=16):**
- `val connected: SharedFlow<Pair<String, Int>>` -- (address, mtu) when setup complete
- `val disconnected: SharedFlow<String>` -- address on disconnect
- `val connectionFailed: SharedFlow<Pair<String, String>>` -- (address, reason)
- `val dataReceived: SharedFlow<Pair<String, ByteArray>>` -- (address, data) from TX notifications
- `val mtuChanged: SharedFlow<Pair<String, Int>>` -- (address, usableMtu)

**Constants:**
```kotlin
companion object {
    private const val TAG = "BleGattClient"
    private const val MAX_RETRIES = 5
    private const val INITIAL_BACKOFF_MS = 1_000L
    private const val GATT_ERROR_133 = 133
}
```

**Permission check:**
Same pattern as BleGattServer -- check BLUETOOTH_CONNECT on API 31+.

**Connection timeout:**
Launch a coroutine that delays CONNECTION_TIMEOUT_MS, then disconnects and emits connectionFailed if the connection hasn't completed setup yet.
  </action>
  <verify>
Build rns-android to verify compilation:
```
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
The file should compile and import BleOperationQueue, BLEConstants from rns-interfaces.
  </verify>
  <done>
BleGattClient.kt exists with:
- connect() creating GATT connection with TRANSPORT_LE
- setupConnection() performing discover services -> MTU 517 -> enable CCCD in sequence
- All GATT operations serialized via BleOperationQueue.enqueue
- CompletableDeferred bridge between GATT callbacks and coroutines
- GATT error 133: full close + exponential backoff retry (1s,2s,4s,8s,16s)
- 5 retry limit with temporary blacklist (60s cooldown)
- API 33 compat for writeCharacteristic and writeDescriptor
- SharedFlow events for connected/disconnected/dataReceived/mtuChanged/connectionFailed
  </done>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin` succeeds
2. BleScanner.kt imports DiscoveredPeer from rns-interfaces, BLEConstants.SERVICE_UUID for ScanFilter
3. BleScanner.kt uses a single long-running scan (no cycling/start-stop pattern)
4. BleGattClient.kt imports BleOperationQueue from rns-interfaces for GATT serialization
5. BleGattClient.kt setupConnection sequence: discoverServices -> requestMtu(517) -> setCharacteristicNotification -> writeDescriptor(CCCD)
6. GATT error 133 triggers gatt.close() + exponential backoff retry (not gatt.disconnect() first)
7. MTU stored as (mtu - 3) in ConnectionData
8. All GATT write/read/discover/MTU/descriptor operations go through operationQueue.enqueue
</verification>

<success_criteria>
- rns-android compiles with new BleScanner and BleGattClient
- CLI-01 (scanner with UUID filter), CLI-02 (connect/discover/CCCD), CLI-03 (MTU 517), CLI-04 (operation queue), CLI-05 (error 133 retry) all addressed
- Both classes follow Phase 19's patterns (SharedFlow, permission checks, scope.launch callbacks)
</success_criteria>

<output>
After completion, create `.planning/phases/20-gatt-client-scanner/20-01-SUMMARY.md`
</output>
