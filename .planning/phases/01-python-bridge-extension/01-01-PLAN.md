---
phase: 01-python-bridge-extension
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python-bridge/bridge_server.py
autonomous: true

must_haves:
  truths:
    - "Bridge server can create LXMessage payload from provided parameters"
    - "Bridge server can serialize LXMessage to bytes and return components"
    - "Bridge server can deserialize LXMessage bytes and return all fields"
    - "Bridge server can compute LXMF message hash from components"
    - "Bridge server can generate stamp workblock from message ID"
    - "Bridge server can validate stamp against cost and workblock"
    - "Bridge server can generate stamp meeting target cost"
  artifacts:
    - path: "python-bridge/bridge_server.py"
      provides: "6 LXMF bridge commands"
      contains: "cmd_lxmf_pack"
  key_links:
    - from: "python-bridge/bridge_server.py"
      to: "~/repos/LXMF/LXMF/LXStamper.py"
      via: "sys.path import"
      pattern: "import LXMF"
---

<objective>
Add LXMF commands to Python bridge server for cross-implementation testing.

Purpose: Enable Kotlin LXMF implementation testing against Python reference. All subsequent phases depend on these bridge commands to verify byte-level interoperability.

Output: 6 new bridge commands (lxmf_pack, lxmf_unpack, lxmf_hash, lxmf_stamp_workblock, lxmf_stamp_valid, lxmf_stamp_generate) following established bridge patterns.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-python-bridge-extension/01-RESEARCH.md

# Reference for existing bridge pattern
@python-bridge/bridge_server.py (lines 1-100 for imports, 245-280 for cmd pattern, 2615-2710 for COMMANDS dict)

# LXMF reference implementations
@~/repos/LXMF/LXMF/LXMessage.py (lines 360-392 for pack, 734-805 for unpack_from_bytes)
@~/repos/LXMF/LXMF/LXStamper.py (lines 20-48 for stamp_workblock, stamp_value, stamp_valid; 92-111 for generate_stamp)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LXMF import to bridge server</name>
  <files>python-bridge/bridge_server.py</files>
  <action>
Add LXMF path to sys.path and import LXStamper module.

After the RNS path setup (around line 26, after `sys.path.insert(0, rns_path)`), add:

```python
# Add LXMF to path
lxmf_path = os.path.abspath(os.environ.get('PYTHON_LXMF_PATH', '../../../LXMF'))
sys.path.insert(0, lxmf_path)
```

After the existing module imports (after hashlib import around line 28), add:

```python
# Import LXMF stamper (used for stamp generation/validation)
import LXMF.LXStamper as LXStamper
```

Note: We do NOT import LXMessage class because it requires RNS Destination objects.
Instead, we will directly work with the wire format following LXMessage.pack() and
unpack_from_bytes() logic. This avoids the "LXMessage initialised with invalid destination"
pitfall documented in research.
  </action>
  <verify>
Run bridge server and verify no import errors:
```bash
cd ./python-bridge && timeout 2 python3 bridge_server.py 2>&1 | head -5
```
Should show "READY" without import errors.
  </verify>
  <done>LXMF path configured and LXStamper imported successfully</done>
</task>

<task type="auto">
  <name>Task 2: Add 6 LXMF bridge commands</name>
  <files>python-bridge/bridge_server.py</files>
  <action>
Add 6 new cmd_* functions before the COMMANDS dict (around line 2610), then register them in COMMANDS dict.

**Function 1: cmd_lxmf_pack**
Pack LXMF message components to wire format pieces.
```python
def cmd_lxmf_pack(params):
    """Pack LXMF message from components.

    Follows LXMessage.pack() logic but works with raw hashes instead of Destination objects.
    Hash is computed WITHOUT stamp, then stamp can be added to payload separately.
    """
    destination_hash = hex_to_bytes(params['destination_hash'])
    source_hash = hex_to_bytes(params['source_hash'])
    timestamp = float(params['timestamp'])
    title = params.get('title', '')
    content = params.get('content', '')
    fields = params.get('fields', {})

    # Convert string field keys to int (JSON only supports string keys)
    if fields:
        fields = {int(k): v for k, v in fields.items()}

    # Encode title and content as bytes
    title_bytes = title.encode('utf-8') if isinstance(title, str) else title
    content_bytes = content.encode('utf-8') if isinstance(content, str) else content

    # Build payload: [timestamp, title, content, fields]
    payload = [timestamp, title_bytes, content_bytes, fields]
    packed_payload = umsgpack.packb(payload)

    # Compute hash: SHA256(dest_hash + source_hash + packed_payload)
    hashed_part = destination_hash + source_hash + packed_payload
    message_hash = hashlib.sha256(hashed_part).digest()

    # Signed part: hashed_part + hash
    signed_part = hashed_part + message_hash

    return {
        'packed_payload': bytes_to_hex(packed_payload),
        'hashed_part': bytes_to_hex(hashed_part),
        'message_hash': bytes_to_hex(message_hash),
        'signed_part': bytes_to_hex(signed_part)
    }
```

**Function 2: cmd_lxmf_unpack**
Unpack LXMF message bytes to components.
```python
def cmd_lxmf_unpack(params):
    """Unpack LXMF message bytes to components.

    Follows LXMessage.unpack_from_bytes() logic.
    Extracts stamp from payload if present, recomputes hash without stamp.
    """
    lxmf_bytes = hex_to_bytes(params['lxmf_bytes'])

    DEST_LEN = 16  # LXMessage.DESTINATION_LENGTH
    SIG_LEN = 64   # LXMessage.SIGNATURE_LENGTH

    destination_hash = lxmf_bytes[:DEST_LEN]
    source_hash = lxmf_bytes[DEST_LEN:2*DEST_LEN]
    signature = lxmf_bytes[2*DEST_LEN:2*DEST_LEN+SIG_LEN]
    packed_payload = lxmf_bytes[2*DEST_LEN+SIG_LEN:]

    unpacked_payload = umsgpack.unpackb(packed_payload)

    # Extract stamp if present (5th element)
    stamp = None
    if len(unpacked_payload) > 4:
        stamp = unpacked_payload[4]
        unpacked_payload = unpacked_payload[:4]
        # Repack without stamp for hash computation
        packed_payload = umsgpack.packb(unpacked_payload)

    # Compute hash (always without stamp)
    hashed_part = destination_hash + source_hash + packed_payload
    message_hash = hashlib.sha256(hashed_part).digest()

    # Decode title/content
    title_bytes = unpacked_payload[1]
    content_bytes = unpacked_payload[2]
    title = title_bytes.decode('utf-8') if isinstance(title_bytes, bytes) else title_bytes
    content = content_bytes.decode('utf-8') if isinstance(content_bytes, bytes) else content_bytes

    return {
        'destination_hash': bytes_to_hex(destination_hash),
        'source_hash': bytes_to_hex(source_hash),
        'signature': bytes_to_hex(signature),
        'timestamp': unpacked_payload[0],
        'title': title,
        'content': content,
        'fields': unpacked_payload[3],
        'stamp': bytes_to_hex(stamp) if stamp else None,
        'message_hash': bytes_to_hex(message_hash)
    }
```

**Function 3: cmd_lxmf_hash**
Compute LXMF message hash from components (convenience wrapper).
```python
def cmd_lxmf_hash(params):
    """Compute LXMF message hash from components.

    Hash = SHA256(destination_hash + source_hash + packed_payload)
    This is the message_id used for stamp generation.
    """
    destination_hash = hex_to_bytes(params['destination_hash'])
    source_hash = hex_to_bytes(params['source_hash'])
    timestamp = float(params['timestamp'])
    title = params.get('title', '')
    content = params.get('content', '')
    fields = params.get('fields', {})

    # Convert string field keys to int
    if fields:
        fields = {int(k): v for k, v in fields.items()}

    # Encode title and content
    title_bytes = title.encode('utf-8') if isinstance(title, str) else title
    content_bytes = content.encode('utf-8') if isinstance(content, str) else content

    # Build payload and hash
    payload = [timestamp, title_bytes, content_bytes, fields]
    packed_payload = umsgpack.packb(payload)
    hashed_part = destination_hash + source_hash + packed_payload
    message_hash = hashlib.sha256(hashed_part).digest()

    return {
        'message_hash': bytes_to_hex(message_hash)
    }
```

**Function 4: cmd_lxmf_stamp_workblock**
Generate stamp workblock from message ID.
```python
def cmd_lxmf_stamp_workblock(params):
    """Generate stamp workblock from message ID.

    Uses LXStamper.stamp_workblock() for exact Python compatibility.
    Default expand_rounds=3000 for standard LXMF stamps.
    """
    message_id = hex_to_bytes(params['message_id'])
    expand_rounds = int(params.get('expand_rounds', 3000))

    workblock = LXStamper.stamp_workblock(message_id, expand_rounds=expand_rounds)

    return {
        'workblock': bytes_to_hex(workblock),
        'size': len(workblock)
    }
```

**Function 5: cmd_lxmf_stamp_valid**
Validate stamp against cost and workblock.
```python
def cmd_lxmf_stamp_valid(params):
    """Validate stamp against target cost and workblock.

    Uses LXStamper.stamp_valid() and stamp_value() for exact Python compatibility.
    """
    stamp = hex_to_bytes(params['stamp'])
    target_cost = int(params['target_cost'])
    workblock = hex_to_bytes(params['workblock'])

    valid = LXStamper.stamp_valid(stamp, target_cost, workblock)
    value = LXStamper.stamp_value(workblock, stamp) if valid else 0

    return {
        'valid': valid,
        'value': value
    }
```

**Function 6: cmd_lxmf_stamp_generate**
Generate stamp meeting target cost.
```python
def cmd_lxmf_stamp_generate(params):
    """Generate stamp meeting target cost.

    Uses LXStamper.generate_stamp() for exact Python compatibility.
    WARNING: Can be slow for high costs. Use expand_rounds=25 for quick tests.
    """
    message_id = hex_to_bytes(params['message_id'])
    stamp_cost = int(params['stamp_cost'])
    expand_rounds = int(params.get('expand_rounds', 3000))

    stamp, value = LXStamper.generate_stamp(message_id, stamp_cost, expand_rounds=expand_rounds)

    return {
        'stamp': bytes_to_hex(stamp) if stamp else None,
        'value': value
    }
```

**Register in COMMANDS dict:**
Add to COMMANDS dict (inside the dict, after bz2 operations section):
```python
    # LXMF operations
    'lxmf_pack': cmd_lxmf_pack,
    'lxmf_unpack': cmd_lxmf_unpack,
    'lxmf_hash': cmd_lxmf_hash,
    'lxmf_stamp_workblock': cmd_lxmf_stamp_workblock,
    'lxmf_stamp_valid': cmd_lxmf_stamp_valid,
    'lxmf_stamp_generate': cmd_lxmf_stamp_generate,
```
  </action>
  <verify>
Run a quick test of each command via the bridge:
```bash
cd ./python-bridge
echo '{"id":"1","command":"lxmf_pack","params":{"destination_hash":"00112233445566778899aabbccddeeff","source_hash":"ffeeddccbbaa99887766554433221100","timestamp":1700000000.0,"title":"Test","content":"Hello"}}' | timeout 5 python3 bridge_server.py | tail -1 | python3 -c "import sys,json; r=json.load(sys.stdin); print('OK' if r['success'] and 'message_hash' in r['result'] else 'FAIL')"
```
Should output "OK".

Also verify workblock generation (with low expand_rounds for speed):
```bash
echo '{"id":"2","command":"lxmf_stamp_workblock","params":{"message_id":"00112233445566778899aabbccddeeff00112233445566778899aabbccddeeff","expand_rounds":10}}' | timeout 5 python3 bridge_server.py | tail -1 | python3 -c "import sys,json; r=json.load(sys.stdin); print('OK' if r['success'] and r['result']['size'] == 2560 else 'FAIL')"
```
Should output "OK" (workblock size = 256 bytes * expand_rounds).
  </verify>
  <done>6 LXMF commands implemented and registered in bridge server</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Import verification**: Bridge starts without errors
2. **Pack/Unpack round-trip**: Pack a message, unpack it, verify fields match
3. **Hash computation**: Hash from pack matches hash from unpack
4. **Stamp operations**: Generate workblock, generate stamp, validate stamp

Quick end-to-end test:
```bash
cd ./python-bridge
# Test pack -> unpack round-trip
python3 -c "
import json
import subprocess

# Start bridge
proc = subprocess.Popen(['python3', 'bridge_server.py'],
    stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True)
proc.stdout.readline()  # Consume READY

# Pack a message
pack_req = json.dumps({
    'id': '1',
    'command': 'lxmf_pack',
    'params': {
        'destination_hash': '00112233445566778899aabbccddeeff',
        'source_hash': 'ffeeddccbbaa99887766554433221100',
        'timestamp': 1700000000.0,
        'title': 'Test',
        'content': 'Hello World'
    }
})
proc.stdin.write(pack_req + '\n')
proc.stdin.flush()
pack_resp = json.loads(proc.stdout.readline())
assert pack_resp['success'], f'Pack failed: {pack_resp}'
print(f'Pack OK: hash={pack_resp[\"result\"][\"message_hash\"][:16]}...')

# Construct full message bytes (dest + source + signature + payload)
# For this test, use zero signature since we don't have signing
import binascii
dest = binascii.unhexlify(pack_req[pack_req.find('destination_hash')+19:pack_req.find('destination_hash')+51])
src = binascii.unhexlify('ffeeddccbbaa99887766554433221100')
sig = b'\\x00' * 64
payload = binascii.unhexlify(pack_resp['result']['packed_payload'])
lxmf_bytes = dest + src + sig + payload

# Unpack the message
unpack_req = json.dumps({
    'id': '2',
    'command': 'lxmf_unpack',
    'params': {
        'lxmf_bytes': binascii.hexlify(lxmf_bytes).decode()
    }
})
proc.stdin.write(unpack_req + '\n')
proc.stdin.flush()
unpack_resp = json.loads(proc.stdout.readline())
assert unpack_resp['success'], f'Unpack failed: {unpack_resp}'
assert unpack_resp['result']['title'] == 'Test', 'Title mismatch'
assert unpack_resp['result']['content'] == 'Hello World', 'Content mismatch'
assert unpack_resp['result']['message_hash'] == pack_resp['result']['message_hash'], 'Hash mismatch'
print('Unpack OK: round-trip verified')

# Test stamp workblock (low rounds for speed)
wb_req = json.dumps({
    'id': '3',
    'command': 'lxmf_stamp_workblock',
    'params': {
        'message_id': pack_resp['result']['message_hash'],
        'expand_rounds': 25
    }
})
proc.stdin.write(wb_req + '\n')
proc.stdin.flush()
wb_resp = json.loads(proc.stdout.readline())
assert wb_resp['success'], f'Workblock failed: {wb_resp}'
assert wb_resp['result']['size'] == 6400, f'Wrong workblock size: {wb_resp[\"result\"][\"size\"]}'
print(f'Workblock OK: size={wb_resp[\"result\"][\"size\"]}')

# Test stamp generation with low cost (for speed)
gen_req = json.dumps({
    'id': '4',
    'command': 'lxmf_stamp_generate',
    'params': {
        'message_id': pack_resp['result']['message_hash'],
        'stamp_cost': 4,
        'expand_rounds': 25
    }
})
proc.stdin.write(gen_req + '\n')
proc.stdin.flush()
gen_resp = json.loads(proc.stdout.readline())
assert gen_resp['success'], f'Stamp gen failed: {gen_resp}'
assert gen_resp['result']['stamp'] is not None, 'No stamp generated'
assert gen_resp['result']['value'] >= 4, f'Stamp value too low: {gen_resp[\"result\"][\"value\"]}'
print(f'Stamp generate OK: value={gen_resp[\"result\"][\"value\"]}')

# Test stamp validation
valid_req = json.dumps({
    'id': '5',
    'command': 'lxmf_stamp_valid',
    'params': {
        'stamp': gen_resp['result']['stamp'],
        'target_cost': 4,
        'workblock': wb_resp['result']['workblock']
    }
})
proc.stdin.write(valid_req + '\n')
proc.stdin.flush()
valid_resp = json.loads(proc.stdout.readline())
assert valid_resp['success'], f'Stamp valid failed: {valid_resp}'
assert valid_resp['result']['valid'] == True, 'Stamp should be valid'
print(f'Stamp valid OK: valid=True, value={valid_resp[\"result\"][\"value\"]}')

proc.terminate()
print('\\nAll LXMF bridge commands working!')
"
```
</verification>

<success_criteria>
- [ ] Bridge server starts without import errors
- [ ] `lxmf_pack` returns packed_payload, hashed_part, message_hash, signed_part
- [ ] `lxmf_unpack` correctly extracts all fields from message bytes
- [ ] `lxmf_hash` computes same hash as pack operation
- [ ] `lxmf_stamp_workblock` generates workblock of expected size
- [ ] `lxmf_stamp_valid` correctly validates stamps against cost
- [ ] `lxmf_stamp_generate` produces stamps meeting target cost
- [ ] Pack -> unpack round-trip preserves all fields
</success_criteria>

<output>
After completion, create `.planning/phases/01-python-bridge-extension/01-01-SUMMARY.md`
</output>
