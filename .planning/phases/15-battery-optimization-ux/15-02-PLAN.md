---
phase: 15-battery-optimization-ux
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/ServiceEventTracker.kt
  - rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt
autonomous: true

must_haves:
  truths:
    - "Service kill events are counted and persisted across restarts"
    - "User can see concrete kill count (e.g., 'Service killed 3 times today')"
    - "Event counts reset daily so stale data does not accumulate"
    - "Warning dismissal is remembered and only resurfaces on new events"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ServiceEventTracker.kt"
      provides: "Optimization event counting, persistence, and dismissal memory"
      min_lines: 60
  key_links:
    - from: "ServiceEventTracker"
      to: "SharedPreferences"
      via: "persists kill counts and dismissal state"
      pattern: "getSharedPreferences"
    - from: "ReticulumService"
      to: "ServiceEventTracker"
      via: "records events on service lifecycle"
      pattern: "eventTracker"
---

<objective>
Create service event tracking for battery optimization impact visibility.

Purpose: Track how often the service is killed by the system (optimization-caused events) and provide dismissable warning state, so the Monitor screen can show concrete evidence like "Service killed 3 times today" with a "Fix" action.

Output: ServiceEventTracker class in rns-android, wired into ReticulumService lifecycle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-battery-optimization-ux/15-CONTEXT.md
@rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt
@rns-android/src/main/kotlin/network/reticulum/android/BatteryOptimizationChecker.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ServiceEventTracker</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ServiceEventTracker.kt</files>
  <action>
Create ServiceEventTracker class that counts optimization-related service events and manages warning dismissal state.

Requirements:
- Constructor takes Context
- Uses SharedPreferences file "reticulum_battery" (same file as BatteryExemptionHelper from Plan 01)
- Data class `ServiceEvents` exposed via StateFlow:
  - `killCountToday: Int` - how many times the service was killed today
  - `lastKillTimestamp: Long` - when the last kill occurred (0 if none)
  - `warningDismissedAtCount: Int` - the kill count at which user last dismissed the warning (-1 if never dismissed)
  - `hasActiveWarning: Boolean` - computed: killCountToday > 0 AND killCountToday > warningDismissedAtCount

Event recording methods:
- `recordServiceKill()` - increments today's kill count, updates lastKillTimestamp, persists immediately
- `recordServiceStart()` - called on every service start. Detects if this is a restart after unexpected kill:
  If service was previously running (check SharedPreferences "service_was_running" flag) AND stop was not user-initiated (check "user_initiated_stop" flag), count it as a kill.
  Set "service_was_running" = true.
- `recordUserStop()` - sets "user_initiated_stop" = true, "service_was_running" = false. Called when user explicitly stops service.

Warning dismissal:
- `dismissWarning()` - sets warningDismissedAtCount to current killCountToday. Warning only resurfaces if killCountToday increases past this value.
- `shouldShowWarning(): Boolean` - killCountToday > 0 AND killCountToday > warningDismissedAtCount AND app is NOT exempt from battery optimization (takes isExempt parameter)

Daily reset:
- On each access/event, check if stored date (SharedPreferences "event_date" as YYYY-MM-DD) differs from today. If so, reset killCountToday to 0 and warningDismissedAtCount to -1.

SharedPreferences keys (all prefixed "event_"):
- "event_kill_count" (Int)
- "event_last_kill_ts" (Long)
- "event_warning_dismissed_at" (Int)
- "event_date" (String, YYYY-MM-DD)
- "service_was_running" (Boolean)
- "user_initiated_stop" (Boolean)
  </action>
  <verify>
Build compiles: JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
  </verify>
  <done>
ServiceEventTracker compiles and provides kill counting, daily reset, and dismissable warning logic via StateFlow.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ServiceEventTracker into ReticulumService</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt</files>
  <action>
Wire ServiceEventTracker into ReticulumService lifecycle.

Changes to ReticulumService:
1. Add `private lateinit var eventTracker: ServiceEventTracker` field
2. In onCreate(): initialize eventTracker = ServiceEventTracker(this), then call eventTracker.recordServiceStart()
3. In shutdownReticulum() (the method called from onDestroy): do NOT record anything here -- this is the normal shutdown path. The "user_initiated_stop" flag is already set by the companion stop() method path.
4. Add a new public method `fun getEventTracker(): ServiceEventTracker = eventTracker` for downstream access
5. Modify the companion `stop()` method: before stopping, call `instance?.getEventTracker()?.recordUserStop()` so the tracker knows this was user-initiated. This distinguishes user stops from system kills.

The detection logic works as follows:
- Service starts: recordServiceStart() checks if "service_was_running" is true AND "user_initiated_stop" is false. If both conditions met, this is a restart after a system kill, so increment kill count.
- User stops: recordUserStop() sets flags so next start is not counted as a kill.
- System kill: service_was_running stays true, user_initiated_stop stays false, so next start detects it.

Also wire BatteryStatsTracker (from Plan 01 -- if it doesn't exist yet, just add the field and initialization with a TODO comment; the plans are Wave 1 parallel so we wire it when both exist):
- Add `private lateinit var batteryStatsTracker: BatteryStatsTracker` field (if class exists)
- In onCreate() after batteryMonitor.start(): batteryStatsTracker = BatteryStatsTracker(this); batteryStatsTracker.start(lifecycleScope)
- In onDestroy() before batteryMonitor.stop(): batteryStatsTracker.stop()
- Add `fun getBatteryStatsTracker(): BatteryStatsTracker = batteryStatsTracker`

If BatteryStatsTracker doesn't compile yet (parallel wave), just add a TODO comment for Plan 03 to wire it.
  </action>
  <verify>
Build compiles: JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
  </verify>
  <done>
ServiceEventTracker is wired into ReticulumService lifecycle with kill detection on start, user-stop flagging on stop, and accessor method for UI consumption.
  </done>
</task>

</tasks>

<verification>
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
ServiceEventTracker and ReticulumService modifications compile. Kill detection logic distinguishes user stops from system kills.
</verification>

<success_criteria>
- ServiceEventTracker counts kills per day with daily reset
- Kill detection works: system kills increment counter, user stops do not
- Warning dismissal has memory -- only resurfaces when new events occur
- ServiceEventTracker wired into ReticulumService lifecycle
- Everything compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/15-battery-optimization-ux/15-02-SUMMARY.md`
</output>
