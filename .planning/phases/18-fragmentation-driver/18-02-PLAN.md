---
phase: 18-fragmentation-driver
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEFragmentation.kt
  - rns-interfaces/src/test/kotlin/network/reticulum/interfaces/ble/BLEFragmentationTest.kt

autonomous: true

must_haves:
  truths:
    - "BLEFragmenter splits a packet into fragments with 5-byte header [type:1][seq:2][total:2] big-endian"
    - "Fragment types are START(0x01), CONTINUE(0x02), END(0x03)"
    - "Single-fragment packets use START type with seq=0, total=1"
    - "Fragment payload size = MTU - 5 bytes"
    - "BLEReassembler reconstructs original packet from ordered fragments"
    - "BLEReassembler handles out-of-order fragment arrival"
    - "BLEReassembler times out incomplete packets after configurable timeout"
    - "Wire format is byte-identical to Python BLEFragmentation.py"
    - "All tests run on JVM without Android dependencies"
  artifacts:
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEFragmentation.kt"
      provides: "BLEFragmenter and BLEReassembler classes"
      exports: ["BLEFragmenter", "BLEReassembler"]
      min_lines: 150
    - path: "rns-interfaces/src/test/kotlin/network/reticulum/interfaces/ble/BLEFragmentationTest.kt"
      provides: "Comprehensive unit tests for fragmentation and reassembly"
      min_lines: 200
  key_links:
    - from: "BLEFragmentation.kt"
      to: "BLEConstants.kt"
      via: "uses FRAGMENT_HEADER_SIZE, FRAGMENT_TYPE_START, etc."
      pattern: "BLEConstants\\."
    - from: "BLEFragmentationTest.kt"
      to: "BLEFragmentation.kt"
      via: "tests BLEFragmenter and BLEReassembler"
      pattern: "BLEFragmenter|BLEReassembler"
---

<objective>
Implement BLE packet fragmentation and reassembly, byte-identical to the Python BLEFragmentation.py reference.

Purpose: The fragment protocol is the foundation of all BLE communication. Every packet sent over BLE goes through fragmentation (sender) and reassembly (receiver). Getting this right -- and proving it with tests -- de-risks all subsequent phases.

Output: `BLEFragmentation.kt` (production) and `BLEFragmentationTest.kt` (tests)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Python reference implementation -- the authoritative source for wire format
@~/repos/public/ble-reticulum/src/ble_reticulum/BLEFragmentation.py
@~/repos/public/ble-reticulum/tests/test_fragmentation.py

# Constants (may or may not exist yet -- if not, use inline values from spec below)
# If BLEConstants.kt exists, import from it. If not, define constants inline.
# Fragment header: 5 bytes. Types: START=0x01, CONTINUE=0x02, END=0x03
# Default MTU: 185. Min MTU: 20.

# Existing test patterns
@rns-interfaces/src/test/kotlin/network/reticulum/interfaces/local/LocalInterfaceTest.kt
@rns-interfaces/build.gradle.kts
</context>

<feature>
  <name>BLE Fragmentation and Reassembly</name>
  <files>
    rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEFragmentation.kt
    rns-interfaces/src/test/kotlin/network/reticulum/interfaces/ble/BLEFragmentationTest.kt
  </files>
  <behavior>
**BLEFragmenter** -- splits packets into BLE-sized fragments:

- Constructor takes `mtu: Int = 185` (default). Enforces minimum MTU of 20. Throws if MTU < HEADER_SIZE + 1 (i.e., < 6).
- `maxPayload = mtu - HEADER_SIZE` (= mtu - 5)
- `fragment(packet: ByteArray): List<ByteArray>` splits packet into fragments.
  - Each fragment: `[type:1][sequence:2][total:2][payload:variable]` -- all big-endian
  - type: START(0x01) for first, CONTINUE(0x02) for middle, END(0x03) for last
  - sequence: 0-indexed fragment number (UShort, big-endian)
  - total: total fragment count (UShort, big-endian)
  - Single-fragment packets: type=START, seq=0, total=1
  - Empty packet throws IllegalArgumentException
  - Packet requiring >65535 fragments throws IllegalArgumentException
- `fragmentOverhead(packetSize: Int): Triple<Int, Int, Double>` returns (numFragments, overheadBytes, overheadPercent)

**BLEReassembler** -- reconstructs packets from fragments:

- Constructor takes `timeoutMs: Long = 30_000L`
- `receiveFragment(fragment: ByteArray, senderId: String = "default"): ByteArray?`
  - Returns complete packet when all fragments received, null otherwise
  - Parses 5-byte header, validates type/sequence/total
  - Handles out-of-order arrival (stores by sequence number, assembles when complete)
  - Handles multiple concurrent senders (separate buffers per sender)
  - Detects duplicate fragments (same seq, same data = ignore; same seq, different data = discard buffer, throw)
  - Validates total consistency across fragments from same sender
  - Fragment too short (<5 bytes) throws IllegalArgumentException
  - Invalid fragment type throws IllegalArgumentException
  - sequence >= total throws IllegalArgumentException
- `cleanupStale(): Int` removes timed-out buffers, returns count removed
- `statistics: ReassemblyStatistics` data class with packetsReassembled, packetsTimedOut, fragmentsReceived, pendingPackets

**Wire format verification cases** (must match Python struct.pack("!BHH", ...)):

| Input | Expected header bytes |
|-------|----------------------|
| Single fragment (START, seq=0, total=1) | `01 00 00 00 01` |
| First of 3 (START, seq=0, total=3) | `01 00 00 00 03` |
| Middle of 3 (CONTINUE, seq=1, total=3) | `02 00 01 00 03` |
| Last of 3 (END, seq=2, total=3) | `03 00 02 00 03` |
| seq=256, total=1000 | `type 01 00 03 E8` |

  </behavior>
  <implementation>
Port the Python BLEFragmenter and BLEReassembler classes to Kotlin. Key differences from Python:

1. Use `ByteArray` not `bytes`. Use `java.nio.ByteBuffer` with `ByteOrder.BIG_ENDIAN` for header packing/unpacking (equivalent to Python `struct.pack("!BHH", ...)`).
2. Use `System.currentTimeMillis()` for timestamps (equivalent to Python `time.time()` but in millis).
3. Reassembly buffer: `MutableMap<String, ReassemblyBuffer>` where ReassemblyBuffer holds fragments map, total, startTimeMs, senderId.
4. If BLEConstants.kt exists (from Plan 01), import constants from it. If it doesn't exist yet (parallel execution), define the needed constants as companion object vals:
   ```kotlin
   companion object {
       const val HEADER_SIZE = 5
       const val TYPE_START: Byte = 0x01
       const val TYPE_CONTINUE: Byte = 0x02
       const val TYPE_END: Byte = 0x03
   }
   ```
   These values are identical to BLEConstants so they'll work either way.
5. Thread safety: The reassembler may be called from multiple coroutines. Use `@Synchronized` or explicit synchronization on the buffers map.

**Test structure** -- Use JUnit5 (matching existing test patterns). Port ALL test cases from Python test_fragmentation.py, plus add:
- Wire format byte-level verification (hardcoded expected bytes for known inputs)
- Round-trip test: fragment then reassemble, verify original == result
- Out-of-order reassembly
- Multiple senders interleaved
- Timeout cleanup with short timeout
- Duplicate fragment handling (benign and conflicting)
- Edge cases: exactly MTU-5 payload (single fragment), MTU payload (needs 2 fragments)
- Large packet (500 bytes, typical Reticulum packet)
- Sequence number in headers verified against expected big-endian encoding
  </implementation>
</feature>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:test --tests "network.reticulum.interfaces.ble.*"` -- all tests pass
2. Wire format test verifies header bytes match Python `struct.pack("!BHH", type, seq, total)` output
3. Round-trip test: `reassemble(fragment(packet)) == packet` for various packet sizes
4. Out-of-order test: fragments delivered in scrambled order still produce correct packet
5. Timeout test: incomplete packets cleaned up after timeout
6. No Android imports: `grep -rn "android\." rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEFragmentation.kt` returns nothing
</verification>

<success_criteria>
- BLEFragmenter produces fragments with correct 5-byte big-endian headers
- BLEReassembler reconstructs packets from ordered and out-of-order fragments
- Wire format is byte-identical to Python BLEFragmentation.py (verified by tests)
- Timeout cleanup works for incomplete packets
- All tests pass on JVM without Android dependencies
- Test coverage includes all cases from Python test_fragmentation.py plus wire-format verification
</success_criteria>

<output>
After completion, create `.planning/phases/18-fragmentation-driver/18-02-SUMMARY.md`
</output>
