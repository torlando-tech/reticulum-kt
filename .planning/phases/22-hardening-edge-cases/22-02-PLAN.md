---
phase: 22-hardening-edge-cases
plan: 02
type: execute
wave: 2
depends_on: ["22-01"]
files_modified:
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt
autonomous: false

must_haves:
  truths:
    - "At connection capacity, a new discovered peer with significantly higher score evicts the lowest-scored existing peer"
    - "At connection capacity, incoming connections are always accepted; then lowest scorer is evicted (which may be the new peer)"
    - "Eviction requires a margin of 0.15 on the [0,1] scoring scale to prevent churn"
    - "MAC rotation does not create duplicate connections for the same identity"
  artifacts:
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt"
      provides: "Eviction logic in collectDiscoveredPeers and handleIncomingConnection"
      contains: "EVICTION_MARGIN"
  key_links:
    - from: "BLEInterface.kt collectDiscoveredPeers"
      to: "BLEPeerInterface.discoveryRssi + DiscoveredPeer.connectionScore()"
      via: "Eviction scoring comparison"
      pattern: "connectionScore"
    - from: "BLEInterface.kt handleIncomingConnection"
      to: "BLEInterface.kt tearDownPeer"
      via: "Evict lowest scorer when incoming peer is better"
      pattern: "tearDownPeer"
---

<objective>
Add connection limit eviction logic for both outgoing discovery and incoming connections, completing the BLE mesh hardening.

Purpose: Without eviction, the mesh gets stuck with initial connections even when better peers appear. Without incoming connection handling at capacity, peers that reach out to us are rejected. These two behaviors together enable the mesh to self-optimize its topology over time.

Output: BLEInterface handles at-capacity scenarios with score-based eviction for outgoing connections and accept-then-evaluate for incoming connections.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-hardening-edge-cases/22-CONTEXT.md
@.planning/phases/22-hardening-edge-cases/22-RESEARCH.md
@.planning/phases/22-hardening-edge-cases/22-01-SUMMARY.md
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEPeerInterface.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/DiscoveredPeer.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEConstants.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Connection limit eviction for outgoing and incoming connections</name>
  <files>
    rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt
  </files>
  <action>
Modify BLEInterface.kt to add eviction logic at connection capacity.

**1. Add a helper to compute a connected peer's score:**

Add a `computePeerScore(peerInterface: BLEPeerInterface): Double` private function that creates a `DiscoveredPeer` from the peer's current state and calls `connectionScore()`:
```kotlin
private fun computePeerScore(peerInterface: BLEPeerInterface): Double {
    val identityHex = peerInterface.peerIdentity.toHex()
    val address = identityToAddress[identityHex] ?: return 0.0
    return DiscoveredPeer(
        address = address,
        rssi = peerInterface.discoveryRssi,
        lastSeen = peerInterface.lastTrafficReceived,
        connectionAttempts = 1,
        connectionSuccesses = 1  // Connected peer = at least 1 success
    ).connectionScore()
}
```

**2. Add a helper to find the lowest-scored connected peer:**

```kotlin
private fun findLowestScoredPeer(): Pair<String, Double>? {
    return peers.entries.minByOrNull { (_, peerInterface) ->
        computePeerScore(peerInterface)
    }?.let { (identityHex, peerInterface) ->
        identityHex to computePeerScore(peerInterface)
    }
}
```

**3. Replace hard skip at capacity in `collectDiscoveredPeers()`:**

Replace the existing `if (peers.size >= maxConnections) return@collect` with eviction logic:
```kotlin
// At capacity: check if new peer is significantly better than worst existing
if (peers.size >= maxConnections) {
    val (lowestIdentity, lowestScore) = findLowestScoredPeer() ?: return@collect
    val newScore = peer.connectionScore()

    if (newScore > lowestScore + BLEConstants.EVICTION_MARGIN) {
        log("Evicting ${lowestIdentity.take(8)} (score=${String.format("%.2f", lowestScore)}) for ${peer.address.takeLast(8)} (score=${String.format("%.2f", newScore)})")
        tearDownPeer(lowestIdentity)
        // Fall through to connection attempt
    } else {
        return@collect  // New peer not significantly better
    }
}
```

**4. Add capacity handling for incoming connections in `handleIncomingConnection()`:**

After the identity handshake succeeds and before calling `spawnPeerInterface()`, add:
```kotlin
// Handle capacity: accept incoming, then evaluate
if (peers.size >= maxConnections) {
    // Spawn the new peer first so we can score it
    spawnPeerInterface(address, identityHex, peerIdentity, connection, rssi = -70)

    // Now find the lowest scorer among ALL peers (including new one)
    val (lowestIdentity, _) = findLowestScoredPeer() ?: return

    if (lowestIdentity == identityHex) {
        // New peer is the worst -- evict it
        log("Incoming peer ${identityHex.take(8)} scored lowest at capacity, removing")
        tearDownPeer(identityHex)
    } else {
        // Evict existing worst peer to make room
        log("Evicting ${lowestIdentity.take(8)} to accept incoming ${identityHex.take(8)}")
        tearDownPeer(lowestIdentity)
    }

    log("Accepted peer ${identityHex.take(8)} from ${address.takeLast(8)}")
    return  // Already spawned (or evicted) above
}
```

Place this block BEFORE the existing `spawnPeerInterface(...)` call in `handleIncomingConnection()`. The existing `spawnPeerInterface` call below handles the normal (not-at-capacity) case.

**IMPORTANT**: For the incoming connection capacity path, the new peer is spawned BEFORE evaluation. If the new peer gets evicted, `tearDownPeer` handles cleanup. If an existing peer gets evicted, the new peer is already registered. This ensures no half-initialized state.

**5. Verify MAC rotation dedup is still intact:**

Confirm that `spawnPeerInterface()` still has the existing identity check:
```kotlin
val existing = peers[identityHex]
if (existing != null) {
    existing.updateConnection(connection, address)
    ...
    return
}
```
This handles MAC rotation (same identity, different address) by reusing the existing peer interface. No changes needed -- just verify it's still present after the edits.
  </action>
  <verify>
`JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:compileKotlin` compiles without errors. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:test --tests "network.reticulum.interfaces.ble.*"` passes. Grep confirms: EVICTION_MARGIN is referenced in collectDiscoveredPeers, capacity handling exists in handleIncomingConnection, updateConnection still present in spawnPeerInterface.
  </verify>
  <done>
Outgoing discovery evicts lowest-scored peer when new peer scores >0.15 higher. Incoming connections always accepted, then lowest scorer evicted (may be the new peer). MAC rotation dedup via updateConnection() remains intact.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete BLE mesh hardening: zombie detection (45s timeout, graceful then force disconnect), exponential blacklist (60s-480s with forgiveness on re-discovery), and connection limit eviction (0.15 margin, accept-then-evaluate for incoming). All in BLEInterface.kt and BLEPeerInterface.kt.
  </what-built>
  <how-to-verify>
1. Connect two Android devices over BLE and verify they mesh (exchange Reticulum packets)
2. Turn off Bluetooth on one device -- the other should detect the zombie after ~45s and tear it down
3. Turn Bluetooth back on -- the device should re-discover the peer, clear the blacklist, and reconnect
4. With 3+ devices: verify that at capacity (default 5), a strong-signal new device can evict a weak-signal existing device
5. Let the mesh run for >15 minutes to verify MAC rotation handling (same peer stays connected through address changes)
6. Check logcat for `[BLEInterface]` logs confirming: zombie detection, blacklist entries, eviction decisions

The on-device test is success criterion 7 from the roadmap: "On-device testing confirms 2+ peers mesh correctly for >1 hour." A 15-minute initial test is sufficient for this checkpoint; extended testing is a follow-up.
  </how-to-verify>
  <resume-signal>Type "approved" if mesh works under adverse conditions, or describe issues seen in testing</resume-signal>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:compileKotlin` passes
2. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:test --tests "network.reticulum.interfaces.ble.*"` passes
3. Grep confirms: eviction logic in `collectDiscoveredPeers` and `handleIncomingConnection`
4. MAC rotation handling (updateConnection) preserved in spawnPeerInterface
5. On-device verification per checkpoint task
</verification>

<success_criteria>
- At capacity, outgoing discovery triggers eviction when new peer scores >0.15 higher than worst existing peer
- At capacity, incoming connections are always accepted then evaluated (lowest scorer evicted)
- MAC rotation does not create duplicate connections (updateConnection still works)
- On-device mesh operates correctly under adverse conditions (zombie, reconnect, eviction)
- All existing unit tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-hardening-edge-cases/22-02-SUMMARY.md`
</output>
