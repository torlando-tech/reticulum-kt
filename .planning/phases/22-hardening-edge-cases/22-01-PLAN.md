---
phase: 22-hardening-edge-cases
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEConstants.kt
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEPeerInterface.kt
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt
autonomous: true

must_haves:
  truths:
    - "Zombie peers (no traffic for 45s) are detected and disconnected"
    - "Blacklist duration grows exponentially with repeated failures (60s, 120s, 240s, 480s cap)"
    - "Blacklist entries clear when a peer is re-discovered via BLE scan"
    - "Zombie teardown blacklists the zombie's MAC address"
    - "Any traffic (keepalive or data) resets the zombie detection timer"
  artifacts:
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEConstants.kt"
      provides: "Zombie and blacklist constants"
      contains: "ZOMBIE_TIMEOUT_MS"
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEPeerInterface.kt"
      provides: "Last traffic tracking for zombie detection"
      contains: "lastTrafficReceived"
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt"
      provides: "Zombie detection loop, exponential blacklist, blacklist forgiveness"
      contains: "zombieDetectionLoop"
  key_links:
    - from: "BLEPeerInterface.kt"
      to: "BLEInterface.kt"
      via: "lastTrafficReceived timestamp read by zombie detection loop"
      pattern: "lastTrafficReceived"
    - from: "BLEInterface.kt zombieDetectionLoop"
      to: "BLEInterface.kt addToBlacklist"
      via: "zombie teardown triggers blacklist entry"
      pattern: "addToBlacklist"
---

<objective>
Add zombie detection and exponential blacklist backoff to the BLE mesh interface.

Purpose: Zombie peers (connected but unresponsive) waste connection slots and prevent better peers from joining. Flat blacklist duration causes either too-short or too-long exclusion. These are the two most critical hardening features for production BLE mesh resilience.

Output: BLEPeerInterface tracks last-traffic timestamps; BLEInterface runs a zombie detection loop and uses exponential blacklist with forgiveness on re-discovery.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-hardening-edge-cases/22-CONTEXT.md
@.planning/phases/22-hardening-edge-cases/22-RESEARCH.md
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEConstants.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEPeerInterface.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hardening constants and traffic tracking in BLEPeerInterface</name>
  <files>
    rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEConstants.kt
    rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEPeerInterface.kt
  </files>
  <action>
**BLEConstants.kt** -- Add constants in a new `// ---- Hardening ----` section after the `// ---- Connection Limits ----` section:

```kotlin
// ---- Hardening ----

/** Zombie timeout: no traffic for this long declares a peer zombie. 3 missed keepalives = 45s. */
const val ZOMBIE_TIMEOUT_MS = 45_000L

/** How often to check for zombie peers. Same cadence as keepalive. */
const val ZOMBIE_CHECK_INTERVAL_MS = 15_000L

/** Grace period after attempting graceful disconnect before force-close. */
const val ZOMBIE_GRACE_PERIOD_MS = 5_000L

/** Base duration for blacklist backoff (60 seconds). */
const val BLACKLIST_BASE_DURATION_MS = 60_000L

/** Maximum multiplier for exponential blacklist backoff. 60s * 8 = 480s cap. */
const val BLACKLIST_MAX_MULTIPLIER = 8

/** Eviction margin: new peer must score this much higher than lowest peer to justify eviction. */
const val EVICTION_MARGIN = 0.15
```

**BLEPeerInterface.kt** -- Add last-traffic tracking:

1. Add a `@Volatile var lastTrafficReceived: Long = System.currentTimeMillis()` property alongside the existing `lastKeepaliveReceived` field.

2. In `receiveLoop()`, update `lastTrafficReceived` for ALL incoming data, including keepalives. Per CONTEXT.md: "Any traffic resets the keepalive timer." The zombie detection is about "no traffic at all" (not "no real data"), so keepalives count:
   - At the very start of the `collect` lambda (before the keepalive filter), add: `lastTrafficReceived = System.currentTimeMillis()`

3. In `updateConnection()`, reset `lastTrafficReceived = System.currentTimeMillis()` when the connection is swapped (MAC rotation proves liveness).

4. Also add a `@Volatile var discoveryRssi: Int = -100` property that can be set by BLEInterface when spawning, so scoring data is available for eviction decisions. Default to -100 (worst).
  </action>
  <verify>
`JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:compileKotlin` compiles without errors.
  </verify>
  <done>
BLEConstants has ZOMBIE_TIMEOUT_MS (45000), ZOMBIE_CHECK_INTERVAL_MS (15000), ZOMBIE_GRACE_PERIOD_MS (5000), BLACKLIST_BASE_DURATION_MS (60000), BLACKLIST_MAX_MULTIPLIER (8), EVICTION_MARGIN (0.15). BLEPeerInterface has lastTrafficReceived updated on all incoming fragments (including keepalives) and discoveryRssi field for scoring.
  </done>
</task>

<task type="auto">
  <name>Task 2: Zombie detection loop and exponential blacklist in BLEInterface</name>
  <files>
    rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt
  </files>
  <action>
Modify BLEInterface.kt to add zombie detection and upgrade the blacklist to exponential backoff.

**1. Replace flat blacklist with exponential blacklist:**

Replace the existing blacklist data structure and related code:
- Change `private val blacklist = ConcurrentHashMap<String, Long>()` to store a data class:
  ```kotlin
  private data class BlacklistEntry(val expiry: Long, val failureCount: Int)
  private val blacklist = ConcurrentHashMap<String, BlacklistEntry>()
  ```
- Remove the `blacklistDurationMs = 60_000L` constant (replaced by BLEConstants.BLACKLIST_BASE_DURATION_MS).
- Add an `addToBlacklist(address: String)` function that:
  - Gets existing entry's failureCount (or 0)
  - Increments failure count
  - Computes duration: `BLEConstants.BLACKLIST_BASE_DURATION_MS * minOf(count, BLEConstants.BLACKLIST_MAX_MULTIPLIER)`
  - Stores `BlacklistEntry(System.currentTimeMillis() + duration, count)`
  - Logs: `"Blacklisted ${address.takeLast(8)} for ${duration / 1000}s (failure #$count)"`
- Update `isBlacklisted()` to check `entry.expiry` instead of the raw Long value.
- Update `periodicCleanup()` to use `it.value.expiry < now` instead of `it.value < now`.

**2. Replace all direct `blacklist[address] = ...` assignments:**
- In `connectToPeer()` catch for TimeoutCancellationException: replace `blacklist[address] = System.currentTimeMillis() + blacklistDurationMs` with `addToBlacklist(address)`.
- In `handleIncomingConnection()` catch for TimeoutCancellationException: same replacement.

**3. Add blacklist forgiveness on re-discovery:**
In `collectDiscoveredPeers()`, BEFORE the `if (isBlacklisted(...))` check, add:
```kotlin
// Blacklist forgiveness: re-discovery proves peer is alive
if (blacklist.containsKey(peer.address)) {
    log("Cleared blacklist for re-discovered ${peer.address.takeLast(8)}")
    blacklist.remove(peer.address)
}
```
This replaces the existing `if (isBlacklisted(peer.address)) return@collect` check entirely -- the forgiveness clears the entry, so the subsequent checks (backoff, capacity) still apply.

**4. Add zombie detection loop:**
Add a `zombieDetectionLoop()` suspend function:
```kotlin
private suspend fun zombieDetectionLoop() {
    while (online.get() && !detached.get()) {
        delay(BLEConstants.ZOMBIE_CHECK_INTERVAL_MS)
        val now = System.currentTimeMillis()

        for ((identityHex, peerInterface) in peers.toMap()) {
            val lastTraffic = peerInterface.lastTrafficReceived
            if (now - lastTraffic > BLEConstants.ZOMBIE_TIMEOUT_MS) {
                log("Zombie detected: ${identityHex.take(8)} (no traffic for ${(now - lastTraffic) / 1000}s)")

                // Attempt graceful disconnect first
                val address = identityToAddress[identityHex]
                if (address != null) {
                    try { driver.disconnect(address) } catch (_: Exception) {}
                }

                // Grace period for clean close
                delay(BLEConstants.ZOMBIE_GRACE_PERIOD_MS)

                // Force teardown if still present
                if (peers.containsKey(identityHex)) {
                    tearDownPeer(identityHex)
                    // Blacklist after zombie teardown
                    if (address != null) addToBlacklist(address)
                }
            }
        }
    }
}
```

**5. Launch zombie detection in start():**
In the `start()` method, add after the existing event collection launches:
```kotlin
scope.launch { zombieDetectionLoop() }
```

**6. Set discoveryRssi when spawning peers:**
In `connectToPeer()`, after creating the connection and before calling `spawnPeerInterface()`, add:
```kotlin
// Store RSSI for scoring/eviction decisions
```
But actually, the `peer` parameter is a `DiscoveredPeer` with `.rssi`. In `spawnPeerInterface()`, after creating the `BLEPeerInterface` instance, set `peerInterface.discoveryRssi = peer.rssi` -- but `spawnPeerInterface` doesn't currently take RSSI. Add an `rssi: Int = -100` parameter to `spawnPeerInterface()` and set `peerInterface.discoveryRssi = rssi` after construction. Pass `peer.rssi` from `connectToPeer()` and `-70` (mid-range default) from `handleIncomingConnection()` (since incoming connections don't have scan RSSI).
  </action>
  <verify>
`JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:compileKotlin` compiles without errors. Verify via grep that: (1) `zombieDetectionLoop` is launched in `start()`, (2) `addToBlacklist` is called from zombie teardown, (3) no direct `blacklist[address] = ...` assignments remain (all go through `addToBlacklist`), (4) blacklist forgiveness occurs before the blacklist check in `collectDiscoveredPeers`.
  </verify>
  <done>
BLEInterface has a zombie detection loop checking every 15s, tearing down peers with no traffic for 45s (graceful then force), blacklisting zombies with exponential backoff (60s-480s). Blacklist forgiveness clears entries when peers are re-discovered via scan. All blacklist writes go through addToBlacklist().
  </done>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:compileKotlin` passes
2. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:test --tests "network.reticulum.interfaces.ble.*"` passes (existing fragmentation tests still green)
3. Grep confirms: `zombieDetectionLoop` is launched in `start()`, `addToBlacklist` is the only blacklist write path, blacklist forgiveness in `collectDiscoveredPeers`
4. No references to `blacklistDurationMs` remain (replaced by constants)
</verification>

<success_criteria>
- BLEPeerInterface.lastTrafficReceived is updated on every incoming fragment
- BLEInterface.zombieDetectionLoop runs every 15s, tears down peers idle >45s
- Blacklist is exponential: 60s, 120s, 240s, 480s (capped at 8x)
- Blacklist clears on peer re-discovery via scan
- Existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/22-hardening-edge-cases/22-01-SUMMARY.md`
</output>
