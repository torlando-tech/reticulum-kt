---
phase: 14-service-notification-ux
plan: 03
type: execute
wave: 3
depends_on: ["14-01", "14-02"]
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt
  - rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/viewmodel/ReticulumViewModel.kt
  - rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/service/InterfaceManager.kt
autonomous: true

must_haves:
  truths:
    - "Notification updates automatically when connection state changes"
    - "Notification updates are debounced at 500ms to avoid flickering during WiFi/cellular handoff"
    - "Tapping notification opens the app to the connection status screen"
    - "ViewModel reflects paused state and wires reconnect callback"
    - "Paused state persists across notification updates (buttons toggle correctly)"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt"
      provides: "Debounced notification update loop, tap-to-open intent, interface snapshot collection"
      contains: "buildConnectionSnapshot"
    - path: "rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/viewmodel/ReticulumViewModel.kt"
      provides: "Paused state exposure and reconnect callback wiring"
      contains: "isPaused"
  key_links:
    - from: "ReticulumService"
      to: "NotificationContentBuilder"
      via: "periodic snapshot -> notification update"
      pattern: "buildConnectionSnapshot.*buildNotification"
    - from: "ReticulumService"
      to: "NotificationActionReceiver.buildActions"
      via: "passes isPaused to get dynamic action buttons"
      pattern: "buildActions.*isPaused"
    - from: "ReticulumViewModel"
      to: "ReticulumService"
      via: "service binding for pause state and reconnect callback"
      pattern: "onReconnectRequested|onPauseStateChanged"
---

<objective>
Wire notification updates into the service lifecycle so the notification stays current and responds to user interaction.

Purpose: Connect all the pieces from Plans 01 and 02: the service collects interface state into ConnectionSnapshots, builds rich notifications with dynamic action buttons, and updates the notification on a debounced schedule. The tap-to-open intent launches the app's main activity. The ViewModel is updated to reflect paused state and wire the reconnect callback through InterfaceManager.

Output: Fully working notification that updates live, responds to quick actions, and opens the app on tap
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-service-notification-ux/14-CONTEXT.md
@.planning/phases/14-service-notification-ux/14-01-SUMMARY.md
@.planning/phases/14-service-notification-ux/14-02-SUMMARY.md
@rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt
@rns-android/src/main/kotlin/network/reticulum/android/ServiceConnectionState.kt
@rns-android/src/main/kotlin/network/reticulum/android/NotificationContentBuilder.kt
@rns-android/src/main/kotlin/network/reticulum/android/NotificationActionReceiver.kt
@rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/viewmodel/ReticulumViewModel.kt
@rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/service/InterfaceManager.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire debounced notification updates into ReticulumService</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt</files>
  <action>
Replace the existing simple `createNotification()`/`updateNotification()` methods with the new rich notification system:

1. **Add fields:**
   - `private lateinit var notificationBuilder: NotificationContentBuilder` - Initialized in onCreate()
   - `private var lastNotificationUpdate = 0L` - For debounce tracking
   - `private var pendingNotificationUpdate = false` - For debounce coalescing
   - `private val NOTIFICATION_DEBOUNCE_MS = 500L` - Debounce interval (matches Phase 10-03 NetworkStateObserver)

2. **Add `buildConnectionSnapshot()` method:**
   - Collect interface snapshots from Transport.getInterfaces():
     ```kotlin
     val transportInterfaces = Transport.getInterfaces()
     val snapshots = transportInterfaces.map { ref ->
         InterfaceSnapshot(
             name = ref.name,
             typeName = categorizeInterface(ref.name), // see below
             isOnline = ref.online,
             detail = "" // Optional detail
         )
     }
     ```
   - Create and return `ConnectionSnapshot(
       state = computeConnectionState(snapshots, isPaused),
       interfaces = snapshots,
       sessionStartTime = sessionStartTime,
       enableTransport = config.enableTransport,
       isPaused = _isPaused
     )`

3. **Add `categorizeInterface(name: String): String` helper:**
   - Interface names in this codebase follow patterns like "TCPInterface[host:port]", or user-defined names from InterfaceManager
   - Simple heuristic: check the class name of the InterfaceRef's underlying type
   - Since InterfaceRef wraps the real interface, and the name is user-defined, the categorization needs to come from the interface class type. Transport.getInterfaces() returns InterfaceRef which has `isLocalSharedInstance` property.
   - Best approach: Check the InterfaceRef properties that are available:
     - If `ref.isLocalSharedInstance` -> "Local"
     - If `ref.parentInterface?.isLocalSharedInstance == true` -> "Local"
     - Otherwise categorize by name convention. InterfaceManager names are user-defined, but the real type info is on the InterfaceRef. Since InterfaceRef wraps InterfaceAdapter which wraps the real Interface, and the `name` property comes from the real interface, we can check if the name contains type hints.
   - Actually, the simplest robust approach: Add a `typeName` property or method. But since we can't easily modify InterfaceRef (it's in rns-core), use a name-based heuristic as a fallback, and allow Plan's executor to choose the best approach. Suggested default:
     - If name contains "TCP" (case-insensitive) or ref has TCP-like characteristics -> "TCP"
     - If name contains "UDP" -> "UDP"
     - If name contains "Auto" -> "Auto"
     - If isLocalSharedInstance or parent is -> "Local"
     - Default: "Other"
   - The InterfaceManager in the sample app always uses user-defined names, so this heuristic may not work perfectly. A better approach: Since InterfaceRef.name comes from the underlying Interface.name, and InterfaceManager sets names from StoredInterfaceConfig.name (user-defined), we need another source. The InterfaceRef may have a type identifier. Check if there's one. If not, use a simple "Interface" as the typeName for all, and show the count without type breakdown. This is acceptable as a first version — the expanded view still shows individual interface names.
   - PREFERRED APPROACH: Store the interface type alongside the snapshot. The InterfaceManager knows the type (it creates the interfaces). But since ReticulumService is in the library module and InterfaceManager is in the sample app, the service can't access it directly. Instead, add a callback: `var interfaceTypeProvider: ((String) -> String)? = null` that the ViewModel can set. If null, fall back to the name heuristic.

4. **Add `updateNotificationDebounced()` method:**
   - Check if enough time has passed since last update: `System.currentTimeMillis() - lastNotificationUpdate >= NOTIFICATION_DEBOUNCE_MS`
   - If yes: build snapshot, build notification, post it
   - If no: set `pendingNotificationUpdate = true`, schedule a delayed update via `lifecycleScope.launch { delay(remaining); if (pendingNotificationUpdate) { actuallyUpdate() } }`
   - The actual update:
     ```kotlin
     val snapshot = buildConnectionSnapshot()
     val contentIntent = buildContentIntent()
     val actions = NotificationActionReceiver.buildActions(this, _isPaused)
     val notification = notificationBuilder.buildNotification(snapshot, contentIntent, actions)
     val nm = getSystemService(NotificationManager::class.java)
     nm.notify(NOTIFICATION_ID, notification)
     lastNotificationUpdate = System.currentTimeMillis()
     pendingNotificationUpdate = false
     ```

5. **Add `buildContentIntent()` method:**
   - Create a PendingIntent that launches the app's main activity
   - Since the library module doesn't know the app's activity class, use the package manager's launch intent:
     ```kotlin
     val launchIntent = packageManager.getLaunchIntentForPackage(packageName)
     return launchIntent?.let {
         PendingIntent.getActivity(this, 0, it, PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT)
     }
     ```
   - This opens whatever the app's launcher activity is

6. **Add periodic notification update job:**
   - In `onCreate()`, after initializing notificationBuilder, launch a coroutine that periodically updates the notification:
     ```kotlin
     lifecycleScope.launch {
         // Wait for initialization
         delay(3000)
         while (isActive) {
             updateNotificationDebounced()
             delay(5000) // Update every 5 seconds
         }
     }
     ```
   - This ensures the notification stays current with interface state changes

7. **Wire `onPauseStateChanged`:**
   - In `onCreate()`, set: `onPauseStateChanged = { updateNotificationDebounced() }`
   - This triggers immediate notification update when user pauses/resumes

8. **Update `initializeReticulum()` completion:**
   - After successful initialization, call `updateNotificationDebounced()` instead of `updateNotification(statusText)`
   - Remove the old `updateNotification(status)` call

9. **Update `createNotification()` for initial foreground notification:**
   - The initial notification (shown before Reticulum initializes) should use the new builder if available, or fall back to simple notification
   - Since `notificationBuilder` is initialized in `onCreate()` before `onStartCommand()`, it's available:
     ```kotlin
     val snapshot = ConnectionSnapshot(
         state = ServiceConnectionState.CONNECTING,
         interfaces = emptyList(),
         sessionStartTime = System.currentTimeMillis(),
         enableTransport = config.enableTransport,
         isPaused = false
     )
     return notificationBuilder.buildNotification(snapshot, buildContentIntent(), emptyList())
     ```

10. **Remove old `createNotification(status)` and `updateNotification(status)` methods** — replaced by new system. Keep them as private deprecated wrappers only if needed for compilation, but prefer removing them entirely.
  </action>
  <verify>Build compiles: `cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin 2>&1 | tail -5`</verify>
  <done>ReticulumService builds ConnectionSnapshot from Transport interfaces, updates notification on a debounced 500ms schedule, shows rich content with state/breakdown/uptime, includes dynamic Pause/Resume/Reconnect actions, tapping opens app via launch intent.</done>
</task>

<task type="auto">
  <name>Task 2: Wire ViewModel to service pause state and reconnect callback</name>
  <files>rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/viewmodel/ReticulumViewModel.kt</files>
  <action>
Update ReticulumViewModel to expose paused state and wire reconnect:

1. **Add paused state:**
   - `private val _isPaused = MutableStateFlow(false)`
   - `val isPaused: StateFlow<Boolean> = _isPaused.asStateFlow()`

2. **In `startService()`, after the delay and InterfaceManager setup:**
   - Get the service instance via binding or static accessor. Since the ViewModel already communicates with the service via static methods (ReticulumService.start/stop), use the static instance:
   - Wire reconnect callback that delegates to InterfaceManager's network change notification:
     ```kotlin
     ReticulumService.getInstance()?.let { service ->
         service.onReconnectRequested = {
             interfaceManager?.let { manager ->
                 // Trigger reconnection by calling onNetworkChanged on all TCP interfaces
                 // This resets backoff and attempts immediate reconnect
                 Log.i(TAG, "Reconnect requested via notification")
                 // InterfaceManager doesn't expose notifyNetworkChange() directly,
                 // but we can trigger it through the network observer or add a method
             }
         }
         service.onPauseStateChanged = {
             _isPaused.value = service.isPaused
         }
     }
     ```
   - Actually, InterfaceManager's `notifyNetworkChange()` is private. The cleanest approach: add a `fun reconnectAll()` public method to InterfaceManager that calls `notifyNetworkChange()`. Then wire:
     ```kotlin
     service.onReconnectRequested = {
         interfaceManager?.reconnectAll()
     }
     ```

3. **Add `reconnectAll()` to InterfaceManager** (minor addition):
   - Since the plan's `files_modified` includes only the ViewModel, and InterfaceManager is a separate file, note that this is a minor one-line public wrapper. The executor should add it when wiring.
   - Alternative: Make `notifyNetworkChange()` public in InterfaceManager. Change `private fun notifyNetworkChange()` to `fun notifyNetworkChange()`. This is a single visibility modifier change.

4. **In `stopService()`:**
   - Reset paused state: `_isPaused.value = false`
   - Clear callbacks on service instance:
     ```kotlin
     ReticulumService.getInstance()?.let { service ->
         service.onReconnectRequested = null
         service.onPauseStateChanged = null
     }
     ```

5. **Update `updateServiceStatus()`:**
   - Sync paused state from service:
     ```kotlin
     ReticulumService.getInstance()?.let { service ->
         _isPaused.value = service.isPaused
     }
     ```

6. **Add `pauseService()` and `resumeService()` methods** (for potential future UI controls):
   ```kotlin
   fun pauseService() {
       ReticulumService.getInstance()?.pause()
       _isPaused.value = true
   }

   fun resumeService() {
       ReticulumService.getInstance()?.resume()
       _isPaused.value = false
   }
   ```

Note: The InterfaceManager change (making `notifyNetworkChange()` public or adding `reconnectAll()`) requires editing `InterfaceManager.kt`. Since this is a one-line visibility change, the executor should handle it as part of this task. Add `InterfaceManager.kt` to the files modified.
  </action>
  <verify>
Build compiles for both modules:
`cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin :rns-sample-app:compileDebugKotlin 2>&1 | tail -10`
  </verify>
  <done>ViewModel exposes isPaused StateFlow. Reconnect callback wired from service through InterfaceManager. Pause/resume methods available for future UI. Service callbacks cleaned up on stop. Both modules compile.</done>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin :rns-sample-app:compileDebugKotlin` succeeds
2. Notification updates every 5 seconds with current interface state
3. Notification debounce prevents flickering (500ms minimum between updates)
4. Tapping notification opens app via launch intent
5. Pause action freezes Transport and updates notification to "Paused" with Resume button
6. Resume action restores Transport and updates notification to current state with Pause button
7. Reconnect action triggers interface reconnection via InterfaceManager
8. ViewModel reflects paused state
</verification>

<success_criteria>
- Notification updates automatically reflecting real-time connection state
- 500ms debounce prevents notification flickering
- Tap-to-open launches app via package manager launch intent
- Pause/Resume cycle works: Transport freezes, WorkManager cancelled, Resume restores
- Reconnect triggers InterfaceManager reconnection
- ViewModel exposes isPaused state for future UI consumption
- Both rns-android and rns-sample-app modules compile
</success_criteria>

<output>
After completion, create `.planning/phases/14-service-notification-ux/14-03-SUMMARY.md`
</output>
