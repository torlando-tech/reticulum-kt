---
phase: 14-service-notification-ux
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/NotificationActionReceiver.kt
  - rns-android/src/main/AndroidManifest.xml
  - rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt
autonomous: true

must_haves:
  truths:
    - "Reconnect button in notification triggers immediate reconnection attempt on all interfaces"
    - "Pause button stops Transport job loop and cancels WorkManager"
    - "Resume button restarts Transport and reconnects interfaces"
    - "Notification button dynamically shows 'Pause' when running and 'Resume' when paused"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/NotificationActionReceiver.kt"
      provides: "BroadcastReceiver handling notification quick action intents"
      contains: "class NotificationActionReceiver"
    - path: "rns-android/src/main/AndroidManifest.xml"
      provides: "Receiver registration for notification actions"
      contains: "NotificationActionReceiver"
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt"
      provides: "Pause/resume/reconnect methods and paused state tracking"
      contains: "fun pause"
  key_links:
    - from: "NotificationActionReceiver"
      to: "ReticulumService"
      via: "Intent actions trigger service methods"
      pattern: "ACTION_PAUSE|ACTION_RESUME|ACTION_RECONNECT"
    - from: "ReticulumService"
      to: "Transport"
      via: "Pause stops Transport job loop, Resume restarts it"
      pattern: "stopCoroutineJobLoop|configureCoroutineJobLoop"
---

<objective>
Implement notification quick actions (Reconnect and Pause/Resume) with their backing service logic.

Purpose: Add the two notification action buttons that let users control Reticulum without opening the app. Reconnect triggers immediate interface reconnection. Pause stops all Transport activity (job loop + WorkManager) while keeping the service alive. Resume restarts everything. The Pause/Resume button dynamically toggles. This requires a BroadcastReceiver for intent handling, and new pause/resume/reconnect methods on ReticulumService.

Output: NotificationActionReceiver, manifest registration, ReticulumService pause/resume/reconnect API
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-service-notification-ux/14-CONTEXT.md
@.planning/phases/14-service-notification-ux/14-01-SUMMARY.md
@rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt
@rns-android/src/main/kotlin/network/reticulum/android/ServiceConnectionState.kt
@rns-android/src/main/kotlin/network/reticulum/android/NotificationContentBuilder.kt
@rns-android/src/main/kotlin/network/reticulum/android/ReticulumWorker.kt
@rns-android/src/main/AndroidManifest.xml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pause/resume/reconnect methods to ReticulumService</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt</files>
  <action>
Add pause, resume, and reconnect capabilities to ReticulumService:

1. **Add state tracking fields:**
   - `private var _isPaused = false` - Whether service is in paused state
   - `val isPaused: Boolean get() = _isPaused` - Public read access
   - `private var sessionStartTime: Long = 0L` - Set to System.currentTimeMillis() when service starts (in onStartCommand)
   - `val sessionStartTimeMs: Long get() = sessionStartTime` - Public read access

2. **Add a `pause()` method:**
   - Set `_isPaused = true`
   - Cancel the Transport coroutine job loop: call `Transport.stopJobLoop()` (this is the private `stopCoroutineJobLoop` — we need a public wrapper). Since Transport's stopCoroutineJobLoop is private, instead set `Transport.customJobIntervalMs = Long.MAX_VALUE` to effectively freeze the job loop. This is simpler and doesn't require modifying Transport internals.
   - IMPORTANT: Actually, reviewing Transport code, the job loop uses `delay(interval)`. Setting `customJobIntervalMs` to `Long.MAX_VALUE` would make it delay for effectively forever — this is the cleanest pause mechanism.
   - Cancel WorkManager: `ReticulumWorker.cancel(this)`
   - Log: `Log.i(TAG, "Service paused by user")`
   - Call `onPauseStateChanged()` (a new callback method, see below)

3. **Add a `resume()` method:**
   - Set `_isPaused = false`
   - Restore Transport job interval by re-collecting the current policy: Reset `Transport.customJobIntervalMs` to the current policy-based value. The simplest approach: trigger a re-evaluation by getting the current policy from `policyProvider.currentPolicy` and computing the interval:
     ```kotlin
     val baseIntervalMs = TransportConstants.JOB_INTERVAL
     val policy = policyProvider.currentPolicy
     Transport.customJobIntervalMs = (baseIntervalMs * policy.throttleMultiplier).toLong()
     ```
   - Re-schedule WorkManager: `ReticulumWorker.schedule(this, intervalMinutes = 15)`
   - Trigger immediate reconnection on all interfaces (call `reconnectInterfaces()`)
   - Log: `Log.i(TAG, "Service resumed by user")`
   - Call `onPauseStateChanged()`

4. **Add a `reconnectInterfaces()` method:**
   - Get all Transport-registered interfaces: `Transport.getInterfaces()`
   - For each interface that has the underlying `Interface` accessible, call its reconnection mechanism
   - Since Transport returns `InterfaceRef` objects, we need to iterate and trigger reconnection. The simplest approach: get the real interface objects via their adapters. Actually, TCPClientInterface has `onNetworkChanged()` which resets backoff and triggers reconnection. Use that.
   - Iterate Transport interfaces and for each one that wraps a TCPClientInterface (check via `InterfaceAdapter.getWrappedInterface()`), call `onNetworkChanged()`
   - Log: `Log.i(TAG, "Triggering reconnection on all interfaces")`

5. **Add `onPauseStateChanged` callback field:**
   - `var onPauseStateChanged: (() -> Unit)? = null` - Called when pause state changes, Plan 03 will set this to trigger notification update

6. **Set `sessionStartTime`** in `onStartCommand` before `initializeReticulum()`:
   - `sessionStartTime = System.currentTimeMillis()`

7. **Add public static action constants** in companion object:
   - `const val ACTION_PAUSE = "network.reticulum.android.ACTION_PAUSE"`
   - `const val ACTION_RESUME = "network.reticulum.android.ACTION_RESUME"`
   - `const val ACTION_RECONNECT = "network.reticulum.android.ACTION_RECONNECT"`

8. **Add static service instance tracking** for BroadcastReceiver access:
   - `private var instance: ReticulumService? = null` in companion
   - `fun getInstance(): ReticulumService? = instance` in companion
   - Set `instance = this` in `onCreate()`, `instance = null` in `onDestroy()`

Note: `InterfaceAdapter` stores a map of wrapped interfaces. Check if there's a `getWrappedInterface()` or similar. If not, use a different approach: since `InterfaceRef` has a `name` field, and we can check `is TCPClientInterface` on the underlying interface, iterate the Transport interfaces and check the adapter's inner interface. The `InterfaceAdapter` class has a `companion` with `getOrCreate()` — look at its internals to find how to access the wrapped interface. If the adapter doesn't expose the wrapped interface, an alternative is to have ReticulumService maintain its own reference to started interfaces. Since `reconnectInterfaces()` is a best-effort operation, logging a warning if the inner interface isn't accessible is acceptable.

Actually, the cleanest approach for reconnect: just call `onNetworkChanged()` for every interface by keeping a reference in ReticulumService. But the service doesn't directly manage interfaces — InterfaceManager in the sample app does. So the reconnect action should go through a callback. Add:
   - `var onReconnectRequested: (() -> Unit)? = null` - Called when reconnect is requested, sample app ViewModel will set this

For the service itself, it can also attempt to reconnect via Transport's interface list as a best-effort backup.
  </action>
  <verify>Build compiles: `cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin 2>&1 | tail -5`</verify>
  <done>ReticulumService has pause(), resume(), reconnectInterfaces() methods. isPaused state tracked. sessionStartTime tracked. Static instance available for BroadcastReceiver access. Action constants defined.</done>
</task>

<task type="auto">
  <name>Task 2: Create NotificationActionReceiver and register in manifest</name>
  <files>
    rns-android/src/main/kotlin/network/reticulum/android/NotificationActionReceiver.kt
    rns-android/src/main/AndroidManifest.xml
  </files>
  <action>
**Create `NotificationActionReceiver.kt`** in `network.reticulum.android` package:

1. **Class `NotificationActionReceiver : BroadcastReceiver()`** that handles notification quick action intents:

2. **`onReceive(context, intent)` method:**
   - Match `intent.action` against:
     - `ReticulumService.ACTION_PAUSE`:
       - Get service instance: `ReticulumService.getInstance()`
       - If non-null, call `service.pause()`
       - Log: `Log.i(TAG, "Pause action received")`
     - `ReticulumService.ACTION_RESUME`:
       - Get service instance: `ReticulumService.getInstance()`
       - If non-null, call `service.resume()`
       - Log: `Log.i(TAG, "Resume action received")`
     - `ReticulumService.ACTION_RECONNECT`:
       - Get service instance: `ReticulumService.getInstance()`
       - If non-null, call `service.reconnectInterfaces()`
       - Log: `Log.i(TAG, "Reconnect action received")`
   - If service instance is null, log warning: "Service not running, ignoring action"

3. **Companion object** with `TAG = "NotifActionReceiver"`

4. **Helper function `buildActions(context: Context, isPaused: Boolean): List<NotificationCompat.Action>`**:
   - Create Reconnect action:
     - Icon: `android.R.drawable.ic_popup_sync` (standard sync icon)
     - Label: "Reconnect"
     - PendingIntent: `PendingIntent.getBroadcast(context, 0, Intent(ReticulumService.ACTION_RECONNECT).setPackage(context.packageName), PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT)`
     - Only include when NOT paused (reconnect during pause makes no sense)
   - Create Pause/Resume action:
     - Icon: `android.R.drawable.ic_media_pause` for pause, `android.R.drawable.ic_media_play` for resume
     - Label: "Pause" when not paused, "Resume" when paused
     - PendingIntent: Use ACTION_PAUSE or ACTION_RESUME based on `isPaused`
     - Same PendingIntent flags as above, but use request code 1 to differentiate from Reconnect
   - Return list of applicable actions

**Update `rns-android/src/main/AndroidManifest.xml`**:
   - Add receiver registration inside the `<application>` tag:
     ```xml
     <receiver
         android:name=".NotificationActionReceiver"
         android:exported="false" />
     ```
   - The `android:exported="false"` ensures only the app's own intents can reach it.
  </action>
  <verify>Build compiles: `cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin 2>&1 | tail -5`</verify>
  <done>NotificationActionReceiver handles PAUSE, RESUME, RECONNECT intents. buildActions() produces dynamic button list (Reconnect hidden when paused, Pause/Resume toggles). Receiver registered in AndroidManifest. Module compiles.</done>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin` succeeds
2. ReticulumService.pause() sets isPaused=true and freezes Transport
3. ReticulumService.resume() restores Transport interval and reconnects
4. NotificationActionReceiver dispatches actions to service instance
5. AndroidManifest includes receiver registration
6. buildActions() returns Reconnect + Pause when running, Resume only when paused
</verification>

<success_criteria>
- Three notification actions (Pause, Resume, Reconnect) functional via BroadcastReceiver
- Pause freezes Transport job loop (Long.MAX_VALUE interval) and cancels WorkManager
- Resume restores policy-based interval and re-schedules WorkManager
- Reconnect triggers interface reconnection via onNetworkChanged()
- Dynamic button: Pause when running, Resume when paused
- Reconnect hidden when paused
- Receiver registered in manifest as non-exported
- rns-android module compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/14-service-notification-ux/14-02-SUMMARY.md`
</output>
