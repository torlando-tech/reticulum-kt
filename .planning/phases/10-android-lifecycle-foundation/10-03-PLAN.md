---
phase: 10-android-lifecycle-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/NetworkStateObserver.kt
  - rns-android/src/main/kotlin/network/reticulum/android/BatteryOptimizationChecker.kt
autonomous: true

must_haves:
  truths:
    - "NetworkStateObserver exposes network state via StateFlow"
    - "Network state includes WiFi/Cellular/None and interface names"
    - "NetworkStateObserver debounces rapid network transitions"
    - "NetworkStateObserver maintains timestamped history buffer"
    - "BatteryOptimizationChecker exposes optimization status via StateFlow"
    - "Both observers are injectable for testing"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/NetworkStateObserver.kt"
      provides: "Network state observation with StateFlow API"
      exports: ["NetworkStateObserver", "NetworkState", "NetworkStateChange"]
    - path: "rns-android/src/main/kotlin/network/reticulum/android/BatteryOptimizationChecker.kt"
      provides: "Battery optimization status observation"
      exports: ["BatteryOptimizationChecker", "BatteryOptimizationStatus"]
  key_links:
    - from: "NetworkStateObserver"
      to: "ConnectivityManager"
      via: "NetworkCallback for network changes"
      pattern: "ConnectivityManager.NetworkCallback"
    - from: "BatteryOptimizationChecker"
      to: "PowerManager"
      via: "isIgnoringBatteryOptimizations check"
      pattern: "isIgnoringBatteryOptimizations"
---

<objective>
Create NetworkStateObserver and BatteryOptimizationChecker with StateFlow-based APIs.

Purpose: Downstream phases need network state (for reconnection logic) and battery optimization status (for guiding users). These observers provide clean StateFlow APIs with history tracking (NetworkStateObserver) and current status checking (BatteryOptimizationChecker).

Output:
- NetworkStateObserver.kt with WiFi/Cellular/None tracking and interface names
- BatteryOptimizationChecker.kt with optimization status exposure
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-android-lifecycle-foundation/10-CONTEXT.md
@rns-android/src/main/kotlin/network/reticulum/android/NetworkMonitor.kt
@rns-android/src/main/kotlin/network/reticulum/android/DozeHandler.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NetworkStateObserver with StateFlow API</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/NetworkStateObserver.kt</files>
  <action>
Create NetworkStateObserver.kt that wraps ConnectivityManager in a StateFlow:

```kotlin
package network.reticulum.android

import android.content.Context
import android.net.ConnectivityManager
import android.net.LinkProperties
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import java.util.concurrent.ConcurrentLinkedDeque
import java.util.concurrent.atomic.AtomicBoolean

/**
 * Represents the current network connection type.
 */
sealed class NetworkType {
    /** Connected via WiFi. */
    data object WiFi : NetworkType()

    /** Connected via cellular (mobile data). */
    data object Cellular : NetworkType()

    /** No network connection available. */
    data object None : NetworkType()

    override fun toString(): String = when (this) {
        is WiFi -> "WiFi"
        is Cellular -> "Cellular"
        is None -> "None"
    }
}

/**
 * Complete network state including connection type and interface details.
 */
data class NetworkState(
    val type: NetworkType,
    val interfaceName: String? = null,
    val isAvailable: Boolean = type != NetworkType.None
) {
    override fun toString(): String = when {
        interfaceName != null -> "$type ($interfaceName)"
        else -> type.toString()
    }
}

/**
 * A timestamped network state change for history tracking.
 */
data class NetworkStateChange(
    val state: NetworkState,
    val timestamp: Long = System.currentTimeMillis()
) {
    override fun toString(): String = "$state at ${java.text.SimpleDateFormat("HH:mm:ss.SSS", java.util.Locale.US).format(timestamp)}"
}

/**
 * Observes Android network state changes.
 *
 * Provides a [StateFlow] of the current network state and maintains a history
 * buffer of recent state changes for debugging and logging. Includes debouncing
 * to handle rapid WiFi/cellular handoffs gracefully.
 *
 * Usage:
 * ```kotlin
 * val observer = NetworkStateObserver(context)
 * observer.start()
 *
 * // Current state
 * val isWifi = observer.state.value.type == NetworkType.WiFi
 *
 * // React to changes
 * observer.state.collect { state ->
 *     when (state.type) {
 *         NetworkType.WiFi -> onWifiConnected(state.interfaceName)
 *         NetworkType.Cellular -> onCellularConnected(state.interfaceName)
 *         NetworkType.None -> onDisconnected()
 *     }
 * }
 *
 * observer.stop()
 * ```
 *
 * @param context Application or service context
 * @param historySize Maximum number of state changes to keep (default: 20)
 * @param debounceMs Debounce time for rapid network changes (default: 500ms)
 */
class NetworkStateObserver(
    private val context: Context,
    private val historySize: Int = 20,
    private val debounceMs: Long = 500L
) {
    private val connectivityManager = context.getSystemService(ConnectivityManager::class.java)
    private var networkCallback: ConnectivityManager.NetworkCallback? = null
    private val started = AtomicBoolean(false)

    private val _state = MutableStateFlow(getCurrentState())

    /**
     * The current network state as a StateFlow.
     *
     * Use `.value` for immediate access or `collect` for reactive updates.
     */
    val state: StateFlow<NetworkState> = _state.asStateFlow()

    private val history = ConcurrentLinkedDeque<NetworkStateChange>()

    /**
     * Recent network state changes, newest first.
     *
     * Limited to [historySize] entries (default 20).
     */
    val recentHistory: List<NetworkStateChange>
        get() = history.toList()

    // Debounce job for coalescing rapid changes
    private val debounceScope = CoroutineScope(Dispatchers.Default)
    private var debounceJob: Job? = null
    private var pendingState: NetworkState? = null

    /**
     * Start observing network state changes.
     */
    fun start() {
        if (started.getAndSet(true)) return

        // Record initial state
        recordStateChange(_state.value)

        networkCallback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                updateStateDebounced()
            }

            override fun onLost(network: Network) {
                updateStateDebounced()
            }

            override fun onCapabilitiesChanged(
                network: Network,
                capabilities: NetworkCapabilities
            ) {
                updateStateDebounced()
            }

            override fun onLinkPropertiesChanged(
                network: Network,
                linkProperties: LinkProperties
            ) {
                updateStateDebounced()
            }
        }

        val request = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()

        connectivityManager.registerNetworkCallback(request, networkCallback!!)
        Log.i(TAG, "Started observing network state. Current: ${_state.value}")
    }

    /**
     * Stop observing network state changes.
     */
    fun stop() {
        if (!started.getAndSet(false)) return

        debounceJob?.cancel()
        debounceJob = null

        networkCallback?.let {
            try {
                connectivityManager.unregisterNetworkCallback(it)
            } catch (e: Exception) {
                // May not be registered
            }
        }
        networkCallback = null
        Log.i(TAG, "Stopped observing network state")
    }

    /**
     * Check if currently observing.
     */
    val isObserving: Boolean
        get() = started.get()

    private fun updateStateDebounced() {
        val newState = getCurrentState()
        pendingState = newState

        debounceJob?.cancel()
        debounceJob = debounceScope.launch {
            delay(debounceMs)

            pendingState?.let { state ->
                val oldState = _state.value
                if (state != oldState) {
                    Log.i(TAG, "Network state changed: $oldState -> $state")
                    recordStateChange(state)
                    _state.value = state
                }
            }
        }
    }

    private fun getCurrentState(): NetworkState {
        val activeNetwork = connectivityManager.activeNetwork
        val capabilities = activeNetwork?.let { connectivityManager.getNetworkCapabilities(it) }
        val linkProperties = activeNetwork?.let { connectivityManager.getLinkProperties(it) }

        if (activeNetwork == null || capabilities == null) {
            return NetworkState(NetworkType.None)
        }

        val interfaceName = linkProperties?.interfaceName

        val type = when {
            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) -> NetworkType.WiFi
            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) -> NetworkType.Cellular
            else -> NetworkType.None
        }

        return NetworkState(type, interfaceName)
    }

    private fun recordStateChange(state: NetworkState) {
        history.addFirst(NetworkStateChange(state))
        while (history.size > historySize) {
            history.removeLast()
        }
    }

    companion object {
        private const val TAG = "NetworkStateObserver"
    }
}
```

Key design decisions:
- NetworkType sealed class (WiFi, Cellular, None) - simple states as per CONTEXT.md
- NetworkState data class includes interface name (wlan0, rmnet0) for detailed logging
- 500ms debounce to coalesce rapid WiFi/cellular handoffs
- Same StateFlow + history pattern as DozeStateObserver
- Trusts ConnectivityManager state (no extra connectivity pings per CONTEXT.md)
  </action>
  <verify>
Verify compilation:
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin 2>&1 | tail -20
```

Verify StateFlow API:
```bash
grep -E "StateFlow|state:" rns-android/src/main/kotlin/network/reticulum/android/NetworkStateObserver.kt
```
  </verify>
  <done>
NetworkStateObserver exists with StateFlow API, debouncing, and interface names.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BatteryOptimizationChecker with StateFlow API</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/BatteryOptimizationChecker.kt</files>
  <action>
Create BatteryOptimizationChecker.kt for battery optimization status:

```kotlin
package network.reticulum.android

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.PowerManager
import android.util.Log
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * Represents the app's battery optimization status.
 */
sealed class BatteryOptimizationStatus {
    /**
     * App is battery-optimized (default Android behavior).
     * Background restrictions may apply in Doze mode.
     */
    data object Optimized : BatteryOptimizationStatus()

    /**
     * App is exempt from battery optimization.
     * Can maintain network connections during Doze maintenance windows.
     */
    data object Unrestricted : BatteryOptimizationStatus()

    override fun toString(): String = when (this) {
        is Optimized -> "Optimized"
        is Unrestricted -> "Unrestricted"
    }

    /**
     * Whether the app is exempt from battery optimization.
     */
    val isExempt: Boolean
        get() = this is Unrestricted
}

/**
 * Checks and observes battery optimization status for this app.
 *
 * Battery optimization affects whether the app can maintain network connections
 * during Doze mode. Unrestricted apps can use maintenance windows more freely.
 *
 * Usage:
 * ```kotlin
 * val checker = BatteryOptimizationChecker(context)
 * checker.start()
 *
 * // Current status
 * if (checker.status.value.isExempt) {
 *     // App is unrestricted
 * }
 *
 * // React to changes (rare - only changes when user modifies settings)
 * checker.status.collect { status ->
 *     updateUI(status)
 * }
 *
 * checker.stop()
 * ```
 *
 * @param context Application or service context
 */
class BatteryOptimizationChecker(
    private val context: Context
) {
    private val powerManager = context.getSystemService(PowerManager::class.java)
    private var receiver: BroadcastReceiver? = null

    private val _status = MutableStateFlow(getCurrentStatus())

    /**
     * The current battery optimization status as a StateFlow.
     *
     * Use `.value` for immediate access or `collect` for reactive updates.
     */
    val status: StateFlow<BatteryOptimizationStatus> = _status.asStateFlow()

    /**
     * Convenience property for checking if app is exempt from battery optimization.
     */
    val isExempt: Boolean
        get() = _status.value.isExempt

    /**
     * Start observing battery optimization status changes.
     *
     * Note: Status changes are rare - only when user manually changes
     * battery settings for this app.
     */
    fun start() {
        if (receiver != null) return

        receiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                if (intent.action == PowerManager.ACTION_POWER_SAVE_WHITELIST_CHANGED) {
                    updateStatus()
                }
            }
        }

        val filter = IntentFilter(PowerManager.ACTION_POWER_SAVE_WHITELIST_CHANGED)
        context.registerReceiver(receiver, filter)

        Log.i(TAG, "Started checking battery optimization. Current: ${_status.value}")
    }

    /**
     * Stop observing battery optimization status changes.
     */
    fun stop() {
        receiver?.let {
            try {
                context.unregisterReceiver(it)
            } catch (e: Exception) {
                // May not be registered
            }
        }
        receiver = null
        Log.i(TAG, "Stopped checking battery optimization")
    }

    /**
     * Check if currently observing.
     */
    val isObserving: Boolean
        get() = receiver != null

    /**
     * Force a status refresh.
     *
     * Useful after requesting battery optimization exemption to check the result.
     */
    fun refresh() {
        updateStatus()
    }

    private fun updateStatus() {
        val newStatus = getCurrentStatus()
        val oldStatus = _status.value

        if (newStatus != oldStatus) {
            Log.i(TAG, "Battery optimization status changed: $oldStatus -> $newStatus")
            _status.value = newStatus
        }
    }

    private fun getCurrentStatus(): BatteryOptimizationStatus {
        return if (powerManager.isIgnoringBatteryOptimizations(context.packageName)) {
            BatteryOptimizationStatus.Unrestricted
        } else {
            BatteryOptimizationStatus.Optimized
        }
    }

    companion object {
        private const val TAG = "BatteryOptChecker"
    }
}
```

Key design decisions:
- Simple Optimized/Unrestricted sealed class (matches phase requirement)
- isExempt convenience property for quick checks
- refresh() method for checking status after exemption request
- Uses ACTION_POWER_SAVE_WHITELIST_CHANGED to detect changes
- No history buffer needed (changes are rare, user-initiated)
- Simpler than other observers since status rarely changes
  </action>
  <verify>
Verify compilation:
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin 2>&1 | tail -20
```

Verify StateFlow API:
```bash
grep -E "StateFlow|status:" rns-android/src/main/kotlin/network/reticulum/android/BatteryOptimizationChecker.kt
```
  </verify>
  <done>
BatteryOptimizationChecker exists with StateFlow API and refresh capability.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify all new observers compile together</name>
  <files>
    rns-android/src/main/kotlin/network/reticulum/android/NetworkStateObserver.kt
    rns-android/src/main/kotlin/network/reticulum/android/BatteryOptimizationChecker.kt
  </files>
  <action>
Run a full build to ensure all new observers compile and integrate:

1. Compile the entire Android module
2. Verify no conflicts with existing classes (NetworkMonitor, BatteryMonitor, DozeHandler)
3. Ensure all imports resolve correctly

All existing monitor/handler classes can remain - they provide listener-based APIs that may still be useful for backward compatibility. The new observers provide the StateFlow-based API required by Phase 10.
  </action>
  <verify>
Full build:
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin 2>&1 | tail -30
```

Check all observers exist:
```bash
ls -la rns-android/src/main/kotlin/network/reticulum/android/*Observer.kt rns-android/src/main/kotlin/network/reticulum/android/*Checker.kt 2>/dev/null
```
  </verify>
  <done>
All Phase 10 observers compile successfully and coexist with existing monitors.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. All files exist:
```bash
ls -la rns-android/src/main/kotlin/network/reticulum/android/NetworkStateObserver.kt
ls -la rns-android/src/main/kotlin/network/reticulum/android/BatteryOptimizationChecker.kt
```

2. Full compilation succeeds:
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
Expected: BUILD SUCCESSFUL

3. NetworkStateObserver has StateFlow:
```bash
grep "val state: StateFlow<NetworkState>" rns-android/src/main/kotlin/network/reticulum/android/NetworkStateObserver.kt
```

4. NetworkState includes interface name:
```bash
grep "interfaceName" rns-android/src/main/kotlin/network/reticulum/android/NetworkStateObserver.kt
```

5. BatteryOptimizationChecker has StateFlow:
```bash
grep "val status: StateFlow<BatteryOptimizationStatus>" rns-android/src/main/kotlin/network/reticulum/android/BatteryOptimizationChecker.kt
```

6. Debouncing in NetworkStateObserver:
```bash
grep "debounceMs" rns-android/src/main/kotlin/network/reticulum/android/NetworkStateObserver.kt
```
</verification>

<success_criteria>
- NetworkStateObserver.kt exists with StateFlow<NetworkState>
- NetworkState includes WiFi/Cellular/None types
- NetworkState includes optional interfaceName
- NetworkStateObserver has configurable debouncing (default 500ms)
- NetworkStateObserver has history buffer with recentHistory property
- BatteryOptimizationChecker.kt exists with StateFlow<BatteryOptimizationStatus>
- BatteryOptimizationStatus has Optimized/Unrestricted states
- BatteryOptimizationChecker has refresh() method
- All code compiles successfully with existing codebase
</success_criteria>

<output>
After completion, create `.planning/phases/10-android-lifecycle-foundation/10-03-SUMMARY.md`
</output>
