---
phase: 10-android-lifecycle-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "DozeStateObserver is instantiated and started in ReticulumService"
    - "NetworkStateObserver is instantiated and started in ReticulumService"
    - "BatteryOptimizationChecker is instantiated and started in ReticulumService"
    - "All observers are stopped in service onDestroy"
    - "Observers are exposed via public getters for downstream phase access"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt"
      provides: "Observer lifecycle integration"
      contains: "DozeStateObserver"
      min_lines: 360
  key_links:
    - from: "ReticulumService.kt"
      to: "DozeStateObserver"
      via: "instantiation in onCreate, start(), stop() in onDestroy"
      pattern: "dozeObserver\\.start\\(\\)"
    - from: "ReticulumService.kt"
      to: "NetworkStateObserver"
      via: "instantiation in onCreate, start(), stop() in onDestroy"
      pattern: "networkObserver\\.start\\(\\)"
    - from: "ReticulumService.kt"
      to: "BatteryOptimizationChecker"
      via: "instantiation in onCreate, start(), stop() in onDestroy"
      pattern: "batteryChecker\\.start\\(\\)"
---

<objective>
Integrate lifecycle-aware observers into ReticulumService.

Purpose: Close verification gaps by wiring DozeStateObserver, NetworkStateObserver, and BatteryOptimizationChecker into service lifecycle. The observers exist but are orphaned - they need instantiation, start/stop lifecycle management, and public getters for downstream phase access.

Output: Updated ReticulumService.kt with all three observers integrated and operational.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-android-lifecycle-foundation/10-VERIFICATION.md

# Existing observer implementations - read to understand their APIs
@rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt
@rns-android/src/main/kotlin/network/reticulum/android/NetworkStateObserver.kt
@rns-android/src/main/kotlin/network/reticulum/android/BatteryOptimizationChecker.kt
@rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add observer properties and lifecycle integration</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt</files>
  <action>
    Add three lateinit observer properties at the top of ReticulumService:

    ```kotlin
    private lateinit var dozeObserver: DozeStateObserver
    private lateinit var networkObserver: NetworkStateObserver
    private lateinit var batteryChecker: BatteryOptimizationChecker
    ```

    In onCreate(), after createNotificationChannel():
    1. Instantiate all three observers with `this` context
    2. Call start() on each observer
    3. Log initial states at Info level using android.util.Log:
       - "Doze state: ${dozeObserver.state.value}"
       - "Network state: ${networkObserver.state.value}"
       - "Battery optimization: ${batteryChecker.status.value}"
    4. Launch StateFlow collectors in lifecycleScope with placeholder log statements:

    ```kotlin
    lifecycleScope.launch {
        dozeObserver.state.collect { state ->
            Log.i(TAG, "Doze state changed: $state")
            // Phase 12 will implement actual reactions
        }
    }

    lifecycleScope.launch {
        networkObserver.state.collect { state ->
            Log.i(TAG, "Network state changed: $state")
            // Phase 12 will implement actual reactions
        }
    }

    lifecycleScope.launch {
        batteryChecker.status.collect { status ->
            Log.i(TAG, "Battery optimization status: $status")
            // Phase 15 will implement guidance flow
        }
    }
    ```

    In onDestroy(), BEFORE super.onDestroy() and other cleanup:
    1. Stop all observers: dozeObserver.stop(), networkObserver.stop(), batteryChecker.stop()

    Add TAG companion object constant if not present:
    ```kotlin
    private const val TAG = "ReticulumService"
    ```

    IMPORTANT: Reactions (onDozeEntered, onWifiConnected, etc.) are Phase 12 scope. This task only wires up observers with placeholder logging. The collectors should log state changes but take no other action.
  </action>
  <verify>
    - Build passes: `cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin`
    - No lint errors in ReticulumService.kt
    - grep confirms observer instantiation: `grep -n "DozeStateObserver\|NetworkStateObserver\|BatteryOptimizationChecker" rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt`
  </verify>
  <done>
    All three observers are instantiated in onCreate(), started, StateFlows collected with placeholder logging, and stopped in onDestroy(). Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add public getters for downstream access</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt</files>
  <action>
    Add three public getter methods for downstream phase access (Phase 12 will use these):

    ```kotlin
    /**
     * Get the Doze state observer.
     * Downstream phases use this to react to Doze mode changes.
     */
    fun getDozeObserver(): DozeStateObserver = dozeObserver

    /**
     * Get the network state observer.
     * Downstream phases use this to react to network transitions.
     */
    fun getNetworkObserver(): NetworkStateObserver = networkObserver

    /**
     * Get the battery optimization checker.
     * Downstream phases use this for exemption flow and status display.
     */
    fun getBatteryChecker(): BatteryOptimizationChecker = batteryChecker
    ```

    Place these after the existing getReticulum(), getConfig(), isRunning() methods for consistency.
  </action>
  <verify>
    - Build passes: `cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin`
    - grep confirms public getters: `grep -n "fun get.*Observer\|fun get.*Checker" rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt`
  </verify>
  <done>
    Public getters exist for all three observers, enabling downstream phases to access them via bound service.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Build verification:**
   ```bash
   cd ~/repos/public/reticulum-kt
   JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
   ```
   Expected: BUILD SUCCESSFUL

2. **Observer integration check:**
   ```bash
   grep -n "dozeObserver\|networkObserver\|batteryChecker" \
     rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt
   ```
   Expected: Lines showing declaration, instantiation, start(), stop(), and getters

3. **Lifecycle ordering check:**
   - Confirm observers stop BEFORE super.onDestroy()
   - Confirm observers start AFTER service is ready in onCreate()

4. **No orphaned artifacts:**
   ```bash
   grep -r "DozeStateObserver\|NetworkStateObserver\|BatteryOptimizationChecker" \
     rns-android/src/main/kotlin/network/reticulum/android/ | grep -v ".kt:1:"
   ```
   Expected: ReticulumService.kt now imports and uses all three classes
</verification>

<success_criteria>
- All three observers instantiated in ReticulumService.onCreate()
- All three observers started with start() method
- StateFlows collected in lifecycleScope with placeholder logging
- All three observers stopped in onDestroy() before super call
- Public getters exposed for downstream phase access
- Build passes with no errors or warnings
</success_criteria>

<output>
After completion, create `.planning/phases/10-android-lifecycle-foundation/10-04-SUMMARY.md`
</output>
