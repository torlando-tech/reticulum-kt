---
phase: 10-android-lifecycle-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt
autonomous: true

must_haves:
  truths:
    - "DozeStateObserver exposes current Doze state via StateFlow"
    - "StateFlow emits on Doze state changes (enter/exit)"
    - "Observer maintains timestamped history buffer of last 20 changes"
    - "History is accessible via recentHistory property"
    - "Observer is injectable (not a singleton) for testing"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt"
      provides: "Doze state observation with StateFlow API"
      exports: ["DozeStateObserver", "DozeState", "DozeStateChange"]
  key_links:
    - from: "DozeStateObserver"
      to: "PowerManager"
      via: "ACTION_DEVICE_IDLE_MODE_CHANGED broadcast receiver"
      pattern: "PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED"
---

<objective>
Create DozeStateObserver with StateFlow-based API and history tracking.

Purpose: Downstream phases need to react to Doze state changes. This observer provides a clean StateFlow API (.value for current state, collect for changes) with a history buffer for debugging and logging. The observer is injectable for testing with fakes.

Output:
- DozeStateObserver.kt with StateFlow exposure and history buffer
- DozeState sealed class for type-safe state representation
- DozeStateChange data class for timestamped history entries
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-android-lifecycle-foundation/10-CONTEXT.md
@rns-android/src/main/kotlin/network/reticulum/android/DozeHandler.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DozeStateObserver with StateFlow API</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt</files>
  <action>
Create DozeStateObserver.kt that wraps PowerManager's Doze state in a StateFlow:

```kotlin
package network.reticulum.android

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.PowerManager
import android.util.Log
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.util.concurrent.ConcurrentLinkedDeque

/**
 * Represents the device's Doze state.
 */
sealed class DozeState {
    /** Device is in normal operation (not Doze). */
    data object Active : DozeState()

    /** Device is in Doze mode - network access restricted. */
    data object Dozing : DozeState()

    override fun toString(): String = when (this) {
        is Active -> "Active"
        is Dozing -> "Dozing"
    }
}

/**
 * A timestamped Doze state change for history tracking.
 */
data class DozeStateChange(
    val state: DozeState,
    val timestamp: Long = System.currentTimeMillis()
) {
    override fun toString(): String = "$state at ${java.text.SimpleDateFormat("HH:mm:ss.SSS", java.util.Locale.US).format(timestamp)}"
}

/**
 * Observes Android Doze mode state changes.
 *
 * Provides a [StateFlow] of the current Doze state and maintains a history
 * buffer of recent state changes for debugging and logging.
 *
 * Usage:
 * ```kotlin
 * val observer = DozeStateObserver(context)
 * observer.start()
 *
 * // Current state
 * val isDozing = observer.state.value == DozeState.Dozing
 *
 * // React to changes
 * observer.state.collect { state ->
 *     when (state) {
 *         DozeState.Active -> resumeNormalOperation()
 *         DozeState.Dozing -> reduceActivity()
 *     }
 * }
 *
 * // View history
 * observer.recentHistory.forEach { change ->
 *     println("${change.state} at ${change.timestamp}")
 * }
 *
 * observer.stop()
 * ```
 *
 * @param context Application or service context for system services
 * @param historySize Maximum number of state changes to keep in history (default: 20)
 */
class DozeStateObserver(
    private val context: Context,
    private val historySize: Int = 20
) {
    private val powerManager = context.getSystemService(PowerManager::class.java)
    private var receiver: BroadcastReceiver? = null

    private val _state = MutableStateFlow(getCurrentState())

    /**
     * The current Doze state as a StateFlow.
     *
     * Use `.value` for immediate access or `collect` for reactive updates.
     */
    val state: StateFlow<DozeState> = _state.asStateFlow()

    // Thread-safe deque for history - newest at front
    private val history = ConcurrentLinkedDeque<DozeStateChange>()

    /**
     * Recent Doze state changes, newest first.
     *
     * Limited to [historySize] entries (default 20).
     */
    val recentHistory: List<DozeStateChange>
        get() = history.toList()

    /**
     * Start observing Doze state changes.
     *
     * Must be called before state changes will be tracked.
     * Safe to call multiple times - subsequent calls are no-ops.
     */
    fun start() {
        if (receiver != null) return // Already started

        // Record initial state in history
        recordStateChange(_state.value)

        receiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context, intent: Intent) {
                if (intent.action == PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED) {
                    val newState = getCurrentState()
                    val oldState = _state.value

                    if (newState != oldState) {
                        Log.i(TAG, "Doze state changed: $oldState -> $newState")
                        recordStateChange(newState)
                        _state.value = newState
                    }
                }
            }
        }

        val filter = IntentFilter(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED)
        context.registerReceiver(receiver, filter)

        Log.i(TAG, "Started observing Doze state. Current: ${_state.value}")
    }

    /**
     * Stop observing Doze state changes.
     *
     * Safe to call multiple times or before start().
     */
    fun stop() {
        receiver?.let {
            try {
                context.unregisterReceiver(it)
            } catch (e: Exception) {
                // May not be registered
            }
        }
        receiver = null
        Log.i(TAG, "Stopped observing Doze state")
    }

    /**
     * Check if currently observing.
     */
    val isObserving: Boolean
        get() = receiver != null

    private fun getCurrentState(): DozeState {
        return if (powerManager.isDeviceIdleMode) {
            DozeState.Dozing
        } else {
            DozeState.Active
        }
    }

    private fun recordStateChange(state: DozeState) {
        history.addFirst(DozeStateChange(state))

        // Trim to size limit
        while (history.size > historySize) {
            history.removeLast()
        }
    }

    companion object {
        private const val TAG = "DozeStateObserver"
    }
}
```

Key design decisions:
- Sealed class for DozeState (type-safe, exhaustive when)
- StateFlow as single API (current value + reactive collection)
- Injectable class, not singleton (testable with fakes)
- ConcurrentLinkedDeque for thread-safe history
- Newest-first history (most recent changes at front)
- Configurable history size (default 20)
- Idempotent start/stop (safe to call multiple times)
- Info-level logging on state changes only (not every callback)
- Follows existing codebase logging pattern with TAG
  </action>
  <verify>
Verify compilation:
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin 2>&1 | tail -20
```

Verify StateFlow API:
```bash
grep -E "StateFlow|state:" rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt
```
Should show StateFlow usage.

Verify history tracking:
```bash
grep -E "recentHistory|historySize|ConcurrentLinkedDeque" rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt
```
Should show history implementation.
  </verify>
  <done>
DozeStateObserver exists with StateFlow API and history buffer.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify DozeStateObserver compiles and is importable</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt</files>
  <action>
Run a full debug build to ensure DozeStateObserver compiles correctly and integrates with the existing codebase:

1. Compile the Android module
2. Verify no import conflicts with existing DozeHandler
3. Ensure StateFlow dependencies are resolved (kotlinx.coroutines.flow)

The existing DozeHandler.kt can remain - it provides a different API (listener-based) that may still be useful. DozeStateObserver provides the new StateFlow-based API that Phase 10 requires.
  </action>
  <verify>
Full build check:
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin 2>&1 | tail -30
```

Check DozeState exports:
```bash
grep -E "^sealed class|^data class|^class" rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt
```
Should show DozeState, DozeStateChange, and DozeStateObserver.
  </verify>
  <done>
DozeStateObserver compiles and coexists with existing DozeHandler.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. File exists:
```bash
ls -la rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt
```

2. Compilation succeeds:
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
Expected: BUILD SUCCESSFUL

3. StateFlow API present:
```bash
grep "val state: StateFlow<DozeState>" rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt
```
Expected: Should match

4. History tracking present:
```bash
grep "val recentHistory: List<DozeStateChange>" rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt
```
Expected: Should match

5. DozeState sealed class:
```bash
grep -A5 "sealed class DozeState" rns-android/src/main/kotlin/network/reticulum/android/DozeStateObserver.kt
```
Expected: Active and Dozing states
</verification>

<success_criteria>
- DozeStateObserver.kt exists in rns-android module
- DozeState sealed class with Active and Dozing states
- DozeStateChange data class with timestamp
- StateFlow<DozeState> exposed as public property
- History buffer with configurable size (default 20)
- recentHistory property returns List<DozeStateChange>
- Idempotent start/stop methods
- Compiles successfully with existing codebase
</success_criteria>

<output>
After completion, create `.planning/phases/10-android-lifecycle-foundation/10-02-SUMMARY.md`
</output>
