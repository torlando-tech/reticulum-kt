---
phase: 21-ble-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEPeerInterface.kt

autonomous: true

must_haves:
  truths:
    - "BLEInterface extends Interface as server-style parent, processOutgoing is no-op"
    - "BLEInterface spawns BLEPeerInterface per connected peer after identity handshake"
    - "BLEPeerInterface registered with Transport via toRef() on spawn, deregistered on disconnect"
    - "Identity handshake: central reads Identity char then writes own identity to RX, peripheral waits for 16-byte write"
    - "Identity handshake times out after 30 seconds, disconnecting the peer"
    - "Identity hash comparison determines connection direction: lower identity initiates as central"
    - "Data transfer blocked until identity handshake completes"
    - "Keepalive byte 0x00 sent every 15 seconds per peer connection"
    - "BLEPeerInterface fragments outgoing packets via BLEFragmenter and reassembles incoming via BLEReassembler"
    - "Dual-role: advertise first, then scan after ~100ms delay"
    - "Duplicate identity from different address: keep newest connection, tear down oldest"
    - "Connection drop triggers backoff delay before reconnecting"
  artifacts:
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt"
      provides: "Server-style parent BLE interface with discovery, connection orchestration, identity handshake, peer lifecycle"
      exports: ["BLEInterface"]
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEPeerInterface.kt"
      provides: "Per-peer child interface with fragmentation, reassembly, keepalive, Transport integration"
      exports: ["BLEPeerInterface"]
  key_links:
    - from: "BLEInterface.kt"
      to: "BLEDriver.kt"
      via: "depends on BLEDriver interface for all BLE operations (scan, advertise, connect, disconnect)"
      pattern: "BLEDriver"
    - from: "BLEInterface.kt"
      to: "InterfaceAdapter.kt"
      via: "registers spawned BLEPeerInterface children with Transport via toRef()"
      pattern: "toRef\\(\\)"
    - from: "BLEPeerInterface.kt"
      to: "BLEFragmentation.kt"
      via: "uses BLEFragmenter for outgoing packets, BLEReassembler for incoming fragments"
      pattern: "BLEFragmenter|BLEReassembler"
    - from: "BLEPeerInterface.kt"
      to: "BLEPeerConnection"
      via: "holds reference to BLEPeerConnection for sendFragment/receivedFragments/readIdentity/writeIdentity"
      pattern: "BLEPeerConnection"
    - from: "BLEInterface.kt"
      to: "Transport"
      via: "registers/deregisters spawned interfaces via Transport.registerInterface/deregisterInterface"
      pattern: "Transport\\.(register|deregister)Interface"
---

<objective>
Implement BLEInterface.kt and BLEPeerInterface.kt -- the core orchestration layer that wires BLE discovery, connection direction, identity handshake, and peer lifecycle into a working BLE mesh.

Purpose: These two classes are the heart of the BLE interface. BLEInterface is a server-style parent (like LocalServerInterface) that collects BLEDriver events, decides connection direction via identity hash sorting, performs the identity handshake, and spawns BLEPeerInterface children. Each BLEPeerInterface handles fragmentation/reassembly, keepalive, and Transport integration for a single connected peer. Together they transform the raw BLEDriver plumbing (Phases 18-20) into a fully functional Reticulum interface.

Output: `BLEInterface.kt` and `BLEPeerInterface.kt` in `rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-ble-orchestration/21-CONTEXT.md
@.planning/phases/21-ble-orchestration/21-RESEARCH.md

# Established parent/child interface pattern (follow this exactly):
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/local/LocalServerInterface.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/local/LocalClientInterface.kt

# Interface base class and adapter:
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/Interface.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/InterfaceAdapter.kt

# BLE infrastructure (Phase 18-20 outputs):
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEDriver.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEConstants.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEFragmentation.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/DiscoveredPeer.kt

# Python reference (read for orchestration logic):
@~/repos/ble-reticulum/src/ble_reticulum/BLEInterface.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement BLEInterface.kt</name>
  <files>rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt</files>
  <action>
Create `BLEInterface.kt` in `network.reticulum.interfaces.ble`. This is the server-style parent interface that orchestrates the entire BLE mesh lifecycle. It follows the LocalServerInterface pattern exactly: spawns children, registers them with Transport, and its own processOutgoing() is a no-op.

**Class signature:**
```kotlin
class BLEInterface(
    name: String,
    private val driver: BLEDriver,
    private val transportIdentity: ByteArray, // 16-byte Transport identity hash
    private val maxConnections: Int = 5,       // Conservative default, configurable up to 7
) : Interface(name)
```

**Interface properties (override):**
```kotlin
override val bitrate: Int = 40_000   // ~40 kbps practical BLE throughput
override val canReceive: Boolean = true
override val canSend: Boolean = true
```

**Internal state:**
```kotlin
private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

// Identity hex -> BLEPeerInterface
private val peers = ConcurrentHashMap<String, BLEPeerInterface>()

// BLE MAC address -> identity hex (for routing received data)
private val addressToIdentity = ConcurrentHashMap<String, String>()

// Identity hex -> BLE MAC address (for reverse lookup)
private val identityToAddress = ConcurrentHashMap<String, String>()

// Temporary blacklist: address -> blacklist expiry timestamp
private val blacklist = ConcurrentHashMap<String, Long>()
private val blacklistDurationMs = 60_000L // 60 seconds

// Reconnection backoff: address -> next-attempt-after timestamp
private val reconnectBackoff = ConcurrentHashMap<String, Long>()
private val reconnectDelayMs = 7_000L // 7s within the 5-10s range

init {
    spawnedInterfaces = mutableListOf()
}
```

**start():**
```kotlin
override fun start() {
    online.set(true)

    // Set transport identity on the driver (for GATT server Identity characteristic)
    // This is a downcast to AndroidBLEDriver -- safe because it's the only BLEDriver impl
    // If the driver doesn't support it, silently skip
    try {
        (driver as? network.reticulum.android.ble.AndroidBLEDriver)?.setTransportIdentity(transportIdentity)
    } catch (e: Exception) {
        // Pure JVM context -- can't cast, that's fine
    }

    // Start dual-role BLE operations
    scope.launch {
        try {
            driver.startAdvertising()
            log("Advertising started")
        } catch (e: Exception) {
            log("Failed to start advertising: ${e.message}")
        }
    }
    scope.launch {
        delay(100) // Brief delay per CONTEXT.md decision
        try {
            driver.startScanning()
            log("Scanning started")
        } catch (e: Exception) {
            log("Failed to start scanning: ${e.message}")
        }
    }

    // Event collection coroutines
    scope.launch { collectDiscoveredPeers() }
    scope.launch { collectIncomingConnections() }
    scope.launch { collectDisconnections() }
    scope.launch { periodicCleanup() }
}
```

IMPORTANT: The `setTransportIdentity` call above uses a problematic downcast. Since BLEInterface lives in rns-interfaces (pure JVM) and AndroidBLEDriver is in rns-android, BLEInterface cannot import it. Instead, add a `setTransportIdentity(ByteArray)` method to the BLEDriver interface. This is a small API addition that maintains the abstraction. If that feels too invasive, use reflection or skip the cast entirely and let InterfaceManager handle setting the identity before calling start(). The simplest approach: **have the caller (InterfaceManager) set the identity on the driver before passing it to BLEInterface.** Then BLEInterface doesn't need to know about setTransportIdentity at all. Use this approach.

Revised start() -- NO downcast, caller sets identity on driver before construction:
```kotlin
override fun start() {
    online.set(true)

    scope.launch {
        try {
            driver.startAdvertising()
            log("Advertising started")
        } catch (e: Exception) {
            log("Failed to start advertising: ${e.message}")
        }
    }
    scope.launch {
        delay(100)
        try {
            driver.startScanning()
            log("Scanning started")
        } catch (e: Exception) {
            log("Failed to start scanning: ${e.message}")
        }
    }

    scope.launch { collectDiscoveredPeers() }
    scope.launch { collectIncomingConnections() }
    scope.launch { collectDisconnections() }
    scope.launch { periodicCleanup() }
}
```

**processOutgoing() -- no-op (server-style parent):**
```kotlin
override fun processOutgoing(data: ByteArray) {
    // No-op: Transport calls each spawned BLEPeerInterface's processOutgoing() directly
}
```

**Identity-based connection direction sorting:**
```kotlin
/**
 * Determine if we should initiate (as central) or wait (as peripheral).
 * Lower identity hash acts as central (initiator).
 * Uses identity hash instead of MAC because Android cannot reliably
 * provide the local BLE MAC address (returns 02:00:00:00:00:00).
 */
private fun shouldInitiateConnection(peerIdentity: ByteArray): Boolean {
    for (i in transportIdentity.indices) {
        val local = transportIdentity[i].toInt() and 0xFF
        val remote = peerIdentity[i].toInt() and 0xFF
        if (local < remote) return true   // We are lower -> we initiate
        if (local > remote) return false  // They are lower -> they initiate
    }
    // Equal identity hashes (astronomically unlikely) -- don't connect
    return false
}
```

NOTE: For the initial connection, we don't have the peer's identity yet (we only have their BLE address from scanning). The identity hash sorting can only be used AFTER reading the peer's Identity characteristic. So the approach is: always connect to discovered peers (if we have capacity and they're not blacklisted), perform the identity handshake, and THEN decide if we should keep or drop the connection based on identity sorting. If both sides connect simultaneously, the handshake will reveal both are connected to the same peer, and deduplication by identity will keep the newest connection.

Revised approach for discovered peers -- connect optimistically, sort after handshake:
```kotlin
private suspend fun collectDiscoveredPeers() {
    driver.discoveredPeers.collect { peer ->
        // Skip if already connected to this address
        if (addressToIdentity.containsKey(peer.address)) return@collect

        // Skip if blacklisted
        if (isBlacklisted(peer.address)) return@collect

        // Skip if in reconnection backoff
        if (isInBackoff(peer.address)) return@collect

        // Skip if at capacity
        if (peers.size >= maxConnections) return@collect

        // Attempt connection
        scope.launch {
            connectToPeer(peer)
        }
    }
}
```

**connectToPeer -- the main connection flow:**
```kotlin
private suspend fun connectToPeer(peer: DiscoveredPeer) {
    val address = peer.address
    log("Connecting to ${address.takeLast(8)}...")

    try {
        val connection = driver.connect(address)

        // Perform identity handshake (central side)
        val peerIdentity = performHandshakeAsCentral(connection)
        val identityHex = peerIdentity.joinToString("") { "%02x".format(it) }

        // Check for duplicate identity
        val existingAddress = identityToAddress[identityHex]
        if (existingAddress != null && existingAddress != address) {
            // Same identity at different address (MAC rotation or dual-connect)
            // Keep newest connection, tear down oldest
            log("Duplicate identity ${identityHex.take(8)}: replacing ${existingAddress.takeLast(8)} with ${address.takeLast(8)}")
            tearDownPeer(identityHex)
        }

        // Check connection direction: if peer's identity is lower, they should have
        // been the initiator. But we already connected. That's fine for now -- the
        // dedup logic above handles race conditions. Just proceed.

        // Store identity mapping
        connection.identity = peerIdentity
        addressToIdentity[address] = identityHex
        identityToAddress[identityHex] = address

        // Spawn peer interface
        spawnPeerInterface(address, identityHex, peerIdentity, connection)

        // Restart advertising (some chipsets stop after connection)
        driver.restartAdvertisingIfNeeded()

        log("Connected to ${identityHex.take(8)} at ${address.takeLast(8)}")

    } catch (e: kotlinx.coroutines.TimeoutCancellationException) {
        log("Handshake timeout for ${address.takeLast(8)}, blacklisting")
        blacklist[address] = System.currentTimeMillis() + blacklistDurationMs
        try { driver.disconnect(address) } catch (_: Exception) {}
    } catch (e: Exception) {
        log("Connection failed for ${address.takeLast(8)}: ${e.message}")
        reconnectBackoff[address] = System.currentTimeMillis() + reconnectDelayMs
    }
}
```

NOTE: `driver.restartAdvertisingIfNeeded()` is not on the BLEDriver interface. Since BLEInterface is pure JVM and cannot import AndroidBLEDriver, either: (a) add this method to BLEDriver interface with a default no-op implementation, or (b) skip it and let advertising resilience be handled entirely by the BleAdvertiser's 60-second refresh. Choose option (b) for simplicity -- the 60-second refresh in BleAdvertiser is sufficient. Remove the `restartAdvertisingIfNeeded()` call.

**performHandshakeAsCentral:**
```kotlin
private suspend fun performHandshakeAsCentral(conn: BLEPeerConnection): ByteArray {
    return withTimeout(BLEConstants.IDENTITY_HANDSHAKE_TIMEOUT_MS) {
        // Step 1: Read peripheral's identity from Identity characteristic
        val peerIdentity = conn.readIdentity()
        require(peerIdentity.size == BLEConstants.IDENTITY_SIZE) {
            "Invalid identity size: ${peerIdentity.size} (expected ${BLEConstants.IDENTITY_SIZE})"
        }

        // Step 2: Write our identity to the peer's RX characteristic
        conn.writeIdentity(transportIdentity)

        peerIdentity
    }
}
```

**collectIncomingConnections (peripheral side):**
```kotlin
private suspend fun collectIncomingConnections() {
    driver.incomingConnections.collect { connection ->
        scope.launch {
            handleIncomingConnection(connection)
        }
    }
}

private suspend fun handleIncomingConnection(connection: BLEPeerConnection) {
    val address = connection.address
    log("Incoming connection from ${address.takeLast(8)}, waiting for identity handshake...")

    try {
        // Peripheral side: wait for central to write its identity to RX
        val peerIdentity = performHandshakeAsPeripheral(connection)
        val identityHex = peerIdentity.joinToString("") { "%02x".format(it) }

        // Check for duplicate identity
        val existingAddress = identityToAddress[identityHex]
        if (existingAddress != null && existingAddress != address) {
            log("Duplicate identity ${identityHex.take(8)}: replacing ${existingAddress.takeLast(8)} with ${address.takeLast(8)}")
            tearDownPeer(identityHex)
        }

        // Store identity mapping
        connection.identity = peerIdentity
        addressToIdentity[address] = identityHex
        identityToAddress[identityHex] = address

        // Spawn peer interface
        spawnPeerInterface(address, identityHex, peerIdentity, connection)

        log("Accepted peer ${identityHex.take(8)} from ${address.takeLast(8)}")

    } catch (e: kotlinx.coroutines.TimeoutCancellationException) {
        log("Identity handshake timeout for incoming ${address.takeLast(8)}, disconnecting")
        blacklist[address] = System.currentTimeMillis() + blacklistDurationMs
        try { driver.disconnect(address) } catch (_: Exception) {}
    } catch (e: Exception) {
        log("Failed to process incoming connection from ${address.takeLast(8)}: ${e.message}")
        try { driver.disconnect(address) } catch (_: Exception) {}
    }
}
```

**performHandshakeAsPeripheral:**
```kotlin
private suspend fun performHandshakeAsPeripheral(conn: BLEPeerConnection): ByteArray {
    return withTimeout(BLEConstants.IDENTITY_HANDSHAKE_TIMEOUT_MS) {
        // Wait for central to write its 16-byte identity to RX
        // The first 16-byte write is the identity handshake
        conn.receivedFragments.first { fragment ->
            fragment.size == BLEConstants.IDENTITY_SIZE
        }
    }
}
```

**spawnPeerInterface:**
```kotlin
private fun spawnPeerInterface(
    address: String,
    identityHex: String,
    peerIdentity: ByteArray,
    connection: BLEPeerConnection,
) {
    // Check if interface already exists for this identity
    val existing = peers[identityHex]
    if (existing != null) {
        // Update address mapping (MAC rotation)
        existing.updateConnection(connection, address)
        addressToIdentity[address] = identityHex
        identityToAddress[identityHex] = address
        log("Reused existing interface for ${identityHex.take(8)} at new address ${address.takeLast(8)}")
        return
    }

    val peerName = "BLE|${identityHex.take(8)}"
    val peerInterface = BLEPeerInterface(
        name = peerName,
        connection = connection,
        parentBleInterface = this,
        peerIdentity = peerIdentity,
    )
    peerInterface.parentInterface = this

    // Set callback BEFORE toRef() -- InterfaceAdapter only sets if null
    peerInterface.onPacketReceived = { data, iface ->
        onPacketReceived?.invoke(data, iface)
    }

    peers[identityHex] = peerInterface
    spawnedInterfaces?.add(peerInterface)

    peerInterface.startReceiving()

    try {
        Transport.registerInterface(peerInterface.toRef())
    } catch (e: Exception) {
        log("Could not register peer interface with Transport: ${e.message}")
    }

    log("Spawned peer interface: $peerName (total: ${peers.size})")
}
```

**collectDisconnections:**
```kotlin
private suspend fun collectDisconnections() {
    driver.connectionLost.collect { address ->
        val identityHex = addressToIdentity.remove(address)
        if (identityHex != null) {
            // Check if this was the current address for this identity
            if (identityToAddress[identityHex] == address) {
                identityToAddress.remove(identityHex)
                tearDownPeer(identityHex)
            }
            // Set backoff for reconnection
            reconnectBackoff[address] = System.currentTimeMillis() + reconnectDelayMs
        }
        log("Connection lost: ${address.takeLast(8)}")
    }
}
```

**tearDownPeer:**
```kotlin
internal fun tearDownPeer(identityHex: String) {
    val peerInterface = peers.remove(identityHex) ?: return
    spawnedInterfaces?.remove(peerInterface)

    try {
        Transport.deregisterInterface(peerInterface.toRef())
    } catch (e: Exception) {
        log("Could not deregister peer interface from Transport: ${e.message}")
    }

    peerInterface.detach()
    log("Torn down peer: ${peerInterface.name}")
}

/**
 * Called by BLEPeerInterface when it detects a fatal error (keepalive failure).
 */
internal fun peerDisconnected(peerInterface: BLEPeerInterface) {
    val identityHex = peerInterface.peerIdentity.joinToString("") { "%02x".format(it) }
    peers.remove(identityHex)
    spawnedInterfaces?.remove(peerInterface)

    try {
        Transport.deregisterInterface(peerInterface.toRef())
    } catch (e: Exception) {
        log("Could not deregister peer interface from Transport: ${e.message}")
    }

    log("Peer disconnected: ${peerInterface.name} (remaining: ${peers.size})")
}
```

**Blacklist and backoff helpers:**
```kotlin
private fun isBlacklisted(address: String): Boolean {
    val expiry = blacklist[address] ?: return false
    if (System.currentTimeMillis() > expiry) {
        blacklist.remove(address)
        return false
    }
    return true
}

private fun isInBackoff(address: String): Boolean {
    val nextAttemptAfter = reconnectBackoff[address] ?: return false
    if (System.currentTimeMillis() > nextAttemptAfter) {
        reconnectBackoff.remove(address)
        return false
    }
    return true
}
```

**periodicCleanup -- clean up stale blacklist/backoff entries:**
```kotlin
private suspend fun periodicCleanup() {
    while (online.get() && !detached.get()) {
        delay(30_000) // Every 30 seconds
        val now = System.currentTimeMillis()

        // Clean expired blacklist entries
        blacklist.entries.removeIf { it.value < now }

        // Clean expired backoff entries
        reconnectBackoff.entries.removeIf { it.value < now }
    }
}
```

**detach():**
```kotlin
override fun detach() {
    super.detach()
    scope.cancel()

    // Detach all peer interfaces
    for ((identityHex, peerInterface) in peers.toMap()) {
        try {
            Transport.deregisterInterface(peerInterface.toRef())
        } catch (e: Exception) {
            // Ignore during shutdown
        }
        peerInterface.detach()
    }
    peers.clear()
    addressToIdentity.clear()
    identityToAddress.clear()

    // Shut down the BLE driver
    driver.shutdown()

    log("Interface stopped")
}
```

**Logging helper:**
```kotlin
private fun log(message: String) {
    println("[BLEInterface][$name] $message")
}
```

**toString:**
```kotlin
override fun toString(): String = "BLEInterface[$name]"
```

**Required imports:**
```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.first
import network.reticulum.interfaces.Interface
import network.reticulum.interfaces.toRef
import network.reticulum.transport.Transport
import java.util.concurrent.ConcurrentHashMap
```
  </action>
  <verify>
Build rns-interfaces to verify compilation:
```
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:compileKotlin
```
BLEInterface.kt should compile. Note: BLEPeerInterface may not exist yet, so there may be a compile error referencing it. That's expected -- it will be resolved in Task 2.

If there's a circular dependency issue, create a minimal BLEPeerInterface stub first and fill it in Task 2.
  </verify>
  <done>
BLEInterface.kt exists in rns-interfaces/ble/ with:
- Extends Interface (server-style parent, processOutgoing is no-op)
- Dual-role startup: advertise first, then scan after 100ms delay
- Discovery collection: connects to discovered peers, skipping blacklisted/backoff/at-capacity
- Incoming connection handling: waits for identity handshake from central
- Identity handshake: central reads Identity char then writes own identity (30s timeout)
- Identity-based connection direction sorting (lower identity initiates)
- Duplicate identity detection: keeps newest connection, tears down oldest
- Peer spawning: creates BLEPeerInterface, registers with Transport via toRef()
- Peer teardown: deregisters from Transport, cleans up state
- Blacklist (60s) on handshake timeout, reconnection backoff (7s)
- Periodic cleanup of expired blacklist/backoff entries
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement BLEPeerInterface.kt</name>
  <files>rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEPeerInterface.kt</files>
  <action>
Create `BLEPeerInterface.kt` in `network.reticulum.interfaces.ble`. This is the per-peer child interface that handles fragmentation, reassembly, keepalive, and data transfer for a single connected BLE peer. It follows the LocalClientInterface pattern.

**Class signature:**
```kotlin
class BLEPeerInterface(
    name: String,
    private var connection: BLEPeerConnection,
    private val parentBleInterface: BLEInterface,
    val peerIdentity: ByteArray,
) : Interface(name)
```

**Interface properties:**
```kotlin
override val bitrate: Int = 40_000 // ~40 kbps BLE practical throughput
override val canReceive: Boolean = true
override val canSend: Boolean = true
```

**Internal state:**
```kotlin
private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
private var receiveJob: Job? = null
private var keepaliveJob: Job? = null

private var fragmenter = BLEFragmenter(connection.mtu)
private var reassembler = BLEReassembler()

// Keepalive tracking
@Volatile
private var lastKeepaliveReceived = System.currentTimeMillis()

init {
    this.parentInterface = parentBleInterface
}
```

**startReceiving() -- called by BLEInterface after spawn:**
```kotlin
fun startReceiving() {
    online.set(true)

    receiveJob = scope.launch { receiveLoop() }
    keepaliveJob = scope.launch { keepaliveLoop() }
}
```

**receiveLoop -- collect fragments and reassemble:**
```kotlin
private suspend fun receiveLoop() {
    try {
        connection.receivedFragments.collect { fragment ->
            if (!online.get() || detached.get()) return@collect

            // Filter keepalive bytes
            if (fragment.size == 1 && fragment[0] == BLEConstants.KEEPALIVE_BYTE) {
                lastKeepaliveReceived = System.currentTimeMillis()
                return@collect
            }

            // Skip identity handshake data (16 bytes exactly, already consumed)
            // This handles the case where the handshake data is re-emitted
            if (fragment.size == BLEConstants.IDENTITY_SIZE) {
                return@collect
            }

            try {
                val packet = reassembler.receiveFragment(fragment, connection.address)
                if (packet != null) {
                    processIncoming(packet) // Delivers to Transport via onPacketReceived
                }
            } catch (e: Exception) {
                log("Reassembly error: ${e.message}")
            }
        }
    } catch (e: CancellationException) {
        // Normal cancellation
    } catch (e: Exception) {
        if (!detached.get()) {
            log("Receive loop error: ${e.message}")
            detach()
        }
    }
}
```

**processOutgoing -- fragment and send:**

Transport calls this method synchronously. BLE send is inherently async (suspend function). Use `runBlocking(Dispatchers.IO)` to bridge, matching the pattern used in AndroidBLEDriver's MTU getter.

```kotlin
override fun processOutgoing(data: ByteArray) {
    if (!online.get() || detached.get()) return

    try {
        val fragments = fragmenter.fragment(data)

        runBlocking(Dispatchers.IO) {
            for (frag in fragments) {
                connection.sendFragment(frag)
            }
        }

        txBytes.addAndGet(data.size.toLong())
        parentInterface?.txBytes?.addAndGet(data.size.toLong())

    } catch (e: Exception) {
        log("Send failed: ${e.message}")
        // Don't detach on single send failure -- BLE is lossy
        // Reticulum handles retransmission at a higher level
    }
}
```

**keepaliveLoop -- send 0x00 every 15 seconds:**
```kotlin
private suspend fun keepaliveLoop() {
    try {
        while (online.get() && !detached.get()) {
            delay(BLEConstants.KEEPALIVE_INTERVAL_MS)

            if (!online.get() || detached.get()) break

            try {
                connection.sendFragment(byteArrayOf(BLEConstants.KEEPALIVE_BYTE))
            } catch (e: Exception) {
                // Keepalive failure -- grace period:
                // Send one more after waiting another interval, then tear down
                log("Keepalive failed, grace period...")
                delay(BLEConstants.KEEPALIVE_INTERVAL_MS)

                if (!online.get() || detached.get()) break

                try {
                    connection.sendFragment(byteArrayOf(BLEConstants.KEEPALIVE_BYTE))
                } catch (e2: Exception) {
                    log("Keepalive failed after grace period, disconnecting")
                    detach()
                    break
                }
            }
        }
    } catch (e: CancellationException) {
        // Normal cancellation
    }
}
```

**updateConnection -- for MAC rotation / reconnection:**
```kotlin
/**
 * Update the underlying BLE connection (for MAC rotation).
 * Called by BLEInterface when the same identity connects from a new address.
 */
fun updateConnection(newConnection: BLEPeerConnection, newAddress: String) {
    // Cancel old receive/keepalive jobs
    receiveJob?.cancel()
    keepaliveJob?.cancel()

    // Close old connection
    try { connection.close() } catch (_: Exception) {}

    // Set new connection
    connection = newConnection
    fragmenter = BLEFragmenter(newConnection.mtu)
    reassembler = BLEReassembler()

    // Restart receive and keepalive
    receiveJob = scope.launch { receiveLoop() }
    keepaliveJob = scope.launch { keepaliveLoop() }

    log("Connection updated to ${newAddress.takeLast(8)}")
}
```

**detach:**
```kotlin
override fun detach() {
    if (detached.getAndSet(true)) return
    online.set(false)

    // Cancel coroutines
    receiveJob?.cancel()
    keepaliveJob?.cancel()
    scope.cancel()

    // Close BLE connection
    try { connection.close() } catch (_: Exception) {}

    // Notify parent
    parentBleInterface.peerDisconnected(this)
}
```

**Logging helper:**
```kotlin
private fun log(message: String) {
    println("[BLEPeerInterface][$name] $message")
}
```

**toString:**
```kotlin
override fun toString(): String = "BLEPeerInterface[$name]"
```

**Required imports:**
```kotlin
import kotlinx.coroutines.*
import network.reticulum.interfaces.Interface
```
  </action>
  <verify>
Build rns-interfaces to verify compilation:
```
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:compileKotlin
```
Both BLEInterface.kt and BLEPeerInterface.kt should compile cleanly. Verify that:
- BLEInterface and BLEPeerInterface both extend Interface
- BLEPeerInterface.processOutgoing uses BLEFragmenter
- BLEPeerInterface receiveLoop uses BLEReassembler
- No Android imports in either file (pure JVM)
  </verify>
  <done>
BLEPeerInterface.kt exists in rns-interfaces/ble/ with:
- Extends Interface (per-peer child pattern)
- Owns BLEFragmenter and BLEReassembler (per peer)
- receiveLoop: collects fragments from BLEPeerConnection, filters keepalives, reassembles packets, delivers to Transport
- processOutgoing: fragments data and sends via BLEPeerConnection (runBlocking bridge)
- keepaliveLoop: sends 0x00 byte every 15s with grace period on failure (try again, then disconnect)
- updateConnection: swaps underlying BLE connection for MAC rotation
- detach: cancels coroutines, closes connection, notifies parent
- Pure JVM (no Android imports)
  </done>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:compileKotlin` succeeds
2. BLEInterface.kt extends Interface with processOutgoing() as no-op
3. BLEInterface.kt depends only on BLEDriver interface (no Android imports)
4. BLEInterface spawns BLEPeerInterface children and registers them with Transport via toRef()
5. Identity handshake: central reads Identity char, writes own identity (30s timeout)
6. Duplicate identity detection: same identity at different address tears down old connection
7. BLEPeerInterface.processOutgoing uses BLEFragmenter to fragment, runBlocking to send
8. BLEPeerInterface receiveLoop uses BLEReassembler, filters keepalives
9. Keepalive sent every 15 seconds with grace period on failure
10. Both files are pure JVM (no android.* imports)
</verification>

<success_criteria>
- rns-interfaces compiles with BLEInterface and BLEPeerInterface
- BLEInterface follows LocalServerInterface pattern (spawn/register/deregister)
- Identity handshake, connection direction, keepalive, fragmentation all implemented
- Phase 21 requirements ID-01..05, CONN-01..07 addressed
</success_criteria>

<output>
After completion, create `.planning/phases/21-ble-orchestration/21-01-SUMMARY.md`
</output>
