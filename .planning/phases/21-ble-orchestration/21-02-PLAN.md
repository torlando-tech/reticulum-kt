---
phase: 21-ble-orchestration
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/service/InterfaceManager.kt
  - rns-sample-app/src/main/AndroidManifest.xml

autonomous: true

must_haves:
  truths:
    - "InterfaceManager.startInterface() creates and starts a BLEInterface when InterfaceType.BLE config is received"
    - "AndroidBLEDriver is constructed with application Context and BluetoothManager"
    - "Transport identity hash is set on AndroidBLEDriver before BLEInterface.start() is called"
    - "BLEInterface is registered with Transport for lifecycle tracking"
    - "BLE interface creation is launched on Dispatchers.IO (async, same pattern as RNODE)"
    - "InterfaceManager.stopInterface() calls detach() on BLEInterface, which shuts down the driver"
    - "BLUETOOTH_ADVERTISE permission is declared in sample app AndroidManifest.xml"
    - "BLE permissions (SCAN, CONNECT, ADVERTISE) are required before starting BLE interface"
  artifacts:
    - path: "rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/service/InterfaceManager.kt"
      provides: "BLE case in startInterface() creating AndroidBLEDriver + BLEInterface"
      exports: ["InterfaceManager"]
    - path: "rns-sample-app/src/main/AndroidManifest.xml"
      provides: "BLUETOOTH_ADVERTISE permission declaration"
  key_links:
    - from: "InterfaceManager.kt"
      to: "AndroidBLEDriver.kt"
      via: "constructs AndroidBLEDriver and sets transport identity"
      pattern: "AndroidBLEDriver"
    - from: "InterfaceManager.kt"
      to: "BLEInterface.kt"
      via: "constructs BLEInterface with driver, starts it, registers with Transport"
      pattern: "BLEInterface"
    - from: "InterfaceManager.kt"
      to: "Transport"
      via: "reads Transport.identity?.hash for identity handshake"
      pattern: "Transport\\.identity"
---

<objective>
Integrate BLEInterface into the sample app's InterfaceManager, completing the app-level wiring that makes BLE mesh available to end users.

Purpose: Plan 21-01 creates the pure-JVM BLEInterface and BLEPeerInterface classes, but they need to be wired into the app through InterfaceManager. This plan fills the existing placeholder BLE case in InterfaceManager.startInterface() with real AndroidBLEDriver construction and BLEInterface lifecycle management. It also adds the missing BLUETOOTH_ADVERTISE permission to the sample app manifest.

Output: Updated `InterfaceManager.kt` with working BLE case and updated `AndroidManifest.xml` with complete BLE permissions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/21-ble-orchestration/21-CONTEXT.md
@.planning/phases/21-ble-orchestration/21-RESEARCH.md

# Plan 21-01 output (the classes being integrated):
@.planning/phases/21-ble-orchestration/21-01-PLAN.md

# The file being modified:
@rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/service/InterfaceManager.kt

# AndroidBLEDriver (the BLE driver implementation to construct):
@rns-android/src/main/kotlin/network/reticulum/android/ble/AndroidBLEDriver.kt

# BLEInterface (the interface being created):
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEInterface.kt

# Manifest to update:
@rns-sample-app/src/main/AndroidManifest.xml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire BLE case in InterfaceManager.startInterface()</name>
  <files>rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/service/InterfaceManager.kt</files>
  <action>
Replace the placeholder BLE case in `InterfaceManager.startInterface()` with a working implementation. Follow the same async pattern used by the RNODE case (launch on Dispatchers.IO, register asynchronously).

**Replace the BLE case (lines 283-288):**

Replace this:
```kotlin
InterfaceType.BLE -> {
    // BLE interface would require Android Bluetooth APIs
    // Not implemented yet
    Log.w(TAG, "BLE interface not yet implemented")
    null
}
```

With this implementation:
```kotlin
InterfaceType.BLE -> {
    // BLE connection and setup requires Android BLE APIs and is async,
    // so launch on IO dispatcher (same pattern as RNODE)
    scope.launch(Dispatchers.IO) {
        try {
            // Require Transport identity before starting BLE
            val identityHash = Transport.identity?.hash
                ?: throw IllegalStateException("Transport identity not available for BLE interface")

            // Construct the Android BLE driver
            val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE)
                as android.bluetooth.BluetoothManager
            val driver = network.reticulum.android.ble.AndroidBLEDriver(
                context = context,
                bluetoothManager = bluetoothManager,
                scope = scope,
            )

            // Set transport identity on the GATT server Identity characteristic
            // This MUST be done before BLEInterface.start() so the identity is
            // available when peers read it during the handshake
            driver.setTransportIdentity(identityHash)

            // Create the BLEInterface (pure JVM, lives in rns-interfaces)
            val iface = network.reticulum.interfaces.ble.BLEInterface(
                name = config.name,
                driver = driver,
                transportIdentity = identityHash,
            )

            // Set up packet callback (same pattern as TCP/Auto)
            iface.onPacketReceived = { data, fromInterface ->
                Transport.inbound(data, InterfaceAdapter.getOrCreate(fromInterface))
            }

            // Start BLE operations (advertise, scan, event collection)
            iface.start()

            // Register parent interface with Transport for lifecycle tracking
            Transport.registerInterface(InterfaceAdapter.getOrCreate(iface))
            runningInterfaces[config.id] = iface

            Log.i(TAG, "Started BLE interface: ${config.name}")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to start BLE interface ${config.name}: ${e.message}", e)
        }
    }
    // Return null -- the interface will be registered asynchronously
    // when the BLE setup completes (same pattern as RNODE)
    null
}
```

**Also update the stopInterface() method** to handle BLEInterface by adding a case. The BLEInterface's `detach()` method already shuts down the BLE driver, so a simple `detach()` call is sufficient. The existing `else -> iface.detach()` fallback already covers this, so no change is needed for stopInterface.

**Add the required import** at the top of the file:
```kotlin
import android.content.Context
```

Note: `Context` is already imported indirectly since the class constructor takes `Context`. The `android.bluetooth.BluetoothManager` and other Android-specific imports are used via fully-qualified names in the BLE case to keep the import section minimal. `network.reticulum.android.ble.AndroidBLEDriver` and `network.reticulum.interfaces.ble.BLEInterface` are also fully-qualified to avoid import clutter for types used in only one place.

Alternatively, add explicit imports if the project style prefers it:
```kotlin
import android.bluetooth.BluetoothManager
import network.reticulum.android.ble.AndroidBLEDriver
import network.reticulum.interfaces.ble.BLEInterface
```
  </action>
  <verify>
Build the sample app to verify compilation:
```
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-sample-app:compileDebugKotlin
```
The BLE case in InterfaceManager should compile without errors. The key verification:
- AndroidBLEDriver constructor is called with correct parameters (Context, BluetoothManager, scope)
- setTransportIdentity is called with the identity hash byte array
- BLEInterface constructor receives (name, driver, transportIdentity)
- InterfaceAdapter.getOrCreate is used for Transport registration
  </verify>
  <done>
InterfaceManager.startInterface() BLE case:
- Creates AndroidBLEDriver with application Context and BluetoothManager
- Sets transport identity on driver BEFORE starting BLEInterface
- Constructs BLEInterface with driver and transport identity
- Sets onPacketReceived callback (same pattern as TCP/Auto)
- Starts BLE operations and registers with Transport
- Async on Dispatchers.IO (same pattern as RNODE)
- Returns null for async registration (same pattern as RNODE)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add BLUETOOTH_ADVERTISE permission to sample app manifest</name>
  <files>rns-sample-app/src/main/AndroidManifest.xml</files>
  <action>
Add the missing `BLUETOOTH_ADVERTISE` permission to the sample app's AndroidManifest.xml. This permission is required on Android 12+ (API 31) for BLE advertising. Without it, BleAdvertiser.startAdvertising() will throw a SecurityException.

The rns-android module already declares this permission in its own manifest (for manifest merger), but adding it explicitly to the sample app ensures it's present regardless of merger behavior and makes the permission requirements visible in the app's manifest.

**Add after the existing BLUETOOTH_SCAN permission (line 8):**

```xml
<uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
```

The final permissions block should be:
```xml
<!-- Bluetooth permissions -->
<uses-permission android:name="android.permission.BLUETOOTH" android:maxSdkVersion="30" />
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:maxSdkVersion="30" />
<uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
<uses-permission android:name="android.permission.BLUETOOTH_SCAN" android:usesPermissionFlags="neverForLocation" />
<uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
```

NOTE on runtime permissions: Android 12+ requires runtime permission requests for BLUETOOTH_SCAN, BLUETOOTH_CONNECT, and BLUETOOTH_ADVERTISE. The InterfaceManager BLE case should check/request these before starting, but this is delegated to the UI layer (the sample app's compose screens already handle runtime permission requests for BLE via the existing BLE/RNODE permission flow). If the permissions are not granted, the AndroidBLEDriver will throw SecurityException which is caught by the try/catch in the BLE case.
  </action>
  <verify>
Verify the permission is present:
```bash
grep -c "BLUETOOTH_ADVERTISE" rns-sample-app/src/main/AndroidManifest.xml
```
Should return 1.

Build to verify manifest is valid:
```
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-sample-app:processDebugManifest
```
  </verify>
  <done>
AndroidManifest.xml includes BLUETOOTH_ADVERTISE permission alongside the existing BLUETOOTH_SCAN and BLUETOOTH_CONNECT permissions, completing the set of BLE permissions required for dual-role BLE operation on Android 12+.
  </done>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-sample-app:compileDebugKotlin` succeeds
2. InterfaceManager BLE case creates AndroidBLEDriver with Context + BluetoothManager
3. Transport identity is set on driver before BLEInterface.start()
4. BLEInterface registered with Transport via InterfaceAdapter
5. Async launch on Dispatchers.IO (same pattern as RNODE)
6. BLUETOOTH_ADVERTISE permission in AndroidManifest.xml
7. stopInterface handles BLEInterface via existing else -> detach() fallback
</verification>

<success_criteria>
- rns-sample-app compiles with BLE case in InterfaceManager
- BLE interface can be created from stored configuration
- All three BLE permissions (SCAN, CONNECT, ADVERTISE) declared in manifest
- Phase 21 requirements APP-01, APP-02, APP-03 addressed
</success_criteria>

<output>
After completion, create `.planning/phases/21-ble-orchestration/21-02-SUMMARY.md`
</output>
