---
phase: 04-lxmf-cryptographic-interop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/MessageHashInteropTest.kt
autonomous: true

must_haves:
  truths:
    - "Kotlin message hash matches Python message hash for identical message bytes"
    - "Hash is idempotent across pack/unpack round-trip cycles"
    - "Empty content produces valid hash that matches Python"
    - "Unicode content produces hash that matches Python"
  artifacts:
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/MessageHashInteropTest.kt"
      provides: "LXMF message hash cross-implementation verification"
      min_lines: 100
  key_links:
    - from: "MessageHashInteropTest"
      to: "python lxmf_unpack"
      via: "PythonBridge call"
      pattern: "python.*lxmf_unpack"
    - from: "MessageHashInteropTest"
      to: "LXMessage.pack()"
      via: "hash computed during pack"
      pattern: "message\\.pack\\(\\)"
---

<objective>
Verify LXMF message hash computation is identical between Kotlin and Python implementations.

Purpose: Correct hash computation is prerequisite for signature validation (signature is computed over hash). This test isolates hash computation bugs from signature bugs.

Output: `MessageHashInteropTest.kt` with comprehensive hash verification tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-lxmf-cryptographic-interop/04-RESEARCH.md
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/LXMFInteropTestBase.kt
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/CustomFieldInteropTest.kt
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMessage.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MessageHashInteropTest with core hash verification</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/MessageHashInteropTest.kt</files>
  <action>
Create `MessageHashInteropTest.kt` extending `LXMFInteropTestBase`. Include:

1. **Nested class `BasicHashComputation`:**
   - `message hash matches Python for simple message` - Create message with text content, pack(), verify hash matches `lxmf_unpack` result's `message_hash`
   - `message hash matches Python for message with title` - Create message with non-empty title, verify hash matches

2. **Nested class `HashIdempotency`:**
   - `hash is idempotent after pack-unpack round-trip` - Pack message in Kotlin, send to Python's `lxmf_unpack`, verify hash matches. Then pack same message again (should use cache), verify still matches.
   - `hash computed from components matches full message hash` - Use `lxmf_hash` bridge command with same components (destination_hash, source_hash, timestamp, title, content, fields), verify matches message.hash

3. **Nested class `EdgeCases`:**
   - `empty content produces valid hash` - Create message with empty string content, verify hash matches Python
   - `empty title and content produces valid hash` - Both empty, verify matches
   - `Unicode content produces matching hash` - Content with emoji, CJK characters, verify matches Python
   - `message with fields produces matching hash` - Add FIELD_RENDERER and custom field, verify hash matches

Use `assertMessageMatchesPython()` helper from base class for field-level comparison. Add explicit hash comparison assertion with descriptive message.

Test pattern from CustomFieldInteropTest:
```kotlin
val message = createTestMessage(content = "...", fields = mutableMapOf(...))
val packed = message.pack()
val pythonResult = verifyInPython(packed)
// Hash comparison
message.hash?.toHex() shouldBe pythonResult.getString("message_hash")
```
  </action>
  <verify>
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "network.reticulum.lxmf.interop.MessageHashInteropTest" -i 2>&1 | tail -100
```
All tests pass. Look for "BUILD SUCCESSFUL" and test count.
  </verify>
  <done>
All hash tests pass:
- Simple message hash matches Python
- Message with title hash matches
- Hash idempotency verified
- Component-computed hash matches message hash
- Empty content/title edge cases pass
- Unicode content hash matches
- Fields do not break hash computation
  </done>
</task>

<task type="auto">
  <name>Task 2: Add lxmf_hash bridge command verification test</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/MessageHashInteropTest.kt</files>
  <action>
Add test to verify Kotlin can independently compute hash using components and match Python's lxmf_hash command:

```kotlin
@Test
fun `Kotlin hash computation matches Python lxmf_hash command`() {
    // Create message and pack
    val message = createTestMessage(content = "Hash verification test")
    message.pack()

    // Call Python's lxmf_hash with same components
    val pythonResult = python(
        "lxmf_hash",
        "destination_hash" to message.destinationHash.toHex(),
        "source_hash" to message.sourceHash.toHex(),
        "timestamp" to message.timestamp!!,
        "title" to message.title,
        "content" to message.content,
        "fields" to emptyMap<String, Any>()
    )

    message.hash?.toHex() shouldBe pythonResult.getString("message_hash")
}
```

This tests the two-layer verification: Kotlin's internal hash matches Python's internal hash computation (not just the final unpacked result).

If fields parameter causes issues (Map serialization to JSON), try with explicit empty map `mapOf<String, Any>()` or omit the fields parameter.
  </action>
  <verify>
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "network.reticulum.lxmf.interop.MessageHashInteropTest.HashIdempotency" -i 2>&1 | tail -50
```
Hash computation test passes.
  </verify>
  <done>
lxmf_hash command verification test passes, confirming Kotlin hash computation logic matches Python's independent computation.
  </done>
</task>

</tasks>

<verification>
Run full test suite to ensure no regressions:
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test -i 2>&1 | tail -50
```

Verify:
- All MessageHashInteropTest tests pass
- All other LXMF interop tests still pass (AttachmentFieldInteropTest, ImageFieldInteropTest, CustomFieldInteropTest)
</verification>

<success_criteria>
- MessageHashInteropTest.kt exists with 8+ test methods
- All tests pass against Python bridge
- Hash matches Python for: simple messages, messages with title, empty content, Unicode content, messages with fields
- Hash idempotency verified across round-trip
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-lxmf-cryptographic-interop/04-01-SUMMARY.md`
</output>
