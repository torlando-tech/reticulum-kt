# Phase 4: LXMF Cryptographic Interop - Research

**Researched:** 2026-01-24
**Domain:** LXMF message hash computation, Ed25519 digital signatures, Python-Kotlin cryptographic interoperability
**Confidence:** HIGH

## Summary

This research investigates the cryptographic primitives used in LXMF message hashing and signing, focusing on ensuring identical computation between Kotlin and Python implementations. The Python reference implementation uses SHA-256 for message hashing (via `RNS.Identity.full_hash()`) and Ed25519 for signatures (via `Identity.sign()` and `Identity.validate()`).

LXMF message hash is computed as: `SHA-256(destination_hash + source_hash + msgpack(payload_without_stamp))`. The signature is then computed over: `hashed_part + message_hash`. This two-layer structure means hash computation must be exactly correct before signature validation can succeed.

The existing codebase already has verified Ed25519 signature interop tests in `IdentityInteropTest.kt` proving that Kotlin signatures validate in Python and vice versa. The existing `HashInteropTest.kt` confirms SHA-256 produces identical results. For Phase 4, we extend this to LXMF message-level cryptographic operations: verify that the exact same hash is computed for identical message content, and that signatures generated by one implementation validate in the other.

**Primary recommendation:** Build on the established `InteropTestBase` pattern with dedicated LXMF cryptographic tests. Use the existing `lxmf_hash` bridge command for Python-authoritative hash computation. Test hash idempotency across pack/unpack cycles and signature cross-validation with freshly-generated keys.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| BouncyCastle | (project) | Ed25519 signing/verification, SHA-256 | Already used via CryptoProvider |
| PythonBridge | (project) | Cross-language verification | Existing infrastructure |
| Kotest | 5.8.0 | Soft assertions for multi-field verification | Established in project |
| JUnit 5 | (project) | Test runner | Standard, established |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| org.msgpack:msgpack-core | (project) | Payload serialization for hash input | Hash computation requires exact msgpack bytes |
| kotlinx-serialization-json | (project) | Bridge response parsing | All bridge communication |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Live bridge calls | Pre-computed test vectors | Vectors are static; bridge tests real Python |
| BouncyCastle | Tink or Conscrypt | BouncyCastle already integrated, well-tested |

## Architecture Patterns

### Recommended Test Structure
```
lxmf-core/src/test/kotlin/network/reticulum/lxmf/
├── LXMFCryptoInteropTest.kt     # Hash and signature cross-validation
```

The tests should be organized into nested classes:
- `MessageHashComputation` - Tests hash matches Python for same message bytes
- `SignatureCrossValidation` - Tests Kotlin sign -> Python verify AND Python sign -> Kotlin verify
- `HashIdempotency` - Tests pack -> unpack -> repack produces same hash
- `EdgeCases` - Tests empty content, Unicode content, fixture keys

### Pattern 1: Two-Layer Hash Verification
**What:** Verify both raw SHA-256 primitives AND LXMF message hash computation
**When to use:** All hash tests - isolates bugs to correct layer
**Example:**
```kotlin
// Source: Verified pattern from HashInteropTest.kt and LXMessage.kt
@Test
fun `message hash matches Python`() {
    // First verify raw SHA-256 works
    val rawData = "test data".toByteArray()
    val kotlinSha256 = crypto.sha256(rawData)
    val pythonSha256 = python("sha256", "data" to rawData).getBytes("hash")
    assertBytesEqual(pythonSha256, kotlinSha256, "Raw SHA-256")

    // Then verify LXMF message hash
    val message = createTestMessage()
    val packed = message.pack()
    val pythonResult = python("lxmf_unpack", "lxmf_bytes" to packed)
    assertBytesEqual(
        pythonResult.getBytes("message_hash"),
        message.hash!!,
        "LXMF message hash"
    )
}
```

### Pattern 2: Bidirectional Signature Testing
**What:** Test signature generation in one implementation validates in the other
**When to use:** All signature tests
**Example:**
```kotlin
// Source: Verified pattern from IdentityInteropTest.kt
@Test
fun `Kotlin signed message validates in Python`() {
    val privateKey = crypto.randomBytes(64)
    val identity = Identity.fromPrivateKey(privateKey, crypto)
    val message = createTestMessage(sourceIdentity = identity)
    message.pack()

    // Verify Python accepts the signature
    val pythonResult = python(
        "lxmf_verify_signature",
        "lxmf_bytes" to message.packed!!,
        "source_public_key" to identity.getPublicKey()
    )
    pythonResult.getBoolean("valid") shouldBe true
}

@Test
fun `Python signed message validates in Kotlin`() {
    val privateKey = crypto.randomBytes(64)
    val pythonResult = python(
        "lxmf_pack_and_sign",
        "destination_hash" to destHash,
        "source_private_key" to privateKey,
        "content" to "Hello"
    )
    val packed = pythonResult.getBytes("packed")

    // Remember source identity for validation
    Identity.remember(packetHash = ByteArray(32), destHash = sourceHash, publicKey = publicKey)

    val unpacked = LXMessage.unpackFromBytes(packed)
    unpacked!!.signatureValidated shouldBe true
}
```

### Pattern 3: Hash Idempotency Testing
**What:** Verify hash remains constant across pack/unpack/repack cycles
**When to use:** Detecting serialization drift
**Example:**
```kotlin
// Source: Context decision from 04-CONTEXT.md
@Test
fun `hash is idempotent across round-trips`() {
    val message = createTestMessage()
    val originalPacked = message.pack()
    val originalHash = message.hash!!.copyOf()

    // Python unpacks and repacks
    val pythonResult = python(
        "lxmf_unpack_repack",
        "lxmf_bytes" to originalPacked
    )
    val repacked = pythonResult.getBytes("packed")
    val pythonHash = pythonResult.getBytes("message_hash")

    // Hash should be identical
    assertBytesEqual(originalHash, pythonHash, "Hash idempotency")
}
```

### Pattern 4: Pre-computed Fixture Keys for Determinism
**What:** Use known-good keys for reproducible test cases
**When to use:** Tests that need determinism across runs
**Example:**
```kotlin
// Source: Context decision for fixture keys
companion object {
    // Pre-shared fixture keys (generated once, saved for reproducibility)
    val FIXTURE_PRIVATE_KEY = "a1b2c3d4...".hexToByteArray()  // 64 bytes
    val FIXTURE_PUBLIC_KEY = "...".hexToByteArray()  // 64 bytes

    @JvmStatic
    @BeforeAll
    fun generateFixtureKeys() {
        // Or generate fresh keys and log them for future fixture use
        val identity = Identity.create()
        println("Fixture private key: ${identity.getPrivateKey().toHex()}")
        println("Fixture public key: ${identity.getPublicKey().toHex()}")
    }
}
```

### Anti-Patterns to Avoid
- **Testing signature without testing hash:** Signature depends on hash; always verify hash first
- **Assuming Unicode doesn't matter:** UTF-8 encoding affects hash bytes
- **Modifying message after pack:** `pack()` sets `packed` cache; modifications won't reflect
- **Testing with stamp included:** Hash computation excludes stamp; ensure consistent handling

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Hash computation | Custom SHA-256 wrapper | `Hashes.fullHash()` / `crypto.sha256()` | Already matched to Python |
| Signature generation | Direct BouncyCastle calls | `Identity.sign()` | Handles key format correctly |
| Signature verification | Manual Ed25519 verify | `Identity.validate()` | Proper error handling |
| Message hash for LXMF | Custom hash logic | `LXMessage.pack()` sets `hash` field | Uses correct LXMF formula |
| Python hash verification | Manual Python script | `lxmf_hash` bridge command | Already implemented |

**Key insight:** The cryptographic primitives are already verified in Phase 1 (bridge) and existing interop tests. Phase 4 focuses on LXMF-layer composition of these primitives, not reimplementing crypto.

## Common Pitfalls

### Pitfall 1: Stamp Inclusion in Hash Input
**What goes wrong:** Including stamp in hash input produces different hash than Python
**Why it happens:** LXMF hash is computed BEFORE stamp is added; stamp is excluded from hash
**How to avoid:** Both implementations already handle this - verify by checking `packPayload` with `stamp = null`
**Warning signs:** Hash mismatch but all other fields match

### Pitfall 2: Ed25519 Seed vs Full Private Key
**What goes wrong:** Using 64-byte expanded private key instead of 32-byte seed
**Why it happens:** Ed25519 has two key formats; Python uses seed (32 bytes)
**How to avoid:** Use `Identity.sigPrv` (32-byte seed), not `getPrivateKey()` which includes X25519 portion
**Warning signs:** Signature generated but verification fails; "invalid key size" errors

### Pitfall 3: Msgpack Field Serialization Order
**What goes wrong:** Hash differs due to different field serialization order in msgpack map
**Why it happens:** HashMap iteration order may differ between implementations
**How to avoid:** Kotlin `LXMessage.packPayload()` already uses consistent field ordering (iterating `Map.entries`)
**Warning signs:** Empty fields work, but non-empty fields produce different hash

### Pitfall 4: Missing Source Identity for Verification
**What goes wrong:** `signatureValidated` is false even for valid signatures
**Why it happens:** `Identity.recall(sourceHash)` returns null, causing SOURCE_UNKNOWN error
**How to avoid:** Call `Identity.remember()` before attempting to unpack/verify
**Warning signs:** `unverifiedReason = SOURCE_UNKNOWN` on messages with valid signatures

### Pitfall 5: UTF-8 Encoding of Strings as Msgpack Bytes
**What goes wrong:** Title/content hash differently due to encoding
**Why it happens:** LXMF stores title/content as msgpack binary (bytes), not strings
**How to avoid:** Kotlin already encodes to UTF-8 bytes in `packPayload()` via `toByteArray(Charsets.UTF_8)`
**Warning signs:** ASCII messages work, Unicode messages fail

### Pitfall 6: Float64 Timestamp Representation
**What goes wrong:** Timestamp appears in hash differently between implementations
**Why it happens:** IEEE 754 float64 packing might differ by ULP
**How to avoid:** Msgpack float64 is standardized; if issue occurs, use exact byte comparison of packed payload
**Warning signs:** Small timestamp differences (10^-15) in unpacked values but byte mismatch in packed

## Code Examples

Verified patterns from the codebase:

### LXMF Hash Computation (Python Reference)
```python
# Source: ~/repos/LXMF/LXMF/LXMessage.py lines 369-374
hashed_part      = b""
hashed_part     += self.__destination.hash
hashed_part     += self.__source.hash
hashed_part     += msgpack.packb(self.payload)  # payload without stamp
self.hash        = RNS.Identity.full_hash(hashed_part)  # SHA-256
```

### LXMF Hash Computation (Kotlin)
```kotlin
// Source: lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMessage.kt lines 173-177
val payloadWithoutStamp = packPayload(timestamp!!, title, content, fields, null)
val hashedPart = destinationHash + sourceHash + payloadWithoutStamp
hash = Hashes.fullHash(hashedPart)  // SHA-256
```

### LXMF Signature Computation (Python Reference)
```python
# Source: ~/repos/LXMF/LXMF/LXMessage.py lines 380-383
signed_part      = b""
signed_part     += hashed_part
signed_part     += self.hash
self.signature   = self.__source.sign(signed_part)
```

### LXMF Signature Computation (Kotlin)
```kotlin
// Source: lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMessage.kt lines 179-183
val signedPart = hashedPart + hash!!
signature = sourceIdentity.sign(signedPart)
```

### Python Ed25519 Sign (Reference)
```python
# Source: ~/repos/Reticulum/RNS/Identity.py lines 780-787
def sign(self, message):
    if self.sig_prv != None:
        try:
            return self.sig_prv.sign(message)  # Ed25519 64-byte signature
        except Exception as e:
            RNS.log("The identity could not sign the message", RNS.LOG_ERROR)
            raise e
    else:
        raise KeyError("Signing failed because identity does not hold a private key")
```

### Kotlin Ed25519 Sign
```kotlin
// Source: rns-core/src/main/kotlin/network/reticulum/identity/Identity.kt lines 1190-1193
fun sign(message: ByteArray): ByteArray {
    check(hasPrivateKey) { "Signing failed because identity does not hold a private key" }
    return crypto.ed25519Sign(ed25519Private!!, message)
}
```

### Bridge LXMF Hash Command
```python
# Source: python-bridge/bridge_server.py cmd_lxmf_hash (approx lines 2755-2785)
def cmd_lxmf_hash(params):
    """Compute LXMF message hash from components."""
    destination_hash = hex_to_bytes(params['destination_hash'])
    source_hash = hex_to_bytes(params['source_hash'])
    timestamp = params['timestamp']
    title = params.get('title', b'')
    content = params.get('content', b'')
    fields = params.get('fields', {})

    payload = [timestamp, title, content, fields]
    packed_payload = umsgpack.packb(payload)
    hashed_part = destination_hash + source_hash + packed_payload
    message_hash = RNS.Identity.full_hash(hashed_part)

    return {'message_hash': bytes_to_hex(message_hash)}
```

### Existing Identity Signature Interop Test Pattern
```kotlin
// Source: rns-test/src/test/kotlin/network/reticulum/interop/identity/IdentityInteropTest.kt lines 247-262
@Test
@DisplayName("Kotlin signature validates in Python")
fun kotlinSignatureValidatesInPython() {
    val privateKey = crypto.randomBytes(RnsConstants.FULL_KEY_SIZE)
    val identity = Identity.fromPrivateKey(privateKey, crypto)

    val message = "Message to sign".toByteArray()
    val signature = identity.sign(message)

    val pyResult = python(
        "identity_verify",
        "public_key" to identity.getPublicKey(),
        "message" to message,
        "signature" to signature
    )

    pyResult.getBoolean("valid") shouldBe true
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Static test vectors | Live Python bridge | Phase 1 | Real-time validation, covers edge cases |
| Raw crypto tests only | Crypto + LXMF layer tests | Phase 2 | Catches composition bugs |
| Source identity manual recall | `Identity.remember()` API | Existing | Proper signature validation |

**Deprecated/outdated:**
- Using `Identity.getPrivateKey()` for signing: Use `Identity.sigPrv` (32-byte seed) for Ed25519

## Open Questions

Things that need validation during implementation:

1. **Bridge command for LXMF signature verification**
   - What we know: `identity_verify` exists for raw messages
   - What's unclear: Whether we need dedicated `lxmf_verify_signature` or can compose existing commands
   - Recommendation: Try composing `lxmf_unpack` + `identity_verify`; add dedicated command only if needed

2. **Empty message content as edge case**
   - What we know: LXMF allows empty title and content (both `b""`)
   - What's unclear: Whether this produces edge case in hash computation
   - Recommendation: Include empty content test per 04-CONTEXT.md requirements

3. **Fields map serialization determinism**
   - What we know: Kotlin uses LinkedHashMap for insertion-order iteration
   - What's unclear: Whether Python dict iteration order matches
   - Recommendation: Test with empty fields first; add multi-field test with sorted keys

4. **Signature verification error behavior**
   - What we know: Python returns False on bad signature (doesn't throw)
   - What's unclear: Exact error message/reason format to match
   - Recommendation: Match Python behavior: return false, set `unverifiedReason = SIGNATURE_INVALID`

## Sources

### Primary (HIGH confidence)
- `~/repos/LXMF/LXMF/LXMessage.py` lines 360-392 - Reference hash and signature computation
- `~/repos/Reticulum/RNS/Identity.py` lines 239-246, 772-805 - `full_hash()`, `sign()`, `validate()`
- `lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMessage.kt` - Kotlin hash/signature implementation
- `rns-core/src/main/kotlin/network/reticulum/identity/Identity.kt` - Kotlin signing API
- `rns-test/src/test/kotlin/network/reticulum/interop/identity/IdentityInteropTest.kt` - Verified signature interop
- `rns-test/src/test/kotlin/network/reticulum/interop/crypto/HashInteropTest.kt` - Verified SHA-256 interop
- `python-bridge/bridge_server.py` - `lxmf_hash`, `lxmf_unpack` commands

### Secondary (MEDIUM confidence)
- `.planning/phases/04-lxmf-cryptographic-interop/04-CONTEXT.md` - User decisions for test coverage
- `.planning/phases/02-lxmf-message-round-trip/02-RESEARCH.md` - Prior research patterns

### Tertiary (LOW confidence)
- Ed25519 specification for signature format (verified against reference implementations)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - existing cryptographic infrastructure verified in prior phases
- Architecture: HIGH - follows established test patterns, builds on proven interop tests
- Pitfalls: HIGH - derived from code analysis of both Python and Kotlin implementations

**Research date:** 2026-01-24
**Valid until:** 90 days (cryptographic algorithms are stable; LXMF format unlikely to change)
