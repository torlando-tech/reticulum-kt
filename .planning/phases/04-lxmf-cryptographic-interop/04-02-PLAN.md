---
phase: 04-lxmf-cryptographic-interop
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/MessageSignatureInteropTest.kt
autonomous: true

must_haves:
  truths:
    - "Kotlin-signed LXMF message signature validates in Python"
    - "Python-signed LXMF message signature validates in Kotlin"
    - "Invalid signatures are rejected by both implementations"
    - "Missing source identity causes SOURCE_UNKNOWN verification failure"
  artifacts:
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/MessageSignatureInteropTest.kt"
      provides: "LXMF message signature cross-implementation verification"
      min_lines: 120
  key_links:
    - from: "MessageSignatureInteropTest"
      to: "python identity_verify"
      via: "PythonBridge call"
      pattern: "python.*identity_verify"
    - from: "MessageSignatureInteropTest"
      to: "LXMessage.pack()"
      via: "signature computed during pack"
      pattern: "message\\.pack\\(\\)"
    - from: "MessageSignatureInteropTest"
      to: "Identity.remember()"
      via: "source identity registration"
      pattern: "Identity\\.remember"
---

<objective>
Verify LXMF message signatures generated by one implementation validate in the other.

Purpose: Signature validation is critical for message authenticity. Messages signed by Kotlin clients must verify in Python clients and vice versa. This enables secure cross-implementation messaging.

Output: `MessageSignatureInteropTest.kt` with bidirectional signature verification tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-lxmf-cryptographic-interop/04-RESEARCH.md
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/LXMFInteropTestBase.kt
@rns-test/src/test/kotlin/network/reticulum/interop/identity/IdentityInteropTest.kt
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMessage.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MessageSignatureInteropTest with Kotlin-to-Python verification</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/MessageSignatureInteropTest.kt</files>
  <action>
Create `MessageSignatureInteropTest.kt` extending `LXMFInteropTestBase`. Include:

1. **Nested class `KotlinSignsPythonVerifies`:**
   - `Kotlin signed message signature validates in Python` - Create message, pack() (which signs), extract signature and signed_part, call `identity_verify` with source public key. The signed_part for LXMF is: `hashedPart + messageHash` where `hashedPart = destHash + sourceHash + packedPayload`.

   Implementation approach:
   ```kotlin
   @Test
   fun `Kotlin signed message signature validates in Python`() {
       val message = createTestMessage(content = "Signature test message")
       val packed = message.pack()

       // Reconstruct signed_part (what was signed)
       // signedPart = hashedPart + hash
       // hashedPart = destHash + sourceHash + packedPayloadWithoutStamp
       val payloadWithoutStamp = packed.drop(32 + 64).toByteArray()  // After dest+source+sig
       val hashedPart = message.destinationHash + message.sourceHash + payloadWithoutStamp
       val signedPart = hashedPart + message.hash!!

       val pyResult = python(
           "identity_verify",
           "public_key" to testSourceIdentity.getPublicKey(),
           "message" to signedPart,
           "signature" to message.signature!!
       )

       pyResult.getBoolean("valid") shouldBe true
   }
   ```

   - `Kotlin signed message with fields validates in Python` - Same test but with FIELD_RENDERER added

2. **Nested class `InvalidSignatures`:**
   - `tampered signature fails validation in Python` - Flip one bit in signature, verify Python rejects
   - `wrong key fails validation` - Use different identity's public key, verify fails

Pattern from IdentityInteropTest:
```kotlin
val pyResult = python(
    "identity_verify",
    "public_key" to publicKey,
    "message" to message,
    "signature" to signature
)
pyResult.getBoolean("valid") shouldBe true/false
```
  </action>
  <verify>
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "network.reticulum.lxmf.interop.MessageSignatureInteropTest.KotlinSignsPythonVerifies" -i 2>&1 | tail -50
```
Tests pass.
  </verify>
  <done>
Kotlin-to-Python signature tests pass:
- Valid Kotlin signature validates in Python
- Signature with fields validates
- Tampered signature rejected
- Wrong key rejected
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Python-to-Kotlin signature verification tests</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/MessageSignatureInteropTest.kt</files>
  <action>
Add nested class for Python signing, Kotlin verification:

**Nested class `PythonSignsKotlinVerifies`:**

First, register the test source identity in Kotlin's identity cache so signature validation can find the public key:
```kotlin
// In test setup or beginning of test
Identity.remember(testSourceIdentity.hash!!, testSourceIdentity.getPublicKey())
```

- `Python signed message validates in Kotlin via Identity.validate()` - Use lxmf_pack (returns signed_part) + identity_sign to create Python-signed message, verify in Kotlin using Identity.validate()

  Implementation:
  ```kotlin
  @Test
  fun `Python signed message validates in Kotlin`() {
      // Register source identity so Kotlin can find public key for validation
      Identity.remember(testSourceIdentity.hash!!, testSourceIdentity.getPublicKey())

      // Create message components
      val content = "Python signed message"
      val title = ""
      val timestamp = System.currentTimeMillis() / 1000.0

      // Get Python to compute signed_part via lxmf_pack
      val packResult = python(
          "lxmf_pack",
          "destination_hash" to destDestination.hash.toHex(),
          "source_hash" to sourceDestination.hash.toHex(),
          "timestamp" to timestamp,
          "title" to title,
          "content" to content
      )
      val signedPart = packResult.getBytes("signed_part")

      // Sign with Python using identity_sign
      val signResult = python(
          "identity_sign",
          "private_key" to testSourceIdentity.prvBytes.toHex(),
          "message" to signedPart.toHex()
      )
      val signature = signResult.getBytes("signature")

      // Verify in Kotlin
      testSourceIdentity.validate(signature, signedPart) shouldBe true
  }
  ```

- `tampered Python signature rejected by Kotlin` - Create valid Python signature via lxmf_pack + identity_sign, flip one bit in signature, verify Kotlin's Identity.validate() returns false

  Implementation:
  ```kotlin
  @Test
  fun `tampered Python signature rejected by Kotlin`() {
      Identity.remember(testSourceIdentity.hash!!, testSourceIdentity.getPublicKey())

      val timestamp = System.currentTimeMillis() / 1000.0
      val packResult = python(
          "lxmf_pack",
          "destination_hash" to destDestination.hash.toHex(),
          "source_hash" to sourceDestination.hash.toHex(),
          "timestamp" to timestamp,
          "title" to "",
          "content" to "Test content"
      )
      val signedPart = packResult.getBytes("signed_part")

      val signResult = python(
          "identity_sign",
          "private_key" to testSourceIdentity.prvBytes.toHex(),
          "message" to signedPart.toHex()
      )
      val signature = signResult.getBytes("signature")

      // Tamper with signature (flip first bit)
      val tamperedSignature = signature.copyOf()
      tamperedSignature[0] = (tamperedSignature[0].toInt() xor 0x01).toByte()

      // Kotlin should reject tampered signature
      testSourceIdentity.validate(tamperedSignature, signedPart) shouldBe false
  }
  ```
  </action>
  <verify>
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "network.reticulum.lxmf.interop.MessageSignatureInteropTest.PythonSignsKotlinVerifies" -i 2>&1 | tail -50
```
Tests pass.
  </verify>
  <done>
Python-to-Kotlin signature tests pass:
- Identity.remember() called before validation
- Valid Python signature validates in Kotlin
- Tampered Python signature rejected by Kotlin (LXMF-07 coverage)
- Cross-implementation signature compatibility confirmed
  </done>
</task>

<task type="auto">
  <name>Task 3: Add edge case and error handling tests</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/MessageSignatureInteropTest.kt</files>
  <action>
Add nested class for edge cases:

**Nested class `EdgeCases`:**
- `empty content message signature validates` - Empty content, verify signature works
- `Unicode content message signature validates` - Emoji/CJK in content, verify signature works
- `signature length is always 64 bytes` - Verify Ed25519 signature is exactly 64 bytes

**Nested class `ErrorHandling`:**
- `missing source identity causes SOURCE_UNKNOWN` - Unpack message without calling Identity.remember() for source, verify `unverifiedReason == SOURCE_UNKNOWN`. Note: This may need LXMessage.unpackFromBytes() which does signature validation.

Implementation for SOURCE_UNKNOWN test:
```kotlin
@Test
fun `missing source identity causes SOURCE_UNKNOWN`() {
    // Create and pack message
    val message = createTestMessage(content = "Test")
    val packed = message.pack()

    // Clear identity cache (or use fresh identity not in cache)
    val freshSourceIdentity = Identity.create()
    val freshSourceDest = Destination.create(
        identity = freshSourceIdentity,
        direction = DestinationDirection.IN,
        type = DestinationType.SINGLE,
        appName = LXMFConstants.APP_NAME,
        "delivery"
    )

    // Create message with fresh source (not remembered)
    val unrememberedMessage = LXMessage.create(
        destination = destDestination,
        source = freshSourceDest,
        content = "Unremembered source"
    )
    val unrememberedPacked = unrememberedMessage.pack()

    // Attempt to unpack - should have SOURCE_UNKNOWN
    val unpacked = LXMessage.unpackFromBytes(unrememberedPacked)
    unpacked?.signatureValidated shouldBe false
    unpacked?.unverifiedReason shouldBe UnverifiedReason.SOURCE_UNKNOWN
}
```

If LXMessage.unpackFromBytes() isn't implemented yet, document this as future work and skip the SOURCE_UNKNOWN test.
  </action>
  <verify>
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "network.reticulum.lxmf.interop.MessageSignatureInteropTest" -i 2>&1 | tail -100
```
All tests pass.
  </verify>
  <done>
Edge case and error handling tests complete:
- Empty content signature validates
- Unicode content signature validates
- Signature is 64 bytes
- Error handling documented/tested as available
  </done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test -i 2>&1 | tail -50
```

Verify:
- All MessageSignatureInteropTest tests pass
- All MessageHashInteropTest tests pass
- All other LXMF interop tests still pass
</verification>

<success_criteria>
- MessageSignatureInteropTest.kt exists with 8+ test methods
- All tests pass against Python bridge
- Kotlin signatures validate in Python
- Python signatures validate in Kotlin (or documented why not testable with current bridge)
- Invalid signatures rejected
- Edge cases (empty content, Unicode) work
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-lxmf-cryptographic-interop/04-02-SUMMARY.md`
</output>
