# Phase 8.1: TCP Interface Interop - Research

**Researched:** 2026-01-24
**Domain:** TCP transport, HDLC framing, Python/Kotlin interoperability
**Confidence:** HIGH (based on reference implementation analysis)

## Summary

This research investigates the TCP interface interoperability issues between Kotlin `TCPClientInterface` and Python RNS `TCPServerInterface`. The problem manifests as connections dropping after packet transmission, causing E2E delivery tests to use flexible assertions (accepting OUTBOUND state instead of requiring DELIVERED).

After analyzing both implementations, the framing protocols (HDLC/KISS) appear correctly implemented and interop-verified. The issue is likely in:
1. Connection state management timing
2. Socket option differences
3. Threading model interactions between Python's blocking I/O and Kotlin's coroutines

**Primary recommendation:** Add diagnostic logging, create minimal TCP interop tests, and systematically compare socket options and timing between implementations.

## Standard Stack

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Python RNS TCPInterface | Reference | TCP server/client with HDLC framing | Authoritative reference implementation |
| Kotlin java.net.Socket | JDK | TCP socket implementation | Standard JVM networking |
| Kotlin coroutines | 1.7+ | Async I/O for read loops | Battery-efficient on Android |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Wireshark/tcpdump | Any | Packet capture | When framing issues suspected |
| netcat (nc) | Any | Raw TCP testing | When connection issues suspected |

## Architecture Patterns

### Python RNS TCP Protocol

The Python reference implementation uses:

1. **Server Architecture (TCPServerInterface)**
   - Uses Python `socketserver.ThreadingMixIn` for concurrent client handling
   - Each client connection spawns a `TCPClientInterface` child
   - Handler thread calls `incoming_connection()` then blocks in `read_loop()`
   - Key: `server.serve_forever()` runs in daemon thread

2. **HDLC Framing Protocol**
   - Frame format: `[FLAG][escaped_data][FLAG]` where FLAG = 0x7E
   - Escape: ESC (0x7D) followed by byte XOR 0x20
   - Escape sequences: `0x7E` -> `0x7D 0x5E`, `0x7D` -> `0x7D 0x5D`
   - Minimum frame size: > HEADER_MINSIZE (19 bytes) or silently dropped

3. **Receive Processing (read_loop)**
   ```python
   # Python approach - buffer-based find()
   frame_buffer += data_in
   frame_start = frame_buffer.find(HDLC.FLAG)
   frame_end = frame_buffer.find(HDLC.FLAG, frame_start+1)
   frame = frame_buffer[frame_start+1:frame_end]
   # Unescape via replace()
   frame = frame.replace(bytes([0x7D, 0x5E]), bytes([0x7E]))
   frame = frame.replace(bytes([0x7D, 0x5D]), bytes([0x7D]))
   if len(frame) > HEADER_MINSIZE:
       process_incoming(frame)
   frame_buffer = frame_buffer[frame_end:]  # Keep tail
   ```

4. **Connection Detection**
   - `socket.recv(4096)` returns empty bytes `b""` when connection closed
   - Empty read triggers teardown or reconnect based on `initiator` flag

### Kotlin TCP Protocol

The Kotlin implementation uses:

1. **Client Architecture (TCPClientInterface)**
   - Uses Kotlin coroutines for async I/O (`Dispatchers.IO`)
   - Read loop runs in coroutine scope
   - Sends empty HDLC frame (`[0x7E][0x7E]`) on connect to "activate" connection

2. **HDLC Framing (HDLC.kt)**
   - Byte-by-byte escape/unescape (functionally equivalent to Python)
   - Streaming deframer with callback pattern
   - Same minimum frame size check (> HEADER_MIN_SIZE)

3. **Receive Processing (Deframer)**
   ```kotlin
   // Kotlin approach - byte-by-byte state machine
   for (byte in data) {
       if (byte == FLAG) {
           if (inFrame && buffer.size() > 0) {
               val unescaped = unescape(buffer.toByteArray())
               if (unescaped.size > HEADER_MIN_SIZE) {
                   onFrame(unescaped)
               }
           }
           inFrame = true
           buffer.reset()
       } else if (inFrame) {
           buffer.write(byte)
       }
   }
   ```

### Key Protocol Differences

| Aspect | Python | Kotlin | Impact |
|--------|--------|--------|--------|
| Escape order | ESC first, then FLAG | Independent per-byte | Equivalent |
| Deframer | Buffer + find() | State machine | Equivalent |
| Threading | OS threads | Coroutines | May differ in timing |
| Connection detect | Empty recv() | -1 from read() | Equivalent |
| Keepalive | TCP options | Disabled by default | **Potential issue** |

## Don't Hand-Roll

Problems with existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| HDLC framing | Custom protocol | Existing HDLC classes | Already correctly implemented and tested |
| Packet capture | Manual byte logging | Wireshark with TCP stream filter | Professional tool with proper dissectors |
| Socket testing | Complex test harness | netcat for raw socket tests | Eliminates application layer complexity |

**Key insight:** The framing layer is correct. Focus on connection lifecycle, not packet encoding.

## Common Pitfalls

### Pitfall 1: Empty Frame on Connect

**What goes wrong:** Kotlin sends `[0x7E][0x7E]` (empty HDLC frame) on connect as "keepalive activation"
**Why it happens:** Attempt to ensure Python's blocking `recv()` returns
**How to avoid:** Empty frame is correctly dropped by Python (size 0 <= HEADER_MINSIZE). Not a problem.
**Warning signs:** None - this is working correctly

### Pitfall 2: TCP Socket Options Mismatch

**What goes wrong:** Connection may time out or close unexpectedly
**Why it happens:** Python sets extensive TCP options, Kotlin doesn't
**How to avoid:** Match Python's socket configuration
**Warning signs:** Connection drops after idle period

Python TCP options (Linux):
```python
# TCP_USER_TIMEOUT: 24 seconds
socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_USER_TIMEOUT, 24000)
# SO_KEEPALIVE enabled
socket.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
# TCP_KEEPIDLE: 5 seconds
socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 5)
# TCP_KEEPINTVL: 2 seconds
socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, 2)
# TCP_KEEPCNT: 12 probes
socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, 12)
# TCP_NODELAY enabled
socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
```

Kotlin current settings:
```kotlin
sock.tcpNoDelay = true
sock.keepAlive = false  // Disabled for battery!
sock.soTimeout = 0      // No read timeout
```

### Pitfall 3: Threading Model Race Condition

**What goes wrong:** Python handler thread may not be fully set up when Kotlin sends first packet
**Why it happens:** Python's `incoming_connection()` is called synchronously in accept handler
**How to avoid:** Ensure connection is fully established before sending
**Warning signs:** First packet after connect is lost

Python server accept flow:
1. `accept()` returns socket
2. `incoming_connection()` called (spawns TCPClientInterface)
3. `read_loop()` called (starts blocking recv)

Kotlin client connect flow:
1. `sock.connect()` returns
2. Immediately sends empty HDLC frame
3. Starts read loop coroutine

**Race condition:** If Kotlin sends before Python's `read_loop()` calls first `recv()`, the packet may be buffered but not lost. However, if there's any issue with the spawned interface setup, packets could be dropped.

### Pitfall 4: Frame Buffer Boundary Issues

**What goes wrong:** Frames split across TCP segments may be mishandled
**Why it happens:** TCP doesn't preserve message boundaries
**How to avoid:** Both implementations handle this correctly with buffering
**Warning signs:** Intermittent frame corruption

### Pitfall 5: Coroutine Cancellation Timing

**What goes wrong:** Read job cancelled before write completes
**Why it happens:** `detach()` cancels coroutines immediately
**How to avoid:** Ensure write completion before cancellation
**Warning signs:** "Broken pipe" or write errors during shutdown

## Code Examples

### Python Server Spawn Point (Reference)

```python
# TCPServerInterface.incoming_connection()
# Source: ~/repos/Reticulum/RNS/Interfaces/TCPInterface.py:576-619

def incoming_connection(self, handler):
    RNS.log("Accepting incoming TCP connection", RNS.LOG_VERBOSE)
    spawned_configuration = {"name": "Client on "+self.name, ...}
    spawned_interface = TCPClientInterface(self.owner, spawned_configuration,
                                           connected_socket=handler.request)
    spawned_interface.OUT = self.OUT
    spawned_interface.IN = self.IN
    # ... lots of setup ...
    spawned_interface.online = True
    RNS.Transport.interfaces.append(spawned_interface)
    # Handler thread now blocks here:
    spawned_interface.read_loop()  # <-- This is where recv() starts
```

### Python Receive Detection (Reference)

```python
# TCPClientInterface.read_loop()
# Source: ~/repos/Reticulum/RNS/Interfaces/TCPInterface.py:337-410

while True:
    if self.socket: data_in = self.socket.recv(4096)
    else: data_in = b""
    if len(data_in) > 0:
        # Process frames...
    else:
        # Empty read = connection closed
        self.online = False
        if self.initiator and not self.detached:
            self.reconnect()
        else:
            self.teardown()
        break
```

### Kotlin Socket Options to Match Python

```kotlin
// To match Python behavior, add these socket options:
// Note: Some options require reflection or native code on JVM

sock.tcpNoDelay = true              // Matches Python
sock.keepAlive = true               // Match Python (override mobile battery setting for interop)
sock.soTimeout = 0                  // Match Python (blocking read)

// These require JNI or socket options not exposed by java.net.Socket:
// TCP_USER_TIMEOUT, TCP_KEEPIDLE, TCP_KEEPINTVL, TCP_KEEPCNT
// On Linux, can use java.nio.channels.SocketChannel with setOption()
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Direct socket options | JVM Socket wrapper | Always | Some TCP options not exposed |
| Blocking I/O | Coroutines | Kotlin adoption | Different threading model |

**Deprecated/outdated:**
- None relevant - both implementations use standard TCP sockets

## Open Questions

### Question 1: Actual Failure Mode

**What we know:**
- Tests pass with flexible assertions (accept OUTBOUND)
- Verification notes "TCP interface limitations"
- Kotlin-to-Kotlin TCP works fine

**What's unclear:**
- Is the connection actually dropping?
- Are packets being lost or just not delivered in time?
- Is it a Kotlin send issue or Python receive issue?

**Recommendation:** Add debug logging at these points:
1. Kotlin: After `sock.getOutputStream().write()` and `flush()`
2. Kotlin: On every deframed packet received
3. Python: On every `process_incoming()` call
4. Both: On connection state changes (online/offline)

### Question 2: TCP Keepalive Impact

**What we know:**
- Python enables TCP keepalive with aggressive settings
- Kotlin disables keepalive for battery efficiency

**What's unclear:**
- Does Python server expect keepalive probes?
- Could missing probes cause server-side teardown?

**Recommendation:** Create test with keepalive enabled on Kotlin side

### Question 3: Test Infrastructure vs Actual Bug

**What we know:**
- Tests use Python bridge server
- Bridge server is complex (3500+ lines)
- Issue might be in bridge, not TCP interface

**What's unclear:**
- Is this a real TCP issue or bridge server issue?
- Would a simpler Python TCP server work correctly?

**Recommendation:** Create minimal Python TCP test server (not using bridge)

## Investigation Plan for Phase 8.1

### Step 1: Diagnostic Logging

Add verbose logging to both implementations:
- Socket state (connected, input/output shutdown)
- Frame boundaries (start/end markers seen)
- Packet counts (sent vs received)
- Timing information

### Step 2: Minimal TCP Interop Test

Create standalone test bypassing bridge:
1. Simple Python TCP server (just echo)
2. Kotlin client sends HDLC frames
3. Verify bidirectional communication

### Step 3: Socket Options Alignment

Match Kotlin socket options to Python:
- Enable keepalive (with option to disable for mobile)
- Consider TCP_NODELAY timing

### Step 4: Timing Investigation

Test with delays at key points:
- After connect, before first send
- Between sends
- Check for packet batching issues

### Step 5: Wire-Level Capture

If above doesn't reveal issue:
- Capture with tcpdump/Wireshark
- Compare actual bytes on wire
- Look for connection resets

## Sources

### Primary (HIGH confidence)
- `~/repos/Reticulum/RNS/Interfaces/TCPInterface.py` - Python reference implementation
- `./rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt` - Kotlin implementation
- `./rns-interfaces/src/main/kotlin/network/reticulum/interfaces/framing/HDLC.kt` - Kotlin HDLC implementation

### Secondary (MEDIUM confidence)
- Existing Kotlin-to-Kotlin TCP tests (pass successfully)
- Existing framing interop tests (verified correct)

### Tertiary (LOW confidence)
- Stack traces and test output from verification phase (indirect evidence)

## Metadata

**Confidence breakdown:**
- Framing protocol: HIGH - Verified against reference, tested
- Connection issue root cause: MEDIUM - Multiple hypotheses, needs investigation
- Socket options impact: MEDIUM - Logical but untested

**Research date:** 2026-01-24
**Valid until:** 2026-02-24 (30 days - stable domain)
