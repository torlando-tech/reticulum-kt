---
phase: 08.1-tcp-interface-interop
plan: 02
type: execute
wave: 2
depends_on: ["08.1-01"]
files_modified:
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt
autonomous: true

must_haves:
  truths:
    - "Kotlin TCP socket options match Python RNS TCPClientInterface defaults"
    - "TCP keepalive enabled by default for interop (can disable via parameter)"
    - "Connection timing allows Python handler thread to be ready before first packet"
  artifacts:
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt"
      provides: "Python-compatible socket options and timing"
      contains: "keepAlive.*true"
  key_links:
    - from: "TCPClientInterface.connect()"
      to: "Python TCPServerInterface.incoming_connection()"
      via: "Socket option compatibility"
      pattern: "keepAlive|tcpNoDelay|soTimeout"
---

<objective>
Apply targeted fixes to TCPClientInterface based on diagnostic findings from Plan 01.

Purpose: Address the socket option mismatches and timing issues identified in research. The goal is to make Kotlin TCPClientInterface behave like Python TCPClientInterface at the socket level.

Output:
- TCPClientInterface with Python-compatible socket options
- Proper connection timing to avoid race conditions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-tcp-interface-interop/08.1-RESEARCH.md

# IMPORTANT: Read Plan 01 SUMMARY for diagnostic findings
@.planning/phases/08.1-tcp-interface-interop/08.1-01-SUMMARY.md

# Reference implementations
@~/repos/Reticulum/RNS/Interfaces/TCPInterface.py

# Current Kotlin implementation
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Align socket options with Python reference</name>
  <files>rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt</files>
  <action>
Update TCPClientInterface to match Python RNS socket options by default.

Changes to make:
1. **Change keepAlive default to true** (was false for battery, but interop requires it)
   - Keep the constructor parameter so callers can disable if needed for mobile
   - Document: "Enable TCP keep-alive. Default true for Python RNS compatibility."

2. **Add connection establishment delay** - After connect(), before sending empty HDLC frame:
   - Increase delay from 50ms to 100ms
   - This gives Python's ThreadingMixIn time to spawn handler and enter read_loop()

3. **Add socket linger option** (optional based on Plan 01 findings):
   - If diagnostics show connection resets, add: `sock.setSoLinger(true, 5)`
   - This ensures clean shutdown with 5 second linger

4. **Consider TCP_NODELAY timing** (only if diagnostics indicate):
   - Python sets TCP_NODELAY after connect
   - Ensure Kotlin does the same (currently it does)

Do NOT add options that require JNI (TCP_USER_TIMEOUT, TCP_KEEPIDLE, etc.) - these are Linux-specific and the basic options should be sufficient.

Note: Adapt this task based on actual findings from Plan 01 SUMMARY. If diagnostics reveal a different root cause, adjust accordingly.
  </action>
  <verify>
Build compiles: `./gradlew :rns-interfaces:build`
Kotlin-to-Kotlin TCP tests pass: `./gradlew :rns-test:test --tests "TcpIntegrationTest"`
Python interop test shows improved behavior: `./gradlew :rns-test:test --tests "TcpPythonInteropTest" -Dreticulum.tcp.debug=true`
  </verify>
  <done>
TCPClientInterface socket options match Python defaults, with keepAlive=true and appropriate connection timing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add write synchronization safeguards</name>
  <files>rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt</files>
  <action>
Add safeguards to processOutgoing() to ensure writes complete reliably.

Changes to make:
1. **Verify connection before write**:
   - Check socket.isConnected && !socket.isClosed && !socket.isOutputShutdown
   - If any check fails, log warning and throw (don't silently fail)

2. **Add write timeout handling** (if Java NIO available):
   - Wrap write in try-catch with specific handling for SocketTimeoutException
   - Log timeout with diagnostic info

3. **Ensure atomic flush**:
   - The current code does write() then flush() separately
   - Both should complete before returning
   - Consider: If flush() throws, the connection should teardown

4. **Handle partial writes** (if using NIO channels):
   - Standard OutputStream.write() blocks until all bytes written
   - If switching to NIO SocketChannel, handle partial writes in loop

These changes ensure that if Kotlin thinks a packet was sent, it actually was.
  </action>
  <verify>
Build compiles: `./gradlew :rns-interfaces:build`
Kotlin-to-Kotlin TCP tests pass: `./gradlew :rns-test:test --tests "TcpIntegrationTest"`
No regression in existing tests.
  </verify>
  <done>
processOutgoing() has proper connection verification and write completion guarantees.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Run diagnostic test again: `./gradlew :rns-test:test --tests "TcpPythonInteropTest" -Dreticulum.tcp.debug=true 2>&1 | tee tcp_debug_after_fixes.log`
2. Compare with pre-fix log from Plan 01
3. Verify connection holds and bidirectional packet exchange works
</verification>

<success_criteria>
- TCPClientInterface keepAlive defaults to true
- Connection timing allows Python handler to be ready
- Write operations have proper verification and error handling
- TcpPythonInteropTest passes all 4 tests
- Kotlin-to-Kotlin TCP tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-tcp-interface-interop/08.1-02-SUMMARY.md`
</output>
