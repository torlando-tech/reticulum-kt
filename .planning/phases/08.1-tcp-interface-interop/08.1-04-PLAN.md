---
phase: 08.1-tcp-interface-interop
plan: 04
type: execute
wave: 1
depends_on: ["08.1-03"]
files_modified:
  - lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PropagatedDeliveryTest.kt
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Propagated delivery messages reach SENT or DELIVERED state within timeout"
    - "PropagatedDeliveryTest uses strict assertions requiring message delivery confirmation"
    - "Link established callback re-triggers outbound processing for pending messages"
  artifacts:
    - path: "lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt"
      provides: "Fixed establishPropagationLink callback for message submission"
      contains: "processOutbound"
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PropagatedDeliveryTest.kt"
      provides: "Strict assertions for propagated delivery"
      contains: "MessageState.SENT"
  key_links:
    - from: "establishPropagationLink callback"
      to: "processOutbound()"
      via: "Link established callback"
      pattern: "establishedCallback.*processOutbound"
---

<objective>
Fix LXMF propagation protocol link establishment to enable strict test assertions.

Purpose: Close the verification gap where PropagatedDeliveryTest uses flexible assertions instead of requiring DELIVERED/SENT state. The root cause is that `establishPropagationLink` callback doesn't re-trigger outbound message processing like Python's implementation does.

Output: LXMRouter with correct propagation link callback, PropagatedDeliveryTest with strict assertions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-tcp-interface-interop/08.1-VERIFICATION.md
@.planning/phases/08.1-tcp-interface-interop/08.1-03-SUMMARY.md

# Reference implementation
@~/repos/LXMF/LXMF/LXMRouter.py (lines 2700-2715)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix establishPropagationLink callback for message submission</name>
  <files>lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt</files>
  <action>
    The current `establishPropagationLink` function has a callback that only handles message retrieval (calls `requestMessageList`). For propagated message SUBMISSION, the callback needs to re-trigger outbound processing.

    **Root cause:** Python LXMRouter line 2709 uses `established_callback=self.process_outbound` when establishing link for message delivery, so pending messages get processed when link becomes active.

    **Fix approach - two separate link establishment paths:**

    1. Add a parameter to `establishPropagationLink` to indicate purpose (retrieval vs submission):
       ```kotlin
       private fun establishPropagationLink(node: PropagationNode, forRetrieval: Boolean = true)
       ```

    2. In the `establishedCallback`:
       - If `forRetrieval`: call `requestMessageList` (existing behavior)
       - If `!forRetrieval` (submission): call `processOutbound()` via coroutine scope

    3. Update `processPropagatedDelivery` to call `establishPropagationLink(node, forRetrieval = false)`

    4. Keep `requestMessagesFromPropagationNode` calling `establishPropagationLink(node, forRetrieval = true)` (default)

    **Alternative simpler approach:**
    Always re-trigger processOutbound in the established callback, regardless of purpose. This matches Python behavior where any link establishment triggers reprocessing.

    Choose the simpler approach - add processOutbound() call to the established callback. The callback already sets `outboundPropagationLink = establishedLink`, so subsequent processOutbound() will find the active link and send pending messages.

    **Implementation:**
    In `establishPropagationLink`, modify the `establishedCallback` to:
    ```kotlin
    establishedCallback = { establishedLink ->
        outboundPropagationLink = establishedLink
        propagationTransferState = PropagationTransferState.LINK_ESTABLISHED

        // Identify ourselves on the link
        identifyOnLink(establishedLink)

        // Re-trigger outbound processing for any pending propagated messages
        processingScope?.launch {
            processOutbound()
        }

        // Request message list if this was a retrieval request
        requestMessageList(establishedLink)
    }
    ```

    Note: processOutbound() is a suspend function, so it needs to be launched in a coroutine.
  </action>
  <verify>
    1. Build compiles: `./gradlew :lxmf-core:compileKotlin`
    2. Review the callback code to ensure processOutbound is called
    3. Check that processingScope is available in the callback context
  </verify>
  <done>
    establishPropagationLink callback includes processOutbound() call to handle pending messages when link becomes active
  </done>
</task>

<task type="auto">
  <name>Task 2: Update PropagatedDeliveryTest with strict assertions</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PropagatedDeliveryTest.kt</files>
  <action>
    With Task 1 fix in place, update the submission test to require strict assertions.

    **In `Kotlin can submit message to Python propagation node` test (around line 142-147):**

    Replace the flexible assertion:
    ```kotlin
    val validStates = listOf(MessageState.OUTBOUND, MessageState.SENDING, MessageState.SENT, MessageState.DELIVERED)
    validStates shouldContain message.state
    ```

    With strict assertion requiring delivery confirmation:
    ```kotlin
    // TCP transport layer verified working (Plans 01-02)
    // LXMF propagation link now triggers processOutbound on establishment (Plan 04)
    // Message should reach SENT (accepted by node) or DELIVERED (fully confirmed)
    val finalStates = listOf(MessageState.SENT, MessageState.DELIVERED)
    if (message.state !in finalStates) {
        println("[KT] ERROR: Expected SENT or DELIVERED but got ${message.state}")
        println("[KT] Message hash: ${message.hash?.toHex()}")
    }
    finalStates shouldContain message.state
    ```

    Also update the wait loop condition to match - it already waits for SENT or DELIVERED.

    **Update the logging comment (around line 150-153):**
    Remove or update the note about "LXMF propagation protocol issues beyond TCP layer" since we're fixing that issue.

    **Keep retrieval test assertions as-is** - retrieval is a different flow and may have separate issues. Focus on submission for this gap closure.
  </action>
  <verify>
    1. Run the test: `./gradlew :lxmf-core:test --tests "*PropagatedDeliveryTest*" --info`
    2. If test passes, assertions are now strict
    3. If test fails, check diagnostic output to understand what's happening
  </verify>
  <done>
    PropagatedDeliveryTest submission test uses strict assertions requiring SENT or DELIVERED state
  </done>
</task>

</tasks>

<verification>
1. Build compiles without errors
2. PropagatedDeliveryTest `Kotlin can submit message to Python propagation node` passes with strict assertions
3. All other PropagatedDeliveryTest tests still pass
4. All LiveDeliveryTest tests still pass (no regression)
5. All TcpPythonInteropTest tests still pass (no regression)
</verification>

<success_criteria>
- establishPropagationLink callback includes processOutbound() to handle pending messages
- PropagatedDeliveryTest submission test requires SENT or DELIVERED (not OUTBOUND)
- All delivery interop tests pass
- Gap from 08.1-VERIFICATION.md is closed
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-tcp-interface-interop/08.1-04-SUMMARY.md`
</output>
