---
phase: 08.1-tcp-interface-interop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt
  - rns-test/src/test/kotlin/network/reticulum/integration/TcpPythonInteropTest.kt
  - rns-test/src/test/resources/python_tcp_test_server.py
autonomous: true

must_haves:
  truths:
    - "TCP interop failures can be diagnosed from debug output showing socket state, frame boundaries, and packet counts"
    - "Minimal TCP interop test connects Kotlin client to Python TCPServerInterface directly"
    - "Test bypasses Python bridge complexity to isolate TCP transport layer"
  artifacts:
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt"
      provides: "Debug logging for socket state and frame I/O"
      contains: "TCPClientInterface"
    - path: "rns-test/src/test/kotlin/network/reticulum/integration/TcpPythonInteropTest.kt"
      provides: "Minimal Python TCP server interop test"
      min_lines: 100
    - path: "rns-test/src/test/resources/python_tcp_test_server.py"
      provides: "Python test server with stdin/stdout protocol for TCP interop testing"
      contains: "TCPServerInterface"
  key_links:
    - from: "TcpPythonInteropTest"
      to: "TCPClientInterface"
      via: "Direct socket connection without LXMF layer"
      pattern: "TCPClientInterface.*targetHost.*targetPort"
---

<objective>
Add diagnostic logging to TCP interfaces and create minimal isolated test for Kotlin-Python TCP interop.

Purpose: Establish diagnostic capability to identify the exact failure mode (connection drops vs packet loss vs timing) before attempting fixes. The research identified multiple hypotheses - we need data to determine which is correct.

Output:
- TCPClientInterface with verbose debug logging at socket/frame boundaries
- Standalone test that connects directly to Python RNS TCPServerInterface (bypasses bridge)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08.1-tcp-interface-interop/08.1-RESEARCH.md

# Reference implementations
@~/repos/Reticulum/RNS/Interfaces/TCPInterface.py

# Current Kotlin implementation
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt

# Existing Kotlin-to-Kotlin TCP tests (working)
@rns-test/src/test/kotlin/network/reticulum/integration/TcpIntegrationTest.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add diagnostic logging to TCPClientInterface</name>
  <files>rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt</files>
  <action>
Add verbose debug logging at key points in TCPClientInterface. Use a DEBUG flag (default false, or controlled via system property) to avoid polluting normal output.

Add logging at these points:
1. **After connect()** - Log socket state: connected, localAddress, remoteAddress, all socket options (tcpNoDelay, keepAlive, soTimeout)
2. **After write()** - Log bytes written, flush status, socket output stream state
3. **On every deframed packet received** - Log packet size, first 16 bytes (hex), frame counter
4. **On connection state changes** - Log online/offline transitions with reason
5. **On any IOException** - Log full exception with socket state at time of error

Implementation notes:
- Add `private val DEBUG = System.getProperty("reticulum.tcp.debug", "false").toBoolean()`
- Use existing log() method but guard with `if (DEBUG)` for verbose output
- Log frame boundaries in hdlcDeframer callback
- Add frameCount counter to track packets sent/received
- Log socket.isClosed, socket.isConnected, socket.isInputShutdown, socket.isOutputShutdown on errors

Do NOT change any functional behavior - diagnostic only.
  </action>
  <verify>
Build compiles: `./gradlew :rns-interfaces:build`
Existing Kotlin-to-Kotlin TCP tests still pass: `./gradlew :rns-test:test --tests "TcpIntegrationTest"`
  </verify>
  <done>
TCPClientInterface has debug logging at all 5 specified points, controlled by system property, without changing functional behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create minimal Python TCP interop test</name>
  <files>
    rns-test/src/test/kotlin/network/reticulum/integration/TcpPythonInteropTest.kt
    rns-test/src/test/resources/python_tcp_test_server.py
  </files>
  <action>
Create a standalone test that connects Kotlin TCPClientInterface directly to Python RNS TCPServerInterface, bypassing the complex Python bridge infrastructure.

**Step 1: Create Python test server script**

Create `rns-test/src/test/resources/python_tcp_test_server.py` with:
- RNS TCPServerInterface setup on port passed as command-line argument
- Stdin command protocol:
  - "SEND <hex>" - write HDLC-framed hex bytes to connected client
  - "QUIT" - clean shutdown
- Stdout protocol:
  - "READY" - printed when server is listening
  - "RECEIVED: <hex>" - printed for each deframed packet received (hex-encoded)
  - "SENT: <hex>" - confirmation after sending
- Log all received frames to stdout as hex for verification

**Step 2: Create Kotlin test class**

Create `rns-test/src/test/kotlin/network/reticulum/integration/TcpPythonInteropTest.kt` with:

Test structure:
1. **Setup**: Start Python script with ProcessBuilder on a random high port
2. **Test 1 - Connection holds**: Connect, wait 5 seconds, verify still connected
3. **Test 2 - K->P packet**: Send HDLC frame from Kotlin, verify Python prints "RECEIVED: <hex>"
4. **Test 3 - P->K packet**: Send "SEND <hex>" to Python stdin, verify Kotlin received deframed packet
5. **Test 4 - Bidirectional**: Exchange 10 frames each way, verify counts match
6. **Teardown**: Send "QUIT" to Python stdin, stop subprocess

Implementation notes:
- Parse Python stdout for "READY" before connecting
- Parse Python stdout for "RECEIVED: <hex>" lines to verify K->P delivery
- Enable debug logging: `System.setProperty("reticulum.tcp.debug", "true")`
- Use @Timeout(30) on all tests
- Use @TestInstance(PER_CLASS) for shared Python process

This test isolates TCP transport from LXMF, Python bridge, and complex test infrastructure.
  </action>
  <verify>
Test class compiles: `./gradlew :rns-test:compileTestKotlin`
When run with Python available, tests exercise TCP transport layer directly.
  </verify>
  <done>
TcpPythonInteropTest exists with 4 tests that directly test Kotlin TCPClientInterface against Python RNS TCPServerInterface without bridge infrastructure.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Run diagnostic test: `./gradlew :rns-test:test --tests "TcpPythonInteropTest" -Dreticulum.tcp.debug=true 2>&1 | tee tcp_debug.log`
2. Examine tcp_debug.log for:
   - Connection establishment sequence
   - Frame send/receive counts
   - Any socket state anomalies
   - Timing of connection drops (if they occur)
</verification>

<success_criteria>
- TCPClientInterface has comprehensive debug logging at socket/frame boundaries
- TcpPythonInteropTest provides isolated TCP interop testing
- Debug output reveals actual failure mode (connection vs packets vs timing)
- All existing Kotlin-to-Kotlin TCP tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-tcp-interface-interop/08.1-01-SUMMARY.md`
</output>
