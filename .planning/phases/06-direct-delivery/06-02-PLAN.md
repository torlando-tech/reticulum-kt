---
phase: 06-direct-delivery
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/KotlinToPythonDirectTest.kt
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PythonToKotlinDirectTest.kt
autonomous: true

must_haves:
  truths:
    - "Kotlin LXMRouter can send message to Python destination via DIRECT delivery"
    - "Python LXMF router can send message to Kotlin destination via DIRECT delivery"
    - "Message content, title, and fields preserved end-to-end in both directions"
    - "Delivery confirmation callback fires on sender side"
  artifacts:
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/KotlinToPythonDirectTest.kt"
      provides: "Kotlin-to-Python direct delivery tests"
      min_lines: 60
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PythonToKotlinDirectTest.kt"
      provides: "Python-to-Kotlin direct delivery tests"
      min_lines: 60
  key_links:
    - from: "KotlinToPythonDirectTest.kt"
      to: "LXMRouter.handleOutbound"
      via: "message send + waitForPythonMessages"
      pattern: "router\\.handleOutbound|waitForPythonMessages"
    - from: "PythonToKotlinDirectTest.kt"
      to: "bridge lxmf_send_direct"
      via: "python command + callback verification"
      pattern: "lxmf_send_direct|deliveryCallback"
---

<objective>
Verify bidirectional LXMF direct delivery between Kotlin and Python implementations.

Purpose: Prove that LXMF messages can be successfully delivered over established Reticulum Links in both directions, with content integrity and delivery confirmations working correctly. This validates requirements E2E-01 and E2E-02.

Output: Comprehensive test suites for Kotlin-to-Python and Python-to-Kotlin direct delivery.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-direct-delivery/06-CONTEXT.md
@.planning/phases/06-direct-delivery/06-RESEARCH.md

# Prior plan summary
@.planning/phases/06-direct-delivery/06-01-SUMMARY.md

# Test infrastructure created in 06-01
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/DirectDeliveryTestBase.kt

# Implementation references
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMessage.kt

# Python reference
Reference: ~/repos/LXMF/LXMF/LXMRouter.py (lxmf_delivery, direct_delivery)
Reference: ~/repos/LXMF/LXMF/LXMessage.py (send, pack)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Kotlin-to-Python direct delivery tests</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/KotlinToPythonDirectTest.kt</files>
  <action>
Create comprehensive tests for Kotlin sending to Python via DIRECT delivery:

```kotlin
package network.reticulum.lxmf.interop

import io.kotest.matchers.collections.shouldHaveSize
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withTimeout
import network.reticulum.destination.Destination
import network.reticulum.common.DestinationDirection
import network.reticulum.common.DestinationType
import network.reticulum.identity.Identity
import network.reticulum.interop.getBytes
import network.reticulum.lxmf.DeliveryMethod
import network.reticulum.lxmf.LXMessage
import network.reticulum.lxmf.MessageState
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import kotlin.time.Duration.Companion.seconds

/**
 * Tests for Kotlin sending LXMF messages to Python via DIRECT delivery.
 *
 * Validates requirement E2E-01: DIRECT delivery Kotlin->Python over established Link.
 */
class KotlinToPythonDirectTest : DirectDeliveryTestBase() {

    @BeforeEach
    fun clearMessages() {
        clearPythonMessages()
    }

    @Test
    fun `send simple message to Python via DIRECT delivery`() = runBlocking {
        // Create destination for Python's LXMF router
        val pythonIdentity = Identity.recall(pythonDestHash!!)
            ?: throw IllegalStateException("Cannot recall Python identity from dest hash")

        val pythonDest = Destination.create(
            identity = pythonIdentity,
            direction = DestinationDirection.OUT,
            type = DestinationType.SINGLE,
            appName = "lxmf",
            "delivery"
        )

        // Create message
        val message = LXMessage(
            destination = pythonDest,
            source = kotlinIdentity,
            content = "Hello from Kotlin!".toByteArray(),
            title = "Test Message".toByteArray()
        )
        message.desiredMethod = DeliveryMethod.DIRECT

        // Track delivery
        val deliveredLatch = CountDownLatch(1)
        var deliveryState: MessageState? = null
        message.deliveryCallback = { msg ->
            deliveryState = msg.state
            deliveredLatch.countDown()
        }

        // Send via router
        kotlinRouter.handleOutbound(message)

        // Wait for Python to receive
        waitForPythonMessages(1, timeoutMs = 15000) shouldBe true

        // Verify message arrived in Python
        val received = getPythonMessages()
        received shouldHaveSize 1
        received[0].content shouldBe "Hello from Kotlin!"
        received[0].title shouldBe "Test Message"

        // Verify delivery confirmation (with timeout)
        deliveredLatch.await(10, TimeUnit.SECONDS) shouldBe true
        deliveryState shouldBe MessageState.DELIVERED
    }

    @Test
    fun `message source hash matches Kotlin identity`() = runBlocking {
        val pythonIdentity = Identity.recall(pythonDestHash!!)!!
        val pythonDest = Destination.create(
            identity = pythonIdentity,
            direction = DestinationDirection.OUT,
            type = DestinationType.SINGLE,
            appName = "lxmf",
            "delivery"
        )

        val message = LXMessage(
            destination = pythonDest,
            source = kotlinIdentity,
            content = "Source hash test".toByteArray()
        )
        message.desiredMethod = DeliveryMethod.DIRECT

        kotlinRouter.handleOutbound(message)

        waitForPythonMessages(1, timeoutMs = 15000) shouldBe true

        val received = getPythonMessages()[0]
        // Source hash should match Kotlin's LXMF delivery destination hash
        received.sourceHash.contentEquals(kotlinDestination.hash) shouldBe true
    }

    @Test
    fun `message with all fields preserved`() = runBlocking {
        val pythonIdentity = Identity.recall(pythonDestHash!!)!!
        val pythonDest = Destination.create(
            identity = pythonIdentity,
            direction = DestinationDirection.OUT,
            type = DestinationType.SINGLE,
            appName = "lxmf",
            "delivery"
        )

        val message = LXMessage(
            destination = pythonDest,
            source = kotlinIdentity,
            content = "Field preservation test".toByteArray(),
            title = "Important Title".toByteArray()
        )
        message.desiredMethod = DeliveryMethod.DIRECT

        // Add custom fields
        message.fields[0x01] = "Custom field value".toByteArray()  // FIELD_EMBEDDED_LXMS
        message.fields[0x02] = byteArrayOf(1, 2, 3, 4)  // FIELD_TELEMETRY

        kotlinRouter.handleOutbound(message)

        waitForPythonMessages(1, timeoutMs = 15000) shouldBe true

        val received = getPythonMessages()[0]
        received.content shouldBe "Field preservation test"
        received.title shouldBe "Important Title"
        // Note: Field verification may need adjustment based on Python bridge response format
    }

    @Test
    fun `multiple messages delivered in order`() = runBlocking {
        val pythonIdentity = Identity.recall(pythonDestHash!!)!!
        val pythonDest = Destination.create(
            identity = pythonIdentity,
            direction = DestinationDirection.OUT,
            type = DestinationType.SINGLE,
            appName = "lxmf",
            "delivery"
        )

        // Send 3 messages
        for (i in 1..3) {
            val message = LXMessage(
                destination = pythonDest,
                source = kotlinIdentity,
                content = "Message $i".toByteArray()
            )
            message.desiredMethod = DeliveryMethod.DIRECT
            kotlinRouter.handleOutbound(message)
            delay(100) // Small delay between sends
        }

        waitForPythonMessages(3, timeoutMs = 20000) shouldBe true

        val received = getPythonMessages()
        received shouldHaveSize 3
        received[0].content shouldBe "Message 1"
        received[1].content shouldBe "Message 2"
        received[2].content shouldBe "Message 3"
    }
}
```

Key test scenarios:
1. Basic message delivery with delivery confirmation
2. Source hash correctly identifies Kotlin sender
3. All message fields (content, title, custom) preserved
4. Multiple messages maintain ordering
  </action>
  <verify>
Run Kotlin-to-Python tests:
```bash
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*KotlinToPythonDirectTest*" --no-daemon 2>&1 | tail -50
```
Tests should pass (or identify specific implementation gaps to address).
  </verify>
  <done>KotlinToPythonDirectTest passes: simple message delivery works, source hash matches, fields preserved, multiple messages delivered in order.</done>
</task>

<task type="auto">
  <name>Task 2: Create Python-to-Kotlin direct delivery tests</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PythonToKotlinDirectTest.kt</files>
  <action>
Create comprehensive tests for Python sending to Kotlin via DIRECT delivery:

```kotlin
package network.reticulum.lxmf.interop

import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import kotlinx.coroutines.runBlocking
import network.reticulum.interop.getString
import network.reticulum.interop.toHex
import network.reticulum.lxmf.LXMessage
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.util.concurrent.CopyOnWriteArrayList
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit

/**
 * Tests for Python sending LXMF messages to Kotlin via DIRECT delivery.
 *
 * Validates requirement E2E-02: DIRECT delivery Python->Kotlin over established Link.
 */
class PythonToKotlinDirectTest : DirectDeliveryTestBase() {

    private val receivedMessages = CopyOnWriteArrayList<LXMessage>()
    private lateinit var messageLatch: CountDownLatch

    @BeforeEach
    fun setupDeliveryCallback() {
        receivedMessages.clear()
        messageLatch = CountDownLatch(1)

        kotlinRouter.registerDeliveryCallback { message ->
            receivedMessages.add(message)
            messageLatch.countDown()
        }
    }

    @Test
    fun `receive message from Python via DIRECT delivery`() = runBlocking {
        // Announce Kotlin destination so Python can discover it
        kotlinDestination.announce()

        // Give time for announce to propagate
        Thread.sleep(1000)

        // Send from Python
        val result = python(
            "lxmf_send_direct",
            "destination_hash" to kotlinDestination.hash.toHex(),
            "content" to "Hello from Python!",
            "title" to "Python Message"
        )
        result.getString("sent") shouldBe "true"

        // Wait for Kotlin to receive
        messageLatch.await(15, TimeUnit.SECONDS) shouldBe true

        // Verify message
        receivedMessages.size shouldBe 1
        val received = receivedMessages[0]
        String(received.content) shouldBe "Hello from Python!"
        String(received.title) shouldBe "Python Message"
    }

    @Test
    fun `message source hash matches Python identity`() = runBlocking {
        kotlinDestination.announce()
        Thread.sleep(1000)

        python(
            "lxmf_send_direct",
            "destination_hash" to kotlinDestination.hash.toHex(),
            "content" to "Source hash test"
        )

        messageLatch.await(15, TimeUnit.SECONDS) shouldBe true

        val received = receivedMessages[0]
        // Source should match Python's LXMF destination hash
        received.sourceHash.contentEquals(pythonDestHash!!) shouldBe true
    }

    @Test
    fun `signature validates on received message`() = runBlocking {
        kotlinDestination.announce()
        Thread.sleep(1000)

        python(
            "lxmf_send_direct",
            "destination_hash" to kotlinDestination.hash.toHex(),
            "content" to "Signature validation test"
        )

        messageLatch.await(15, TimeUnit.SECONDS) shouldBe true

        val received = receivedMessages[0]
        received.signatureValidated shouldBe true
        received.unverifiedReason shouldBe null
    }

    @Test
    fun `multiple messages from Python received correctly`() = runBlocking {
        messageLatch = CountDownLatch(3) // Expect 3 messages

        kotlinDestination.announce()
        Thread.sleep(1000)

        // Send 3 messages from Python
        for (i in 1..3) {
            python(
                "lxmf_send_direct",
                "destination_hash" to kotlinDestination.hash.toHex(),
                "content" to "Python message $i"
            )
            Thread.sleep(200) // Small delay between sends
        }

        messageLatch.await(20, TimeUnit.SECONDS) shouldBe true

        receivedMessages.size shouldBe 3
        val contents = receivedMessages.map { String(it.content) }
        contents shouldBe listOf("Python message 1", "Python message 2", "Python message 3")
    }

    @Test
    fun `bidirectional communication works`() = runBlocking {
        kotlinDestination.announce()
        Thread.sleep(1000)

        // Python sends to Kotlin
        python(
            "lxmf_send_direct",
            "destination_hash" to kotlinDestination.hash.toHex(),
            "content" to "Ping from Python"
        )

        messageLatch.await(15, TimeUnit.SECONDS) shouldBe true
        String(receivedMessages[0].content) shouldBe "Ping from Python"

        // Now Kotlin sends back to Python
        val pythonIdentity = network.reticulum.identity.Identity.recall(pythonDestHash!!)!!
        val pythonDest = network.reticulum.destination.Destination.create(
            identity = pythonIdentity,
            direction = network.reticulum.common.DestinationDirection.OUT,
            type = network.reticulum.common.DestinationType.SINGLE,
            appName = "lxmf",
            "delivery"
        )

        val replyMessage = LXMessage(
            destination = pythonDest,
            source = kotlinIdentity,
            content = "Pong from Kotlin".toByteArray()
        )
        replyMessage.desiredMethod = network.reticulum.lxmf.DeliveryMethod.DIRECT

        kotlinRouter.handleOutbound(replyMessage)

        // Wait for Python to receive reply
        waitForPythonMessages(1, timeoutMs = 15000) shouldBe true

        val pythonReceived = getPythonMessages()
        pythonReceived.size shouldBe 1
        pythonReceived[0].content shouldBe "Pong from Kotlin"
    }
}
```

Key test scenarios:
1. Basic message reception from Python
2. Source hash correctly identifies Python sender
3. Signature validates on received messages
4. Multiple messages handled correctly
5. Full bidirectional ping-pong communication
  </action>
  <verify>
Run Python-to-Kotlin tests:
```bash
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*PythonToKotlinDirectTest*" --no-daemon 2>&1 | tail -50
```
Tests should pass.
  </verify>
  <done>PythonToKotlinDirectTest passes: message reception works, source hash matches, signature validates, multiple messages handled, bidirectional communication confirmed.</done>
</task>

<task type="auto">
  <name>Task 3: Run full direct delivery test suite</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/DirectDeliverySmokeTest.kt</files>
  <action>
Run all direct delivery tests together to ensure they work in combination:

1. Run the full test suite:
```bash
./gradlew :lxmf-core:test --tests "*Direct*" --no-daemon
```

2. If any tests fail, debug and fix:
   - Check Python bridge stderr for errors
   - Verify TCP connection establishes
   - Check for timing issues (increase timeouts if needed)
   - Verify announce propagation (add delays if needed)

3. Ensure all tests pass consistently (run 2-3 times to check for flakiness)

Common issues to watch for:
- Path discovery timing (Python may need to announce or Kotlin needs time to learn paths)
- Link establishment timing (wait for ACTIVE status before sending)
- Delivery callback timing (may need longer timeouts in test environment)
  </action>
  <verify>
Run full suite:
```bash
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*Direct*" --no-daemon 2>&1 | tail -100
```
All tests should pass.
  </verify>
  <done>Full direct delivery test suite passes: smoke tests, Kotlin-to-Python tests, Python-to-Kotlin tests all green.</done>
</task>

</tasks>

<verification>
1. KotlinToPythonDirectTest - all tests pass
2. PythonToKotlinDirectTest - all tests pass
3. Full suite runs without flakiness
4. E2E-01 (Kotlin->Python) and E2E-02 (Python->Kotlin) requirements validated
</verification>

<success_criteria>
- Kotlin can send LXMF message to Python via DIRECT delivery, Python receives it correctly
- Python can send LXMF message to Kotlin via DIRECT delivery, Kotlin receives it correctly
- Message content, title, fields preserved in both directions
- Delivery confirmation callbacks fire on sender side
- Source hashes correctly identify senders
- Signatures validate on received messages
- Multiple messages and bidirectional communication work
</success_criteria>

<output>
After completion, create `.planning/phases/06-direct-delivery/06-02-SUMMARY.md`
</output>
