---
phase: 06-direct-delivery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python-bridge/bridge_server.py
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/DirectDeliveryTestBase.kt
autonomous: true

must_haves:
  truths:
    - "PythonBridge can start a Reticulum instance with TCP server interface"
    - "PythonBridge can start an LXMF router with delivery destination"
    - "PythonBridge can report received LXMF messages"
    - "DirectDeliveryTestBase starts Kotlin Reticulum with TCP client connection to Python"
  artifacts:
    - path: "python-bridge/bridge_server.py"
      provides: "Reticulum/LXMF router commands for live testing"
      contains: "cmd_rns_start"
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/DirectDeliveryTestBase.kt"
      provides: "Test base class with Reticulum lifecycle management"
      min_lines: 80
  key_links:
    - from: "DirectDeliveryTestBase.kt"
      to: "bridge_server.py"
      via: "rns_start, lxmf_start_router commands"
      pattern: "python.*rns_start|lxmf_start_router"
---

<objective>
Build test infrastructure for live LXMF direct delivery testing between Kotlin and Python Reticulum instances.

Purpose: Enable end-to-end testing of LXMF DIRECT delivery method with real Reticulum networking, not mocked crypto functions. This is the foundation for all Phase 6 tests.

Output: Extended PythonBridge with Reticulum/LXMF commands, DirectDeliveryTestBase with lifecycle management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-direct-delivery/06-CONTEXT.md
@.planning/phases/06-direct-delivery/06-RESEARCH.md

# Prior phase summaries for patterns
@.planning/phases/01-python-bridge-extension/01-01-SUMMARY.md

# Reference implementations
@python-bridge/bridge_server.py
@rns-test/src/main/kotlin/network/reticulum/interop/InteropTestBase.kt
@rns-test/src/main/kotlin/network/reticulum/interop/PythonBridge.kt
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt

# Python reference for LXMF router
Reference: ~/repos/LXMF/LXMF/LXMRouter.py
Reference: ~/repos/Reticulum/RNS/Transport.py
Reference: ~/repos/Reticulum/RNS/Interfaces/TCPInterface.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Reticulum/LXMF router commands to Python bridge</name>
  <files>python-bridge/bridge_server.py</files>
  <action>
Extend bridge_server.py with commands for live Reticulum networking:

1. **cmd_rns_start(params)** - Start Reticulum with TCP server interface:
   - params: `tcp_port` (int), `config_path` (optional string, default temp dir)
   - Creates temp config directory if not provided
   - Starts RNS with TCPServerInterface on specified port
   - Returns: `{"identity_hash": hex, "ready": true}`
   - Store RNS instance globally for reuse

2. **cmd_rns_stop(params)** - Stop Reticulum:
   - Calls RNS.Transport.exit() to clean shutdown
   - Returns: `{"stopped": true}`

3. **cmd_lxmf_start_router(params)** - Start LXMF router with delivery destination:
   - params: `identity_hex` (optional, 64-byte private key), `display_name` (optional)
   - Creates identity from hex if provided, else generates new
   - Creates LXMRouter with temp storage path
   - Registers delivery identity and callback
   - Stores received messages in global list
   - Returns: `{"identity_hash": hex, "destination_hash": hex}`

4. **cmd_lxmf_get_messages(params)** - Get received LXMF messages:
   - Returns list of received messages with fields:
     - `source_hash`: hex
     - `destination_hash`: hex
     - `content`: string (decoded from bytes)
     - `title`: string (decoded from bytes)
     - `timestamp`: float
     - `hash`: hex (if available)
     - `fields`: dict (field_id -> value)

5. **cmd_lxmf_clear_messages(params)** - Clear received messages list:
   - Returns: `{"cleared": true}`

6. **cmd_lxmf_send_direct(params)** - Send LXMF message via DIRECT delivery:
   - params: `destination_hash` (hex), `content` (string), `title` (optional string), `fields` (optional dict)
   - Creates LXMessage with DIRECT method
   - Uses router to send
   - Returns: `{"sent": true, "message_hash": hex}`

**Important:** Use full RNS import (not the crypto-only bypass) for these commands. The existing crypto-only imports should remain for crypto commands but Reticulum networking requires full RNS.

Pattern: Follow existing cmd_* pattern with try/except and proper error reporting.
  </action>
  <verify>
Run Python bridge manually to verify commands load without errors:
```bash
cd python-bridge && echo '{"id":"test","command":"help","params":{}}' | python3 bridge_server.py
```
Bridge should start without import errors and respond (may return error for unknown command, that's ok).
  </verify>
  <done>6 new bridge commands added: rns_start, rns_stop, lxmf_start_router, lxmf_get_messages, lxmf_clear_messages, lxmf_send_direct. Python bridge starts without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create DirectDeliveryTestBase with Reticulum lifecycle</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/DirectDeliveryTestBase.kt</files>
  <action>
Create a test base class that manages both Kotlin and Python Reticulum instances:

```kotlin
package network.reticulum.lxmf.interop

import network.reticulum.Reticulum
import network.reticulum.identity.Identity
import network.reticulum.interop.InteropTestBase
import network.reticulum.interop.getBytes
import network.reticulum.interop.getString
import network.reticulum.interfaces.tcp.TCPClientInterface
import network.reticulum.lxmf.LXMRouter
import network.reticulum.transport.Transport
import org.junit.jupiter.api.AfterAll
import org.junit.jupiter.api.BeforeAll
import java.io.File
import java.nio.file.Files

/**
 * Base class for direct delivery interop tests.
 *
 * Manages Kotlin and Python Reticulum instances connected via TCP.
 * Python runs TCP server, Kotlin connects as client.
 */
abstract class DirectDeliveryTestBase : InteropTestBase() {

    // Python-side state
    protected var pythonDestHash: ByteArray? = null
    protected var pythonIdentityHash: ByteArray? = null

    // Kotlin-side state
    protected lateinit var kotlinIdentity: Identity
    protected lateinit var kotlinRouter: LXMRouter
    protected lateinit var kotlinDestination: network.reticulum.destination.Destination
    protected var kotlinTcpClient: TCPClientInterface? = null
    protected var configDir: File? = null

    // TCP port for testing (use high port to avoid conflicts)
    protected val tcpPort: Int = 14242 + (System.currentTimeMillis() % 1000).toInt()

    @BeforeAll
    fun setupDirectDelivery() {
        // 1. Start Python Reticulum with TCP server
        val rnsResult = python("rns_start", "tcp_port" to tcpPort)
        require(rnsResult.getString("ready") == "true") { "Python RNS failed to start" }

        // 2. Start Python LXMF router
        val routerResult = python("lxmf_start_router")
        pythonDestHash = routerResult.getBytes("destination_hash")
        pythonIdentityHash = routerResult.getBytes("identity_hash")

        // 3. Start Kotlin Reticulum with TCP client
        configDir = Files.createTempDirectory("reticulum-test-").toFile()
        Reticulum.start(
            configDir = configDir!!.absolutePath,
            enableTransport = true
        )

        // 4. Create TCP client interface to Python
        kotlinTcpClient = TCPClientInterface(
            name = "Test Client",
            targetHost = "127.0.0.1",
            targetPort = tcpPort
        )
        kotlinTcpClient!!.onPacketReceived = { data, iface ->
            Transport.inbound(data, iface.toRef())
        }
        Transport.registerInterface(kotlinTcpClient!!.toRef())
        kotlinTcpClient!!.start()

        // 5. Create Kotlin LXMF router
        kotlinIdentity = Identity.create()
        kotlinRouter = LXMRouter(identity = kotlinIdentity)
        kotlinDestination = kotlinRouter.registerDeliveryIdentity(kotlinIdentity)
        kotlinRouter.start()

        // 6. Wait for connection to establish
        Thread.sleep(500)
    }

    @AfterAll
    fun teardownDirectDelivery() {
        // Stop Kotlin side
        if (::kotlinRouter.isInitialized) {
            kotlinRouter.stop()
        }
        kotlinTcpClient?.stop()
        Reticulum.stop()
        configDir?.deleteRecursively()

        // Stop Python side
        try {
            python("rns_stop")
        } catch (e: Exception) {
            // Ignore cleanup errors
        }
    }

    /**
     * Get messages received by Python LXMF router.
     */
    protected fun getPythonMessages(): List<ReceivedMessage> {
        val result = python("lxmf_get_messages")
        val messagesJson = result["messages"] ?: return emptyList()

        return (messagesJson as kotlinx.serialization.json.JsonArray).map { elem ->
            val obj = elem as kotlinx.serialization.json.JsonObject
            ReceivedMessage(
                sourceHash = obj.getBytes("source_hash"),
                destinationHash = obj.getBytes("destination_hash"),
                content = obj.getString("content"),
                title = obj.getString("title"),
                timestamp = obj.getString("timestamp").toDouble()
            )
        }
    }

    /**
     * Clear Python received messages.
     */
    protected fun clearPythonMessages() {
        python("lxmf_clear_messages")
    }

    /**
     * Wait for Python to receive at least N messages.
     */
    protected fun waitForPythonMessages(count: Int, timeoutMs: Long = 10000): Boolean {
        val deadline = System.currentTimeMillis() + timeoutMs
        while (System.currentTimeMillis() < deadline) {
            if (getPythonMessages().size >= count) {
                return true
            }
            Thread.sleep(100)
        }
        return false
    }

    data class ReceivedMessage(
        val sourceHash: ByteArray,
        val destinationHash: ByteArray,
        val content: String,
        val title: String,
        val timestamp: Double
    )
}
```

Key implementation notes:
- Uses dynamic port allocation (base 14242 + random offset) to avoid conflicts
- Follows existing InteropTestBase pattern for bridge lifecycle
- Manages full Reticulum lifecycle on both sides
- Provides utility methods for message verification
  </action>
  <verify>
Compile the test base class:
```bash
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:compileTestKotlin --no-daemon 2>&1 | head -50
```
Should compile without errors.
  </verify>
  <done>DirectDeliveryTestBase compiles successfully with Kotlin/Python Reticulum lifecycle management, TCP connection, and message verification utilities.</done>
</task>

<task type="auto">
  <name>Task 3: Verify infrastructure with smoke test</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/DirectDeliverySmokeTest.kt</files>
  <action>
Create a minimal smoke test to verify the infrastructure works:

```kotlin
package network.reticulum.lxmf.interop

import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable

/**
 * Smoke test for direct delivery infrastructure.
 *
 * Verifies that Python and Kotlin Reticulum instances can start and connect.
 */
class DirectDeliverySmokeTest : DirectDeliveryTestBase() {

    @Test
    fun `infrastructure starts successfully`() {
        // Python side should have destination
        pythonDestHash shouldNotBe null
        pythonDestHash!!.size shouldBe 16

        // Kotlin side should have router
        kotlinRouter shouldNotBe null
        kotlinDestination shouldNotBe null
        kotlinDestination.hash.size shouldBe 16
    }

    @Test
    fun `TCP connection is active`() {
        // TCP client should be connected
        kotlinTcpClient shouldNotBe null
        kotlinTcpClient!!.isConnected shouldBe true
    }

    @Test
    fun `Python messages list starts empty`() {
        clearPythonMessages()
        val messages = getPythonMessages()
        messages.size shouldBe 0
    }
}
```

This validates:
- Both Reticulum instances start
- TCP connection establishes
- LXMF routers initialize
- Message verification utilities work
  </action>
  <verify>
Run the smoke test:
```bash
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*DirectDeliverySmokeTest*" --no-daemon 2>&1 | tail -30
```
All 3 tests should pass.
  </verify>
  <done>Smoke test passes - infrastructure successfully starts Python/Kotlin Reticulum instances connected via TCP, with LXMF routers initialized.</done>
</task>

</tasks>

<verification>
1. Python bridge loads without import errors
2. 6 new bridge commands respond to requests
3. DirectDeliveryTestBase compiles
4. Smoke test passes: infrastructure starts, TCP connects, routers initialize
</verification>

<success_criteria>
- Python bridge has rns_start, rns_stop, lxmf_start_router, lxmf_get_messages, lxmf_clear_messages, lxmf_send_direct commands
- DirectDeliveryTestBase manages Kotlin+Python Reticulum lifecycle
- TCP connection between instances works
- Smoke test confirms infrastructure is functional
</success_criteria>

<output>
After completion, create `.planning/phases/06-direct-delivery/06-01-SUMMARY.md`
</output>
