---
phase: 03-lxmf-field-interop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python-bridge/bridge_server.py
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/AttachmentFieldInteropTest.kt
autonomous: true

must_haves:
  truths:
    - "Kotlin message with file attachments unpacks in Python with correct filenames and content"
    - "Python message with file attachments unpacks in Kotlin with correct filenames and content"
    - "Multiple attachments preserve ordering across round-trip"
    - "Unicode filenames survive round-trip"
  artifacts:
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/AttachmentFieldInteropTest.kt"
      provides: "FIELD_FILE_ATTACHMENTS round-trip verification"
      min_lines: 100
    - path: "python-bridge/bridge_server.py"
      provides: "Bridge extension for nested binary field content"
      contains: "serialize_field_value"
  key_links:
    - from: "AttachmentFieldInteropTest"
      to: "PythonBridge"
      via: "lxmf_unpack_with_fields command"
      pattern: "lxmf_unpack_with_fields"
---

<objective>
Implement FIELD_FILE_ATTACHMENTS round-trip verification between Kotlin and Python.

Purpose: Prove that file attachments in LXMF messages survive Kotlin-Python round-trips with byte-level accuracy, including filename encoding and binary content preservation.

Output: AttachmentFieldInteropTest with bidirectional attachment verification tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-lxmf-field-interop/03-RESEARCH.md

# Key reference files
@python-bridge/bridge_server.py (cmd_lxmf_unpack, cmd_lxmf_pack)
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/LXMFInteropTestBase.kt
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/KotlinToPythonMessageTest.kt
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMFConstants.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Python bridge with nested field serialization</name>
  <files>python-bridge/bridge_server.py</files>
  <action>
Add a helper function `serialize_field_value(value)` that recursively converts Python field values to JSON-safe format with type annotations:

```python
def serialize_field_value(value):
    """Recursively serialize field values for JSON transport.

    Binary data is hex-encoded with type annotation.
    Lists/tuples are recursively serialized.
    """
    if isinstance(value, bytes):
        return {'type': 'bytes', 'hex': value.hex()}
    elif isinstance(value, (list, tuple)):
        return {'type': 'list', 'items': [serialize_field_value(v) for v in value]}
    elif isinstance(value, dict):
        return {'type': 'dict', 'items': {str(k): serialize_field_value(v) for k, v in value.items()}}
    elif isinstance(value, int):
        return {'type': 'int', 'value': value}
    elif isinstance(value, float):
        return {'type': 'float', 'value': value}
    elif isinstance(value, str):
        return {'type': 'str', 'value': value}
    else:
        return {'type': type(value).__name__, 'value': str(value)}
```

Add new command `cmd_lxmf_unpack_with_fields(params)`:

```python
def cmd_lxmf_unpack_with_fields(params):
    """Unpack LXMF message with deep field serialization.

    Like lxmf_unpack but returns fields_hex with all nested binary data hex-encoded.
    """
    result = cmd_lxmf_unpack(params)

    # Serialize all field values for JSON transport
    fields = result.get('fields', {})
    fields_hex = {}
    if fields:
        for key, value in fields.items():
            fields_hex[str(key)] = serialize_field_value(value)

    result['fields_hex'] = fields_hex
    return result
```

Register the new command in the commands dict: `'lxmf_unpack_with_fields': cmd_lxmf_unpack_with_fields`
  </action>
  <verify>
Run bridge server manually with test command:
```bash
cd ./python-bridge
echo '{"command":"lxmf_unpack_with_fields","params":{"lxmf_bytes":"..."}}' | python3 bridge_server.py
```
Verify `fields_hex` appears in response with properly nested structure.
  </verify>
  <done>Bridge returns fields_hex with nested binary content hex-encoded and type-annotated.</done>
</task>

<task type="auto">
  <name>Task 2: Create AttachmentFieldInteropTest</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/AttachmentFieldInteropTest.kt</files>
  <action>
Create AttachmentFieldInteropTest extending LXMFInteropTestBase with these test cases:

1. `single text attachment round-trips correctly` - Create message with one text file attachment, verify filename bytes and content bytes match in Python

2. `multiple attachments preserve ordering` - Create message with 3 attachments (text, binary, text), verify all three present in correct order with matching content

3. `binary attachment content preserved` - Create message with binary file (e.g., 1KB random bytes), verify byte-for-byte match via SHA-256 checksum

4. `unicode filename survives round-trip` - Create attachment with emoji and CJK characters in filename, verify decoded correctly in Python

5. `empty attachments list handled correctly` - Create message with empty attachments list, verify Python handles it (discover what Python does - empty list vs field absent)

Key implementation details:
- FIELD_FILE_ATTACHMENTS structure: `listOf(listOf(filename.toByteArray(Charsets.UTF_8), contentBytes))`
- Field key is `LXMFConstants.FIELD_FILE_ATTACHMENTS` (0x05)
- Use the new `lxmf_unpack_with_fields` command to get hex-encoded field content
- Add helper to parse fields_hex response structure
- Include timing logs like existing tests

Test fixture structure:
```kotlin
data class AttachmentFixture(
    val filename: String,
    val content: ByteArray
)

fun createAttachmentMessage(attachments: List<AttachmentFixture>): LXMessage {
    val attachmentField = attachments.map { att ->
        listOf(att.filename.toByteArray(Charsets.UTF_8), att.content)
    }
    return createTestMessage(
        content = "Message with attachments",
        fields = mutableMapOf(
            LXMFConstants.FIELD_FILE_ATTACHMENTS to attachmentField
        )
    )
}
```
  </action>
  <verify>
```bash
JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "AttachmentFieldInteropTest" --info
```
All 5 tests should pass.
  </verify>
  <done>AttachmentFieldInteropTest passes all tests proving FIELD_FILE_ATTACHMENTS survives Kotlin-Python round-trip.</done>
</task>

</tasks>

<verification>
1. Python bridge responds to `lxmf_unpack_with_fields` with properly serialized fields
2. AttachmentFieldInteropTest runs all 5 tests
3. All tests pass with timing logs showing bridge communication
4. Git status shows only expected file modifications
</verification>

<success_criteria>
- FIELD_FILE_ATTACHMENTS with multiple files survives round-trip
- Filename bytes (UTF-8 encoded) match between implementations
- Binary content bytes match between implementations
- Attachment ordering preserved
- Unicode filenames handled correctly
- Empty attachment list behavior documented and matched
</success_criteria>

<output>
After completion, create `.planning/phases/03-lxmf-field-interop/03-01-SUMMARY.md`
</output>
