---
phase: 03-lxmf-field-interop
plan: 03
type: execute
wave: 1
depends_on: ["03-01"]
files_modified:
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/CustomFieldInteropTest.kt
autonomous: true

must_haves:
  truths:
    - "FIELD_RENDERER integer value survives round-trip correctly"
    - "FIELD_THREAD byte array survives round-trip correctly"
    - "Arbitrary custom fields survive round-trip"
    - "Msgpack Long/Int handling works correctly for field values"
  artifacts:
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/CustomFieldInteropTest.kt"
      provides: "Custom field round-trip verification"
      min_lines: 100
  key_links:
    - from: "CustomFieldInteropTest"
      to: "PythonBridge"
      via: "lxmf_unpack_with_fields command"
      pattern: "lxmf_unpack_with_fields"
---

<objective>
Implement custom field (FIELD_RENDERER, FIELD_THREAD, arbitrary fields) round-trip verification between Kotlin and Python.

Purpose: Prove that custom LXMF fields with various value types (integers, byte arrays, strings) survive Kotlin-Python round-trips correctly.

Output: CustomFieldInteropTest with comprehensive custom field verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-lxmf-field-interop/03-RESEARCH.md

# Key reference files
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/LXMFInteropTestBase.kt
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/AttachmentFieldInteropTest.kt
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMFConstants.kt

# Research notes:
# - FIELD_RENDERER (0x0F) is an integer: RENDERER_PLAIN=0x00, RENDERER_MICRON=0x01, RENDERER_MARKDOWN=0x02, RENDERER_BBCODE=0x03
# - FIELD_THREAD (0x08) is for thread ID (typically byte array)
# - Msgpack deserializes integers as Long not Int
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CustomFieldInteropTest</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/CustomFieldInteropTest.kt</files>
  <action>
Create CustomFieldInteropTest extending LXMFInteropTestBase with these test cases:

1. `FIELD_RENDERER integer values round-trip correctly` - Test all 4 renderer values (PLAIN, MICRON, MARKDOWN, BBCODE), verify each survives round-trip. Handle msgpack Long vs Int deserialization.

2. `FIELD_THREAD byte array round-trips correctly` - Create message with thread ID as byte array (e.g., 16-byte hash), verify bytes match in Python

3. `multiple custom fields round-trip together` - Create message with FIELD_RENDERER + FIELD_THREAD + FIELD_DEBUG, verify all three present and correct

4. `arbitrary high field key values work` - Test with FIELD_CUSTOM_TYPE (0xFB), FIELD_CUSTOM_DATA (0xFC), FIELD_NON_SPECIFIC (0xFE) to verify high key values work

5. `empty fields dictionary handled correctly` - Test message with empty mutableMapOf(), verify Python handles it (field absent vs empty dict)

6. `null field handling matches Python` - Test what happens with null values in fields dictionary, document Python behavior

Key implementation details:
- Handle msgpack Long deserialization: `when (value) { is Int -> ..., is Long -> ... }`
- Field keys are integers, not strings
- Use `lxmf_unpack_with_fields` for hex-encoded verification
- Reuse field parsing helpers from AttachmentFieldInteropTest

Important: From research, msgpack deserializes integers as Long by default. Test must handle:
```kotlin
val rendererValue = when (val v = message.fields[LXMFConstants.FIELD_RENDERER]) {
    is Int -> v
    is Long -> v.toInt()
    else -> throw AssertionError("Unexpected renderer type: ${v?.javaClass}")
}
rendererValue shouldBe LXMFConstants.RENDERER_MARKDOWN
```

Test the full range of renderer values:
```kotlin
listOf(
    LXMFConstants.RENDERER_PLAIN to "PLAIN",
    LXMFConstants.RENDERER_MICRON to "MICRON",
    LXMFConstants.RENDERER_MARKDOWN to "MARKDOWN",
    LXMFConstants.RENDERER_BBCODE to "BBCODE"
).forEach { (value, name) ->
    // Test each renderer value
}
```

Also test Python-to-Kotlin direction:
- Create message in Python with custom fields using lxmf_pack
- Unpack in Kotlin
- Verify field values match
  </action>
  <verify>
```bash
JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "CustomFieldInteropTest" --info
```
All 6 tests should pass.
  </verify>
  <done>CustomFieldInteropTest passes all tests proving custom fields survive Kotlin-Python round-trip with correct type handling.</done>
</task>

<task type="auto">
  <name>Task 2: Run full Phase 3 test suite</name>
  <files>N/A (verification only)</files>
  <action>
Run all Phase 3 interop tests together to verify no regressions and complete phase:

1. Run all three new test classes:
```bash
JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "*FieldInteropTest" --info
```

2. Also run existing Phase 2 tests to verify no regressions:
```bash
JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "*MessageTest" --info
```

3. Document any edge case behaviors discovered (empty fields, null handling, etc.) in the summary

4. Count total test cases across all three test classes
  </action>
  <verify>
All field interop tests pass. All message tests pass (no regressions). Total test count documented.
  </verify>
  <done>Full Phase 3 suite passes with documented edge case behaviors.</done>
</task>

</tasks>

<verification>
1. CustomFieldInteropTest runs all 6 tests
2. All tests pass with timing logs
3. Msgpack Long/Int handling works correctly
4. Full suite (3 test classes) passes
5. No regressions in Phase 2 tests
6. Edge case behaviors documented
</verification>

<success_criteria>
- FIELD_RENDERER with all 4 values survives round-trip
- FIELD_THREAD byte array survives round-trip
- Arbitrary custom fields survive round-trip
- Msgpack integer type handling is correct
- Empty/null field behaviors documented and matched
</success_criteria>

<output>
After completion, create `.planning/phases/03-lxmf-field-interop/03-03-SUMMARY.md`
</output>
