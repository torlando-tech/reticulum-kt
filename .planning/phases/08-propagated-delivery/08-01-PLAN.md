---
phase: 08-propagated-delivery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - python-bridge/bridge_server.py
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PropagatedDeliveryTestBase.kt
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PropagatedDeliveryTest.kt
autonomous: true

must_haves:
  truths:
    - "Kotlin client can submit message to Python propagation node"
    - "Python propagation node accepts Kotlin-generated stamp"
    - "Kotlin client can retrieve message from Python propagation node"
    - "Propagation node rejects message with insufficient stamp"
    - "End-to-end content integrity verified"
  artifacts:
    - path: "python-bridge/bridge_server.py"
      provides: "Propagation node commands"
      contains: "cmd_propagation_node_start"
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PropagatedDeliveryTestBase.kt"
      provides: "Test infrastructure for propagation node lifecycle"
      min_lines: 100
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PropagatedDeliveryTest.kt"
      provides: "E2E propagated delivery tests"
      min_lines: 150
  key_links:
    - from: "PropagatedDeliveryTestBase.kt"
      to: "bridge_server.py"
      via: "python() bridge calls"
      pattern: "python.*propagation_node"
    - from: "PropagatedDeliveryTest.kt"
      to: "LXMRouter.kt"
      via: "handleOutbound() and requestMessagesFromPropagationNode()"
      pattern: "kotlinRouter\\.(handleOutbound|requestMessages)"
---

<objective>
Implement end-to-end testing of LXMF PROPAGATED delivery between Kotlin clients and a Python propagation node.

Purpose: Verify Kotlin can submit messages to and retrieve messages from Python propagation nodes with correct stamp handling - the store-and-forward mechanism essential for offline messaging.

Output: PropagatedDeliveryTestBase with propagation node lifecycle management, bridge commands for propagation node control, and tests verifying submission, retrieval, and stamp rejection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-propagated-delivery/08-CONTEXT.md
@.planning/phases/08-propagated-delivery/08-RESEARCH.md
@.planning/phases/06-direct-delivery/06-01-SUMMARY.md
@python-bridge/bridge_server.py
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/DirectDeliveryTestBase.kt
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add propagation node commands to Python bridge</name>
  <files>python-bridge/bridge_server.py</files>
  <action>
Add 3 new bridge commands for propagation node testing:

1. **cmd_propagation_node_start(params)** - Start propagation node
   - Get stamp_cost from params (default 8 for fast tests)
   - Set lxmf_router.propagation_stamp_cost = stamp_cost
   - Call lxmf_router.enable_propagation()
   - Return propagation_hash (lxmf_router.propagation_destination.hash), stamp_cost
   - Pattern from RESEARCH.md Example 1

2. **cmd_propagation_node_get_messages(params)** - Get stored messages
   - Iterate lxmf_router.propagation_entries
   - Return list with transient_id, destination_hash, received_time, size for each
   - Return count of messages
   - Pattern from RESEARCH.md Example 2

3. **cmd_propagation_node_submit_for_recipient(params)** - Store test message for retrieval
   - Get recipient_hash, content from params
   - Create LXMessage with source=lxmf_router identity, destination=recipient
   - Set desired_method to PROPAGATED
   - Pack message with propagation format
   - Call lxmf_propagation() or equivalent to store directly
   - Return submitted: true, transient_id

Register all three in main() command_handlers dict.

Important: Must call lxmf_router.enable_propagation() before any propagation operations.
  </action>
  <verify>
Bridge server starts without errors:
```bash
cd ./python-bridge && python3 -c "import bridge_server; print('OK')"
```
  </verify>
  <done>
Three new bridge commands handle propagation node start, message listing, and test message submission.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PropagatedDeliveryTestBase and tests</name>
  <files>
    lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PropagatedDeliveryTestBase.kt
    lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PropagatedDeliveryTest.kt
  </files>
  <action>
**Create PropagatedDeliveryTestBase.kt** extending DirectDeliveryTestBase:

1. Override setupDirectDelivery() to:
   - Call super.setupDirectDelivery()
   - Start propagation node via python("propagation_node_start", "stamp_cost" to 8)
   - Store propagationNodeHash from result
   - Call setActivePropagationNode() on kotlinRouter
   - Log propagation node ready status

2. Add helper methods:
   - getPropagationNodeMessages(): Call python("propagation_node_get_messages"), return list
   - waitForMessageInPropagationNode(timeoutMs): Poll until message count > 0
   - submitTestMessageForKotlin(content): Call python("propagation_node_submit_for_recipient")

**Create PropagatedDeliveryTest.kt** with 4 tests:

1. **`Kotlin can submit message to Python propagation node`**
   - Create LXMessage with PROPAGATED method
   - Generate propagation stamp (cost=8)
   - Call kotlinRouter.handleOutbound(message)
   - Wait for message state SENT (accepted by node)
   - Verify getPropagationNodeMessages() count >= 1

2. **`Kotlin can retrieve message from Python propagation node`**
   - Call submitTestMessageForKotlin() to store test message
   - Register delivery callback on kotlinRouter
   - Call kotlinRouter.requestMessagesFromPropagationNode()
   - Wait for message delivery via callback
   - Verify content matches

3. **`Propagation node rejects message with insufficient stamp`**
   - Start propagation node with stamp_cost=12
   - Create message with stamp cost=8 (insufficient)
   - Submit message
   - Wait for REJECTED state (not SENT)
   - Verify message NOT in propagation node storage

4. **`Message with fields survives propagated delivery round-trip`**
   - Create message with custom fields and attachment
   - Submit to propagation node
   - Retrieve via another identity
   - Verify fields preserved

Pattern: Follow DirectDeliveryTestBase structure, use runBlocking for async, add Unit at end of tests for JUnit discovery.
  </action>
  <verify>
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "*PropagatedDelivery*" --info
```
  </verify>
  <done>
All 4 propagated delivery tests pass, validating submission, retrieval, rejection, and field preservation.
  </done>
</task>

</tasks>

<verification>
Run full Phase 8 test suite:
```bash
cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "*PropagatedDelivery*" --info
```

Verify requirements coverage:
- E2E-04: PROPAGATED delivery via Python propagation node (all 4 tests)
</verification>

<success_criteria>
1. Python bridge loads with 3 new propagation_node_* commands
2. PropagatedDeliveryTestBase compiles and manages propagation node lifecycle
3. Kotlin message submission accepted by Python propagation node
4. Kotlin retrieval returns messages stored in propagation node
5. Insufficient stamp correctly rejected with REJECTED state
6. Fields preserved through propagated delivery round-trip
7. All 4 tests pass consistently
</success_criteria>

<output>
After completion, create `.planning/phases/08-propagated-delivery/08-01-SUMMARY.md`
</output>
