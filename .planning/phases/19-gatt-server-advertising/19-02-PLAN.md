---
phase: 19-gatt-server-advertising
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/ble/BleAdvertiser.kt
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BleOperationQueue.kt
  - rns-interfaces/src/test/kotlin/network/reticulum/interfaces/ble/BleOperationQueueTest.kt

autonomous: true

must_haves:
  truths:
    - "BLE advertising with service UUID 37145b00-442d-4a94-917f-8f42c5da28e3 for peer discovery"
    - "Advertising is connectable with indefinite timeout"
    - "Advertising restarts after connection if stopped (OEM auto-stop resilience)"
    - "60-second periodic advertising refresh for background persistence"
    - "Advertising mode is user-configurable (LOW_POWER, BALANCED, LOW_LATENCY)"
    - "BleOperationQueue serializes GATT operations via Channel (one at a time)"
    - "BleOperationQueue is pure JVM (coroutines-only, no Android imports)"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ble/BleAdvertiser.kt"
      provides: "BLE advertising lifecycle, configurable mode, restart logic, 60s refresh"
      exports: ["BleAdvertiser"]
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BleOperationQueue.kt"
      provides: "Generic GATT operation serializer using Channel + suspend functions"
      exports: ["BleOperationQueue"]
    - path: "rns-interfaces/src/test/kotlin/network/reticulum/interfaces/ble/BleOperationQueueTest.kt"
      provides: "Unit tests for operation queue serialization behavior"
  key_links:
    - from: "BleAdvertiser.kt"
      to: "BLEConstants.kt"
      via: "imports SERVICE_UUID for advertising payload"
      pattern: "BLEConstants\\.SERVICE_UUID"
    - from: "BleOperationQueue.kt"
      to: "kotlinx.coroutines"
      via: "uses Channel, Mutex, withTimeout for operation serialization"
      pattern: "Channel|Mutex|withTimeout"
---

<objective>
Implement BleAdvertiser.kt for BLE advertising lifecycle and BleOperationQueue.kt for GATT operation serialization.

Purpose: The advertiser makes this device discoverable by other Reticulum BLE peers. It handles the advertising lifecycle including OEM resilience (some chipsets silently stop advertising on connection), periodic 60-second refresh for background persistence, and user-configurable advertising mode. The operation queue serializes GATT operations for Phase 20's GATT client and is placed in rns-interfaces as a pure-JVM coroutines utility.

Output: `BleAdvertiser.kt` in rns-android, `BleOperationQueue.kt` + tests in rns-interfaces.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-gatt-server-advertising/19-CONTEXT.md
@.planning/phases/19-gatt-server-advertising/19-RESEARCH.md

# Reference implementations:
@~/repos/columba/reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/server/BleAdvertiser.kt
@~/repos/columba/reticulum/src/main/java/com/lxmf/messenger/reticulum/ble/util/BleOperationQueue.kt

# Phase 18 outputs:
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BLEConstants.kt

# Existing module structure:
@rns-android/build.gradle.kts
@rns-interfaces/build.gradle.kts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement BleOperationQueue.kt (pure JVM)</name>
  <files>
    rns-interfaces/src/main/kotlin/network/reticulum/interfaces/ble/BleOperationQueue.kt
    rns-interfaces/src/test/kotlin/network/reticulum/interfaces/ble/BleOperationQueueTest.kt
  </files>
  <action>
Create a generic GATT operation queue in `rns-interfaces` that serializes suspend function execution. This is a pure-JVM utility using only kotlinx.coroutines -- NO Android imports. It will be used by Phase 20's GATT client for write/read serialization and can also be used by BleGattServer for notification serialization if desired.

**IMPORTANT:** This is NOT the same as Columba's BleOperationQueue which is tightly coupled to Android BLE types (BluetoothGatt, etc.). This is a generic operation serializer.

**BleOperationQueue.kt:**
```kotlin
package network.reticulum.interfaces.ble

import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock

/**
 * Generic operation queue that ensures only one BLE operation runs at a time.
 *
 * Android's BLE stack does NOT queue operations internally. If you call
 * multiple GATT operations in succession, the second silently fails.
 * This queue serializes operations with proper completion tracking and timeouts.
 *
 * Pure JVM -- uses only kotlinx.coroutines, no Android imports.
 * Used by BleGattClient (Phase 20) for GATT write/read serialization.
 */
class BleOperationQueue(
    private val scope: CoroutineScope = CoroutineScope(Dispatchers.IO + SupervisorJob()),
    private val defaultTimeoutMs: Long = BLEConstants.OPERATION_TIMEOUT_MS,
) {
    private data class Operation<T>(
        val block: suspend () -> T,
        val deferred: CompletableDeferred<T>,
        val timeoutMs: Long,
    )

    private val channel = Channel<Operation<*>>(Channel.UNLIMITED)
    private val _isRunning = kotlinx.coroutines.flow.MutableStateFlow(false)

    init {
        scope.launch {
            _isRunning.value = true
            for (op in channel) {
                executeOperation(op)
            }
            _isRunning.value = false
        }
    }

    private suspend fun <T> executeOperation(op: Operation<T>) {
        try {
            val result = withTimeout(op.timeoutMs) { op.block() }
            op.deferred.complete(result)
        } catch (e: TimeoutCancellationException) {
            op.deferred.completeExceptionally(
                BleOperationTimeoutException("Operation timed out after ${op.timeoutMs}ms", e)
            )
        } catch (e: CancellationException) {
            op.deferred.cancel(e)
        } catch (e: Exception) {
            op.deferred.completeExceptionally(e)
        }
    }

    /**
     * Enqueue an operation and suspend until it completes.
     * Operations execute in FIFO order, one at a time.
     *
     * @param timeoutMs timeout for this operation (default from constructor)
     * @param block the suspend function to execute
     * @return result of the operation
     * @throws BleOperationTimeoutException if the operation times out
     */
    suspend fun <T> enqueue(
        timeoutMs: Long = defaultTimeoutMs,
        block: suspend () -> T,
    ): T {
        val deferred = CompletableDeferred<T>()
        val operation = Operation(block, deferred, timeoutMs)
        channel.send(operation)
        return deferred.await()
    }

    /**
     * Shutdown the queue. Cancels all pending operations.
     */
    fun shutdown() {
        channel.close()
        scope.cancel()
    }
}

/**
 * Thrown when a BLE operation exceeds its timeout.
 */
class BleOperationTimeoutException(
    message: String,
    cause: Throwable? = null,
) : Exception(message, cause)
```

**BleOperationQueueTest.kt:**
Write tests that exercise the production code:

1. **Serial execution**: Enqueue 3 operations that each record their execution order. Assert they run in FIFO order (not interleaved).

2. **Timeout**: Enqueue an operation that delays longer than the timeout. Assert it throws BleOperationTimeoutException.

3. **Exception propagation**: Enqueue an operation that throws. Assert the exception is propagated to the caller.

4. **Queue continues after failure**: Enqueue an operation that throws, then enqueue a second that succeeds. Assert the second runs and returns its result.

5. **Concurrent enqueue**: Launch multiple coroutines that each enqueue operations concurrently. Assert all operations complete and total execution count matches enqueue count.

Use `runBlocking` and `kotlinx.coroutines.test.runTest` for test coroutine support. Use `delay()` in operations to verify serialization (if op1 delays 100ms and op2 delays 0ms, op2 should still complete after op1).
  </action>
  <verify>
Run the tests:
```
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:test --tests "network.reticulum.interfaces.ble.BleOperationQueueTest"
```
All tests pass.
  </verify>
  <done>
BleOperationQueue.kt is a pure-JVM coroutines utility that serializes operations via Channel. All 5+ unit tests pass verifying serial execution, timeout, exception propagation, and concurrent access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement BleAdvertiser.kt</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ble/BleAdvertiser.kt</files>
  <action>
Create `BleAdvertiser.kt` in `network.reticulum.android.ble`. This manages BLE advertising lifecycle.

**Follow Columba's BleAdvertiser.kt** but simplify per CONTEXT.md decisions:
- Minimal advertising payload: service UUID only, NO device name (per CONTEXT.md)
- No scan response data needed (no name to put there)
- User-configurable advertising mode via enum parameter
- 60-second periodic refresh for background persistence (ADV-03)
- Restart advertising after connection if it stopped (ADV-02)

**Class signature:**
```kotlin
class BleAdvertiser(
    private val context: Context,
    private val bluetoothAdapter: BluetoothAdapter,
    private val scope: CoroutineScope = CoroutineScope(Dispatchers.Default + SupervisorJob()),
)
```

**Advertising mode enum:**
```kotlin
enum class AdvertiseMode(val value: Int) {
    LOW_POWER(AdvertiseSettings.ADVERTISE_MODE_LOW_POWER),
    BALANCED(AdvertiseSettings.ADVERTISE_MODE_BALANCED),
    LOW_LATENCY(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY),
}
```

**Public API:**
- `suspend fun startAdvertising(mode: AdvertiseMode = AdvertiseMode.BALANCED): Result<Unit>`
  - Build AdvertiseSettings with connectable=true, timeout=0, TX_POWER_HIGH, user-chosen mode
  - Build AdvertiseData with service UUID only (no device name, no TX power level)
  - No scan response (CONTEXT.md says minimal payload, service UUID only)
  - Start advertising via BluetoothLeAdvertiser
  - Start the 60-second refresh timer

- `suspend fun stopAdvertising()`
  - Stop advertising via BluetoothLeAdvertiser
  - Cancel the refresh timer

- `fun restartIfNeeded()`
  - Called by BleGattServer's onConnectionStateChange to restart advertising after OEM auto-stop
  - Checks `_isAdvertising` state -- if it should be advertising but isn't, restart

- `fun shutdown()`
  - Stop advertising, cancel refresh timer, cancel scope

**State:**
- `val isAdvertising: StateFlow<Boolean>` -- current advertising state
- `private var shouldBeAdvertising = false` -- tracks desired state (vs actual state which may differ due to OEM stops)
- `private var currentMode: AdvertiseMode = AdvertiseMode.BALANCED`

**AdvertiseCallback:**
```kotlin
private val advertiseCallback = object : AdvertiseCallback() {
    override fun onStartSuccess(settingsInEffect: AdvertiseSettings) {
        _isAdvertising.value = true
        retryCount = 0
    }
    override fun onStartFailure(errorCode: Int) {
        _isAdvertising.value = false
        // Retry once with 2s delay, then emit error
        if (retryCount < 3) {
            retryCount++
            scope.launch {
                delay(2000L * retryCount)
                if (shouldBeAdvertising) {
                    startAdvertisingInternal()
                }
            }
        }
    }
}
```

**60-second advertising refresh (ADV-03):**
```kotlin
private var refreshJob: Job? = null

private fun startRefreshTimer() {
    refreshJob?.cancel()
    refreshJob = scope.launch {
        while (isActive) {
            delay(60_000L)
            if (shouldBeAdvertising) {
                // Stop and restart advertising to ensure it's still active
                // Some OEMs silently stop advertising after extended periods
                try {
                    stopAdvertisingInternal()
                    delay(100) // Brief gap
                    startAdvertisingInternal()
                } catch (e: Exception) {
                    // Log error, but don't crash -- advertising may recover
                }
            }
        }
    }
}
```

**Permission check:**
Same pattern as BleGattServer -- check BLUETOOTH_ADVERTISE on API 31+, check isMultipleAdvertisementSupported.

**Error handling per CONTEXT.md:**
- Retry up to 3 times on advertising failure with linear backoff (2s, 4s, 6s)
- After max retries, stop attempting and let caller handle via isAdvertising state
- Minimal logging -- only errors

**Tag for logging:** `"BleAdvertiser"` (no vendor prefix)
  </action>
  <verify>
Build rns-android to verify compilation:
```
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
The file should compile without errors.
  </verify>
  <done>
BleAdvertiser.kt exists at rns-android/src/main/kotlin/network/reticulum/android/ble/BleAdvertiser.kt with:
- Minimal advertising payload (service UUID only, no device name)
- Connectable advertising with indefinite timeout
- User-configurable AdvertiseMode enum (LOW_POWER, BALANCED, LOW_LATENCY)
- 60-second periodic refresh timer for background persistence
- restartIfNeeded() for OEM auto-stop resilience
- Retry with linear backoff on failure (up to 3 attempts)
- StateFlow for isAdvertising state
  </done>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:test --tests "network.reticulum.interfaces.ble.BleOperationQueueTest"` passes
2. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin` succeeds
3. BleOperationQueue has zero Android imports (pure JVM)
4. BleAdvertiser uses BLEConstants.SERVICE_UUID for advertising payload
5. Advertising is connectable with timeout=0
6. AdvertiseMode enum exposes 3 Android advertising modes
7. 60-second refresh timer restarts advertising periodically
</verification>

<success_criteria>
- BleOperationQueue tests pass on JVM (no Android required)
- BleAdvertiser compiles with rns-android
- ADV-01 (service UUID advertising), ADV-02 (restart after connection), ADV-03 (60s refresh) all addressed
</success_criteria>

<output>
After completion, create `.planning/phases/19-gatt-server-advertising/19-02-SUMMARY.md`
</output>
