---
phase: 13-workmanager-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/BootReceiver.kt
  - rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt
autonomous: true

must_haves:
  truths:
    - "When user explicitly stops service, WorkManager periodic work is also cancelled"
    - "Boot receiver enqueues WorkManager when auto-start preference is enabled"
    - "BootReceiver starts service directly for immediate availability (not delayed via WorkManager)"
    - "Worker survives app restart via KEEP policy on enqueue"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/BootReceiver.kt"
      provides: "Boot-triggered service start with WorkManager enqueue"
      contains: "ACTION_BOOT_COMPLETED"
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt"
      provides: "Service stop cancels WorkManager, service start enqueues WorkManager"
      contains: "ReticulumWorker"
  key_links:
    - from: "BootReceiver.onReceive()"
      to: "ReticulumService.start()"
      via: "direct service start on boot for immediate availability"
      pattern: "ReticulumService\\.start"
    - from: "BootReceiver.onReceive()"
      to: "ReticulumWorker.schedule()"
      via: "enqueue WorkManager after service start for recovery"
      pattern: "ReticulumWorker\\.schedule"
    - from: "ReticulumService.shutdownReticulum()"
      to: "ReticulumWorker.cancel()"
      via: "cancel WorkManager on service shutdown"
      pattern: "ReticulumWorker\\.cancel"
---

<objective>
Wire WorkManager lifecycle into service start/stop and boot receiver. Ensure "stop means stop" (user-initiated stop cancels WorkManager) and boot restarts both service and WorkManager when auto-start is enabled.

Purpose: The worker is only useful alongside the service. When the user explicitly stops the service, the worker must stop too. On boot, if auto-start is enabled, both service and worker should start for immediate + resilient operation.

Output: Modified BootReceiver.kt and ReticulumService.kt with proper WorkManager lifecycle wiring.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-workmanager-integration/13-CONTEXT.md

# Files to modify
@rns-android/src/main/kotlin/network/reticulum/android/BootReceiver.kt
@rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt

# Worker scheduling API
@rns-android/src/main/kotlin/network/reticulum/android/ReticulumWorker.kt

# App preferences (auto_start key)
@rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/data/PreferencesManager.kt

# ViewModel service lifecycle (for understanding stop flow)
@rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/viewmodel/ReticulumViewModel.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance BootReceiver with auto-start check and WorkManager enqueue</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/BootReceiver.kt</files>
  <action>
Enhance BootReceiver to:

**1. Check auto-start preference before starting service on boot:**
- Since BootReceiver is in the rns-android library module, it doesn't have direct access to the app's DataStore. The receiver is currently disabled by default in the manifest — apps enable it explicitly.
- Keep the existing behavior: if the receiver is enabled AND boot intent is received, start the service. The app's manifest controls whether the receiver is active.
- Add MY_PACKAGE_REPLACED intent filter handling — when the app is updated, re-enqueue WorkManager if the service should be running.

**2. Enqueue WorkManager after starting service:**
- After calling `ReticulumService.start(context)`, also call `ReticulumWorker.schedule(context)` to ensure the periodic worker is enqueued for recovery
- This means on boot, both the service (immediate) and the worker (recovery backup) are running

**3. Handle ACTION_MY_PACKAGE_REPLACED:**
- Add handler for this intent to re-enqueue WorkManager after app update
- Since WorkManager uses KEEP policy, this is a safety net — the work should survive updates, but re-enqueue ensures it

**4. Add logging:**
- Log.i when boot completed, when starting service, when enqueuing worker
- Use TAG "BootReceiver"

Note: The BootReceiver is disabled by default in the manifest (android:enabled="false"). The app enables/disables it via PackageManager based on the autoStart preference. This is the correct pattern — the library provides the receiver, the app controls whether it's active.
  </action>
  <verify>
Build the rns-android module:
```bash
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
No compilation errors.
  </verify>
  <done>
BootReceiver starts service AND enqueues WorkManager on boot. Handles MY_PACKAGE_REPLACED for app update resilience. Has logging for debugging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ReticulumService stop to cancel WorkManager</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt</files>
  <action>
The existing ReticulumService already has WorkManager wiring:
- `initializeReticulum()` calls `ReticulumWorker.schedule(this, intervalMinutes = 15)` when transport is enabled
- `shutdownReticulum()` calls `ReticulumWorker.cancel(this)`

Review and ensure the wiring is correct per CONTEXT.md decisions:

**1. Schedule WorkManager regardless of transport mode:**
- Currently, WorkManager is only scheduled when `config.enableTransport` is true
- Per CONTEXT.md, the worker should run for recovery even in client mode (service restart, interface health)
- Move `ReticulumWorker.schedule()` call outside the `if (config.enableTransport)` block
- Pass autoRestart data to schedule() if the autoRestart parameter was added in Plan 13-01

**2. Verify "stop means stop":**
- `shutdownReticulum()` already calls `ReticulumWorker.cancel(this)` — this is correct
- Ensure this happens before `Reticulum.stop()` so the worker doesn't race to restart

**3. Add a static helper for external callers to cancel work:**
- Add `ReticulumService.cancelWorkManager(context: Context)` or ensure the ViewModel's stopService() path reaches `ReticulumWorker.cancel()`
- Looking at the code flow: ViewModel.stopService() -> ReticulumService.stop(context) -> stopService(intent) -> onDestroy() -> shutdownReticulum() -> ReticulumWorker.cancel(this)
- This chain is correct. No additional wiring needed for the stop path.

**4. Verify KEEP policy:**
- ReticulumWorker.schedule() already uses `ExistingPeriodicWorkPolicy.KEEP` — this is correct for app update survival per CONTEXT.md

Log the WorkManager schedule/cancel events at Log.i level.
  </action>
  <verify>
Build the rns-android module:
```bash
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
No compilation errors.
  </verify>
  <done>
WorkManager scheduled regardless of transport mode (recovery applies to all modes). Stop path correctly cancels WorkManager before Reticulum shutdown. KEEP policy ensures work survives app updates.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update AndroidManifest for MY_PACKAGE_REPLACED intent</name>
  <files>rns-android/src/main/AndroidManifest.xml</files>
  <action>
Add MY_PACKAGE_REPLACED action to the BootReceiver intent-filter so the receiver can re-enqueue WorkManager after app updates:

```xml
<receiver
    android:name=".BootReceiver"
    android:enabled="false"
    android:exported="false">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED" />
        <action android:name="android.intent.action.MY_PACKAGE_REPLACED" />
    </intent-filter>
</receiver>
```

This allows the same receiver to handle both boot and app update events. The receiver is still disabled by default — apps must explicitly enable it.
  </action>
  <verify>
Build the rns-android module:
```bash
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
No compilation errors. Check that AndroidManifest.xml has MY_PACKAGE_REPLACED in the intent-filter.
  </verify>
  <done>
AndroidManifest includes MY_PACKAGE_REPLACED intent filter for app update resilience. BootReceiver is still disabled by default.
  </done>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin` compiles successfully
2. BootReceiver handles both BOOT_COMPLETED and MY_PACKAGE_REPLACED
3. BootReceiver starts service AND enqueues WorkManager
4. ReticulumService schedules WorkManager regardless of transport mode
5. Service shutdown path cancels WorkManager before Reticulum.stop()
6. AndroidManifest has MY_PACKAGE_REPLACED in BootReceiver intent-filter
</verification>

<success_criteria>
- Boot receiver starts both service and WorkManager for immediate + resilient operation
- App update re-enqueues WorkManager for continuity
- Service stop cancels WorkManager (stop means stop)
- WorkManager scheduled in all modes (not just transport)
- All wiring compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-workmanager-integration/13-02-SUMMARY.md`
</output>
