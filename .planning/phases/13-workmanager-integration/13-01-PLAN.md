---
phase: 13-workmanager-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-android/src/main/kotlin/network/reticulum/android/ReticulumWorker.kt
autonomous: true

must_haves:
  truths:
    - "Worker performs interface health checks and triggers reconnection for dead connections"
    - "Worker runs Transport maintenance (path table cleanup, announce processing)"
    - "Worker checks if foreground service is alive and restarts it when auto-restart is enabled"
    - "Worker respects battery policy (skips non-critical work in MAXIMUM_BATTERY mode)"
    - "Worker runs without network connectivity constraint (mesh routing over LoRa/BLE)"
  artifacts:
    - path: "rns-android/src/main/kotlin/network/reticulum/android/ReticulumWorker.kt"
      provides: "Recovery-focused periodic worker with health checks, service restart, and battery awareness"
      contains: "doWork"
  key_links:
    - from: "ReticulumWorker.doWork()"
      to: "Transport.runMaintenanceJobs()"
      via: "direct call for path table cleanup"
      pattern: "Transport\\.runMaintenanceJobs"
    - from: "ReticulumWorker.doWork()"
      to: "Transport.getInterfaces()"
      via: "interface health check loop"
      pattern: "getInterfaces"
    - from: "ReticulumWorker.schedule()"
      to: "WorkManager.enqueueUniquePeriodicWork()"
      via: "KEEP policy for app update survival"
      pattern: "ExistingPeriodicWorkPolicy\\.KEEP"
---

<objective>
Enhance ReticulumWorker from a skeleton into a recovery-focused periodic worker that performs interface health checks, Transport maintenance, and conditional service restart.

Purpose: The foreground service runs Transport's continuous job loop (250ms). WorkManager's role is recovery when Doze suspends the service: check interface health, run accumulated maintenance, and restart the service if it was killed by the OS. This is a companion to the service, not a replacement.

Output: Enhanced ReticulumWorker.kt with health check logic, battery-aware task execution, and service restart capability.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-workmanager-integration/13-CONTEXT.md

# Existing worker (skeleton)
@rns-android/src/main/kotlin/network/reticulum/android/ReticulumWorker.kt

# Service it companions
@rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt

# Battery policy for MAXIMUM_BATTERY awareness
@rns-android/src/main/kotlin/network/reticulum/android/ConnectionPolicy.kt

# Transport maintenance entry point
# Transport.runMaintenanceJobs() does: cullTables, packetHashlistPrev.clear, saveTunnelTable
# Transport.getInterfaces() returns list of registered interfaces with online status
# Key reference: rns-core/src/main/kotlin/network/reticulum/transport/Transport.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance ReticulumWorker with recovery-focused doWork()</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ReticulumWorker.kt</files>
  <action>
Rewrite ReticulumWorker.doWork() to perform three recovery tasks in order:

**1. Interface Health Check:**
- Call `Transport.getInterfaces()` to get all registered interfaces
- For each interface, check `online` status
- Log health summary: "Interface health: X/Y online"
- Note: reconnection is handled by TCPClientInterface's built-in reconnect loop (Phase 12-04). The worker's job is just to verify and log. If Transport isn't started, skip this step entirely.

**2. Transport Maintenance:**
- Call `Transport.runMaintenanceJobs()` (already exists — path table cleanup, hashlist rotation, tunnel table save)
- This is the existing functionality, keep it
- If Transport isn't started, skip

**3. Service Health Check and Restart:**
- Check if ReticulumService is running by checking if Reticulum.isStarted()
- If NOT running, check the auto-restart preference using DataStore/SharedPreferences
  - Read "auto_start" boolean from the app's DataStore preferences
  - If auto_start is true, call ReticulumService.start(applicationContext) to restart the service
  - Log: "Service not running, auto-restart enabled — restarting"
  - If auto_start is false, log: "Service not running, auto-restart disabled — skipping"

**Battery Policy Awareness:**
- Check current battery level and charging state via BatteryManager system service
- When battery < ConnectionPolicy.BATTERY_THROTTLE_THRESHOLD (15%) AND not charging:
  - Skip interface health check (non-critical, logging only)
  - Still run Transport maintenance (important for table hygiene)
  - Still check service health (critical for recovery)
  - Log: "Low battery mode — skipping non-critical tasks"

**Important constraints from CONTEXT.md:**
- NO network connectivity constraint on the WorkRequest — Reticulum can route over non-internet transports
- Use ExistingPeriodicWorkPolicy.KEEP so work survives app updates
- Return Result.success() on normal completion, Result.retry() only on exceptions
- Add TAG logging throughout for debugging

**Do NOT change the schedule() or cancel() companion methods yet** — that wiring happens in Plan 13-02.

**Auto-restart preference approach:** Use WorkManager `inputData` to pass the "auto_restart" flag. Add an `autoRestart: Boolean = false` parameter to `schedule()` and pass it via `setInputData(workDataOf("auto_restart" to autoRestart))`. In `doWork()`, read it via `inputData.getBoolean("auto_restart", false)`. This keeps the library module independent of the app's DataStore/SharedPreferences.
  </action>
  <verify>
Build the rns-android module:
```bash
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
No compilation errors.
  </verify>
  <done>
ReticulumWorker.doWork() performs interface health check, Transport maintenance, and conditional service restart with battery awareness. Schedule method accepts autoRestart parameter. All branches have Log.i/Log.d statements.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add worker status reporting and diagnostic info</name>
  <files>rns-android/src/main/kotlin/network/reticulum/android/ReticulumWorker.kt</files>
  <action>
Add the following to ReticulumWorker for observability:

**1. Work result data:**
- On success, return Result.success(workDataOf(...)) with:
  - "interfaces_total" -> total interface count
  - "interfaces_online" -> online interface count
  - "service_running" -> whether Reticulum was started
  - "service_restarted" -> whether service was restarted this run
  - "battery_low" -> whether low battery mode was active
  - "timestamp" -> System.currentTimeMillis()

**2. Logging improvements:**
- Add a TAG constant "ReticulumWorker"
- Log at start: "Maintenance worker starting"
- Log at end: "Maintenance worker completed: X/Y interfaces online, service=$running"
- Log duration: track start time and log elapsed ms

**3. Update schedule() to not require network constraint:**
- The existing schedule() method already has no network constraint — verify this is correct per CONTEXT.md (no NetworkType constraint)
- Ensure the request has no constraints at all, matching the CONTEXT.md decision that Reticulum routes over non-internet transports

Import `androidx.work.workDataOf` for the result data builder.
  </action>
  <verify>
Build the rns-android module:
```bash
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin
```
No compilation errors.
  </verify>
  <done>
Worker reports diagnostic data on completion including interface health, service status, and timing. No network constraint on the periodic work request. Comprehensive logging throughout the worker execution.
  </done>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-android:compileDebugKotlin` compiles successfully
2. ReticulumWorker.doWork() contains interface health check, Transport maintenance, and service restart logic
3. Worker respects battery policy (skips non-critical when battery < 15% and not charging)
4. No network constraint on PeriodicWorkRequest
5. Result.success() includes diagnostic output data
</verification>

<success_criteria>
- ReticulumWorker enhanced from skeleton to full recovery-focused worker
- Three recovery tasks: interface health, Transport maintenance, service restart
- Battery-aware execution (MAXIMUM_BATTERY skips non-critical)
- No network constraint (mesh routing support)
- Diagnostic output data for monitoring
- Compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-workmanager-integration/13-01-SUMMARY.md`
</output>
