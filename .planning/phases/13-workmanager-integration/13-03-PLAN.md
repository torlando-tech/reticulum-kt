---
phase: 13-workmanager-integration
plan: 03
type: execute
wave: 2
depends_on: ["13-01", "13-02"]
files_modified:
  - rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/viewmodel/ReticulumViewModel.kt
  - rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/data/PreferencesManager.kt
autonomous: true

must_haves:
  truths:
    - "ViewModel stopService() cancels WorkManager in addition to stopping the service"
    - "ViewModel startService() enqueues WorkManager for recovery alongside the service"
    - "autoStart preference toggle enables/disables BootReceiver component at runtime"
    - "Sub-second delivery when service is active (WorkManager is backup only)"
  artifacts:
    - path: "rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/viewmodel/ReticulumViewModel.kt"
      provides: "WorkManager lifecycle wiring in ViewModel service start/stop"
      contains: "ReticulumWorker"
  key_links:
    - from: "ReticulumViewModel.stopService()"
      to: "ReticulumWorker.cancel()"
      via: "explicit WorkManager cancellation before service stop"
      pattern: "ReticulumWorker\\.cancel"
    - from: "ReticulumViewModel.startService()"
      to: "ReticulumWorker.schedule()"
      via: "WorkManager enqueue after service start"
      pattern: "ReticulumWorker\\.schedule"
    - from: "ReticulumViewModel.setAutoStart()"
      to: "PackageManager.setComponentEnabledSetting()"
      via: "enable/disable BootReceiver based on preference"
      pattern: "setComponentEnabledSetting"
---

<objective>
Wire the sample app's ViewModel to manage WorkManager lifecycle alongside service start/stop, and connect the autoStart preference to the BootReceiver component state.

Purpose: The library provides ReticulumWorker and BootReceiver. The app must wire them into its lifecycle: start enqueues the worker, stop cancels it, and the autoStart toggle controls whether BootReceiver fires on device boot.

Output: Modified ReticulumViewModel.kt with WorkManager lifecycle integration and BootReceiver component management.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-workmanager-integration/13-CONTEXT.md

# Files to modify
@rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/viewmodel/ReticulumViewModel.kt
@rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/data/PreferencesManager.kt

# Worker API (from Plan 13-01)
@rns-android/src/main/kotlin/network/reticulum/android/ReticulumWorker.kt

# BootReceiver (from Plan 13-02)
@rns-android/src/main/kotlin/network/reticulum/android/BootReceiver.kt

# Service lifecycle
@rns-android/src/main/kotlin/network/reticulum/android/ReticulumService.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire WorkManager into ViewModel service lifecycle</name>
  <files>rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/viewmodel/ReticulumViewModel.kt</files>
  <action>
Modify the ViewModel's startService() and stopService() methods:

**In startService():**
- After `ReticulumService.start(context, config)` is called, add `ReticulumWorker.schedule(context)` to enqueue the periodic maintenance worker
- This is a safety net — ReticulumService.initializeReticulum() also enqueues, but the ViewModel calling it ensures WorkManager is running even if initialization is slow
- Add import for `network.reticulum.android.ReticulumWorker`

**In stopService():**
- Before `ReticulumService.stop(context)`, add `ReticulumWorker.cancel(context)` to cancel WorkManager
- This implements "stop means stop" — no background activity after user explicitly stops
- The service's onDestroy -> shutdownReticulum path also cancels, but doing it in the ViewModel is belt-and-suspenders

**Logging:**
- Log.i when WorkManager is scheduled: "WorkManager maintenance scheduled"
- Log.i when WorkManager is cancelled: "WorkManager maintenance cancelled"

Note: The service already schedules/cancels WorkManager internally. The ViewModel wiring is defensive — it ensures the WorkManager state is correct regardless of service lifecycle timing. This is safe because schedule() uses KEEP policy (no-op if already enqueued) and cancel() is idempotent.
  </action>
  <verify>
Build the sample app:
```bash
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-sample-app:compileDebugKotlin
```
No compilation errors.
  </verify>
  <done>
ViewModel startService() enqueues WorkManager. ViewModel stopService() cancels WorkManager before stopping service. Both are defensive/idempotent alongside the service's own WorkManager management.
  </done>
</task>

<task type="auto">
  <name>Task 2: Connect autoStart preference to BootReceiver component state</name>
  <files>rns-sample-app/src/main/kotlin/tech/torlando/reticulumkt/viewmodel/ReticulumViewModel.kt</files>
  <action>
When the user toggles the autoStart preference, enable/disable the BootReceiver component dynamically:

**In setAutoStart():**
- After saving the preference via preferencesManager, use PackageManager to enable/disable the BootReceiver:

```kotlin
fun setAutoStart(enabled: Boolean) {
    viewModelScope.launch {
        preferencesManager.setAutoStart(enabled)

        // Enable/disable BootReceiver component based on preference
        val context = getApplication<Application>()
        val componentName = android.content.ComponentName(
            context,
            network.reticulum.android.BootReceiver::class.java
        )
        val newState = if (enabled) {
            android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED
        } else {
            android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED
        }
        context.packageManager.setComponentEnabledSetting(
            componentName,
            newState,
            android.content.pm.PackageManager.DONT_KILL_APP
        )
        Log.i("ReticulumViewModel", "BootReceiver ${if (enabled) "enabled" else "disabled"}")
    }
}
```

- This means when autoStart is ON:
  1. BootReceiver is enabled in the manifest at runtime
  2. On device boot, BootReceiver fires -> starts service + enqueues WorkManager
  3. Device is always-connected after boot

- When autoStart is OFF:
  1. BootReceiver is disabled — no boot-time activity
  2. User must manually start from the app

Add required imports:
- `android.util.Log`
- The ComponentName and PackageManager imports (or use fully qualified names as shown above)
  </action>
  <verify>
Build the sample app:
```bash
JAVA_HOME=~/android-studio/jbr ./gradlew :rns-sample-app:compileDebugKotlin
```
No compilation errors.
  </verify>
  <done>
autoStart toggle dynamically enables/disables BootReceiver component via PackageManager. When enabled, device boot starts service + WorkManager. When disabled, no boot-time activity.
  </done>
</task>

</tasks>

<verification>
1. `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-sample-app:compileDebugKotlin` compiles successfully
2. ViewModel.startService() enqueues WorkManager
3. ViewModel.stopService() cancels WorkManager before stopping service
4. autoStart toggle enables/disables BootReceiver component via PackageManager
5. End-to-end lifecycle: start -> schedule WorkManager, stop -> cancel WorkManager, boot -> conditional start
</verification>

<success_criteria>
- WorkManager lifecycle is managed by both ViewModel and Service (defensive/idempotent)
- autoStart preference controls BootReceiver component state at runtime
- "Stop means stop" — explicit stop cancels all background activity
- Sub-second delivery maintained when service is active (WorkManager is backup only)
- Sample app compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-workmanager-integration/13-03-SUMMARY.md`
</output>
