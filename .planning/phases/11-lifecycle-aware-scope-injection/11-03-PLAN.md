---
phase: 11-lifecycle-aware-scope-injection
plan: 03
type: execute
wave: 2
depends_on: ["11-01", "11-02"]
files_modified:
  - rns-interfaces/src/test/kotlin/network/reticulum/interfaces/ScopeInjectionTest.kt
autonomous: true

must_haves:
  truths:
    - "Service stop cancels all interface I/O coroutines within 1 second"
    - "TCP/UDP interfaces with parent scope cancel gracefully on parent cancellation"
    - "CancellationException is treated as expected (not logged as error)"
    - "Standalone interfaces (null parent) continue working independently"
  artifacts:
    - path: "rns-interfaces/src/test/kotlin/network/reticulum/interfaces/ScopeInjectionTest.kt"
      provides: "Tests verifying scope injection and cancellation behavior"
      min_lines: 100
  key_links:
    - from: "test parent scope"
      to: "interface ioScope"
      via: "cancellation propagation"
      pattern: "parentScope.*cancel.*interface"
---

<objective>
Create comprehensive tests verifying scope injection behavior for both TCPClientInterface and UDPInterface, ensuring cancellation propagates correctly and completes within the 1-second requirement.

Purpose: Validate that scope injection works correctly and meets the roadmap's 1-second cancellation requirement.
Output: Test class verifying scope propagation and graceful cancellation behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-lifecycle-aware-scope-injection/11-CONTEXT.md

# Modified interfaces (from plans 01 and 02)
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/udp/UDPInterface.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scope injection test class</name>
  <files>rns-interfaces/src/test/kotlin/network/reticulum/interfaces/ScopeInjectionTest.kt</files>
  <action>
Create new test file that validates scope injection behavior:

```kotlin
package network.reticulum.interfaces

import kotlinx.coroutines.*
import network.reticulum.interfaces.tcp.TCPClientInterface
import network.reticulum.interfaces.udp.UDPInterface
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Timeout
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean

/**
 * Tests for lifecycle-aware scope injection in TCP and UDP interfaces.
 *
 * Verifies:
 * - Parent scope cancellation propagates to interface
 * - Cancellation completes within 1 second (roadmap requirement)
 * - Standalone mode (null parent) continues working
 * - CancellationException treated as expected shutdown
 */
class ScopeInjectionTest {

    private val interfaces = mutableListOf<Interface>()

    @AfterEach
    fun cleanup() {
        interfaces.forEach {
            try { it.detach() } catch (e: Exception) { /* ignore */ }
        }
        interfaces.clear()
        Thread.sleep(100)
    }

    // ========================
    // UDP Scope Injection Tests
    // ========================

    @Test
    @Timeout(5)
    fun `UDP - standalone mode works without parent scope`() {
        // Create UDP interface without parentScope (standalone mode)
        val udp = UDPInterface(
            name = "standalone-udp",
            bindPort = 15001,
            forwardIp = "127.0.0.1",
            forwardPort = 15002
        )
        interfaces.add(udp)

        udp.start()
        assertTrue(udp.online.get(), "Should be online")

        // Explicit stop should work
        udp.stop()
        Thread.sleep(100)
        assertFalse(udp.online.get(), "Should be offline after stop")
    }

    @Test
    @Timeout(5)
    fun `UDP - parent scope cancellation stops interface`() = runBlocking {
        // Create parent scope (simulates serviceScope)
        val parentScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

        // Create UDP interface with parent scope
        val udp = UDPInterface(
            name = "child-udp",
            bindPort = 15011,
            forwardIp = "127.0.0.1",
            forwardPort = 15012,
            parentScope = parentScope
        )
        interfaces.add(udp)

        udp.start()
        assertTrue(udp.online.get(), "Should be online")

        // Cancel parent scope (simulates service stop)
        parentScope.cancel()

        // Wait for cancellation to propagate (should be quick)
        delay(500)
        assertFalse(udp.online.get(), "Should be offline after parent cancellation")
    }

    @Test
    @Timeout(2) // Strict 1-second requirement with margin
    fun `UDP - cancellation completes within 1 second`() = runBlocking {
        val parentScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

        val udp = UDPInterface(
            name = "timing-udp",
            bindPort = 15021,
            forwardIp = "127.0.0.1",
            forwardPort = 15022,
            parentScope = parentScope
        )
        interfaces.add(udp)

        udp.start()
        assertTrue(udp.online.get())

        // Measure cancellation time
        val startTime = System.currentTimeMillis()
        parentScope.cancel()

        // Poll for completion (max 1 second)
        var elapsed = 0L
        while (udp.online.get() && elapsed < 1000) {
            delay(50)
            elapsed = System.currentTimeMillis() - startTime
        }

        assertFalse(udp.online.get(), "Should be offline within 1 second")
        assertTrue(elapsed < 1000, "Cancellation took ${elapsed}ms, should be < 1000ms")
    }

    @Test
    @Timeout(5)
    fun `UDP - multiple interfaces with same parent all cancel`() = runBlocking {
        val parentScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

        // Create multiple UDP interfaces with same parent
        val udp1 = UDPInterface(
            name = "multi-udp-1",
            bindPort = 15031,
            forwardIp = "127.0.0.1",
            forwardPort = 15032,
            parentScope = parentScope
        )
        val udp2 = UDPInterface(
            name = "multi-udp-2",
            bindPort = 15033,
            forwardIp = "127.0.0.1",
            forwardPort = 15034,
            parentScope = parentScope
        )
        interfaces.add(udp1)
        interfaces.add(udp2)

        udp1.start()
        udp2.start()
        assertTrue(udp1.online.get() && udp2.online.get(), "Both should be online")

        // Cancel parent
        parentScope.cancel()
        delay(500)

        assertFalse(udp1.online.get(), "UDP1 should be offline")
        assertFalse(udp2.online.get(), "UDP2 should be offline")
    }

    // ========================
    // TCP Scope Injection Tests
    // ========================

    @Test
    @Timeout(5)
    fun `TCP - standalone mode works without parent scope`() {
        // Create TCP interface without parentScope (standalone mode)
        // Note: This won't actually connect, but verifies scope creation works
        val tcp = TCPClientInterface(
            name = "standalone-tcp",
            targetHost = "127.0.0.1",
            targetPort = 15101,
            connectTimeoutMs = 100,
            maxReconnectAttempts = 0
        )
        interfaces.add(tcp)

        // Don't start - just verify it can be created and stopped
        tcp.stop()
        // Should not throw
    }

    @Test
    @Timeout(5)
    fun `TCP - parent scope cancellation triggers cleanup`() = runBlocking {
        val parentScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

        // Create TCP with parent scope
        val tcp = TCPClientInterface(
            name = "child-tcp",
            targetHost = "127.0.0.1",
            targetPort = 15111,
            connectTimeoutMs = 100,
            maxReconnectAttempts = 0,
            parentScope = parentScope
        )
        interfaces.add(tcp)

        // Start (will try to connect and fail, but that's fine)
        tcp.start()
        delay(200) // Let it attempt connection

        // Cancel parent
        parentScope.cancel()
        delay(500)

        assertTrue(tcp.detached.get(), "Should be detached after parent cancellation")
    }

    @Test
    @Timeout(2)
    fun `TCP - cancellation completes within 1 second`() = runBlocking {
        val parentScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

        val tcp = TCPClientInterface(
            name = "timing-tcp",
            targetHost = "127.0.0.1",
            targetPort = 15121,
            connectTimeoutMs = 100,
            maxReconnectAttempts = 0,
            parentScope = parentScope
        )
        interfaces.add(tcp)

        tcp.start()
        delay(200)

        val startTime = System.currentTimeMillis()
        parentScope.cancel()

        var elapsed = 0L
        while (!tcp.detached.get() && elapsed < 1000) {
            delay(50)
            elapsed = System.currentTimeMillis() - startTime
        }

        assertTrue(tcp.detached.get(), "Should be detached within 1 second")
        assertTrue(elapsed < 1000, "Cancellation took ${elapsed}ms, should be < 1000ms")
    }

    // ========================
    // Isolation Tests (SupervisorJob)
    // ========================

    @Test
    @Timeout(5)
    fun `interfaces with same parent are isolated - one failure doesn't cancel others`() = runBlocking {
        val parentScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

        // UDP that will work
        val udp = UDPInterface(
            name = "working-udp",
            bindPort = 15201,
            forwardIp = "127.0.0.1",
            forwardPort = 15202,
            parentScope = parentScope
        )

        // TCP that will fail to connect
        val tcp = TCPClientInterface(
            name = "failing-tcp",
            targetHost = "127.0.0.1",
            targetPort = 15203,
            connectTimeoutMs = 100,
            maxReconnectAttempts = 0,
            parentScope = parentScope
        )

        interfaces.add(udp)
        interfaces.add(tcp)

        udp.start()
        tcp.start()

        // Wait for TCP to fail
        delay(500)

        // UDP should still be online despite TCP failure
        assertTrue(udp.online.get(), "UDP should remain online when sibling TCP fails")

        // Cleanup
        parentScope.cancel()
    }
}
```

Key test coverage:
- Standalone mode (null parent) works
- Parent cancellation propagates to children
- Cancellation completes within 1 second
- Multiple interfaces with same parent all cancel
- SupervisorJob isolation prevents cascading failures
  </action>
  <verify>
Run tests: `cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:test --tests "network.reticulum.interfaces.ScopeInjectionTest" --no-daemon`
  </verify>
  <done>All scope injection tests pass, verifying correct behavior</done>
</task>

<task type="auto">
  <name>Task 2: Verify all interface tests pass</name>
  <files></files>
  <action>
Run the complete rns-interfaces test suite to ensure:
1. New scope injection tests pass
2. Existing UDP tests still pass (backward compatibility)
3. Any other interface tests continue working

This is purely verification - no code changes needed.
  </action>
  <verify>
Run all interface tests: `cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:test --no-daemon`
  </verify>
  <done>All rns-interfaces tests pass (new and existing)</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. All ScopeInjectionTest tests pass
2. All UDPInterfaceTest tests pass (backward compatibility)
3. Full test suite: `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:test --no-daemon`

Phase 11 success criteria verified:
- TCP/UDP interfaces accept optional parentScope
- Parent cancellation propagates within 1 second
- Standalone mode preserved for JVM tests
- SupervisorJob isolation prevents cascading failures
</verification>

<success_criteria>
- New ScopeInjectionTest class created with 8+ tests
- All scope injection tests pass
- All existing UDP tests pass
- Cancellation timing tests verify < 1 second
- Full rns-interfaces test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-lifecycle-aware-scope-injection/11-03-SUMMARY.md`
</output>
