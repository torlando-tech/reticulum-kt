---
phase: 11-lifecycle-aware-scope-injection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt
autonomous: true

must_haves:
  truths:
    - "TCPClientInterface accepts optional parentScope parameter"
    - "When parentScope is null, interface creates standalone scope (backward compatible)"
    - "When parentScope provided, interface creates child scope that cancels when parent cancels"
    - "JVM tests continue working without modification"
  artifacts:
    - path: "rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt"
      provides: "parentScope parameter and child scope creation"
      contains: "parentScope: CoroutineScope? = null"
  key_links:
    - from: "TCPClientInterface constructor"
      to: "internal ioScope"
      via: "child scope creation with SupervisorJob"
      pattern: "parentScope.*\\+.*SupervisorJob"
---

<objective>
Add optional parentScope parameter to TCPClientInterface enabling lifecycle-aware scope injection from Android services while preserving backward compatibility for standalone JVM usage.

Purpose: Enable proper coroutine cancellation when Android service stops, preventing leaks while maintaining JVM test compatibility.
Output: TCPClientInterface with parentScope parameter and child scope creation logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-lifecycle-aware-scope-injection/11-CONTEXT.md

# Reference implementation
@rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add parentScope parameter and child scope creation</name>
  <files>rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt</files>
  <action>
Add parentScope parameter to TCPClientInterface constructor:
- Parameter: `parentScope: CoroutineScope? = null` as the LAST constructor parameter
- Position after ifacNetkey parameter (preserves existing call sites)

Replace the fixed ioScope creation:
```kotlin
// OLD:
private val ioScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

// NEW:
private val ioScope: CoroutineScope = createScope(parentScope)

private fun createScope(parent: CoroutineScope?): CoroutineScope {
    return if (parent != null) {
        // Child scope: cancels when parent cancels, but can cancel independently
        CoroutineScope(parent.coroutineContext + SupervisorJob(parent.coroutineContext[Job]) + Dispatchers.IO)
    } else {
        // Standalone scope: lives until explicitly cancelled
        CoroutineScope(SupervisorJob() + Dispatchers.IO)
    }
}
```

Key implementation details:
- SupervisorJob as parent's child enables independent cancellation
- Dispatchers.IO preserved for blocking socket operations
- Null parentScope = standalone mode (current behavior)
- Child scope pattern allows interface to cancel its own work without affecting siblings
  </action>
  <verify>
Compile check: `cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:compileKotlin --no-daemon`
  </verify>
  <done>TCPClientInterface compiles with parentScope parameter defaulting to null</done>
</task>

<task type="auto">
  <name>Task 2: Add stop() method for explicit cleanup</name>
  <files>rns-interfaces/src/main/kotlin/network/reticulum/interfaces/tcp/TCPClientInterface.kt</files>
  <action>
Add public stop() method that triggers same cleanup as scope cancellation for explicit control in JVM tests and non-Android usage:

```kotlin
/**
 * Stop the interface gracefully.
 * Cancels all coroutines and closes the socket.
 * This is the explicit cleanup path - called directly in JVM usage
 * or triggered automatically when parent scope is cancelled.
 */
fun stop() {
    detach()
}
```

The existing detach() method already:
1. Cancels readJob and connectJob
2. Cancels ioScope
3. Closes socket

The stop() method provides a cleaner API name while leveraging existing cleanup.

Also add scope cancellation listener for parent-triggered cleanup. This should be added INLINE right after ioScope is created (inside createScope or immediately after it returns), NOT in a separate init block. This avoids race conditions where the init block might run before ioScope is assigned:

```kotlin
private val ioScope: CoroutineScope = createScope(parentScope).also { scope ->
    // Listen for parent cancellation AFTER scope is created
    parentScope?.coroutineContext?.get(Job)?.invokeOnCompletion { cause ->
        if (cause != null) {
            // Parent was cancelled - trigger graceful shutdown
            detach()
        }
    }
}
```

This ensures that when the parent scope (serviceScope) is cancelled, the interface cleans up automatically. The `.also` block guarantees the listener is registered after the scope exists.
  </action>
  <verify>
Compile check: `cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:compileKotlin --no-daemon`
  </verify>
  <done>TCPClientInterface has stop() method and parent scope cancellation listener</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run compile: `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:compileKotlin --no-daemon`
2. Verify no existing tests break: `JAVA_HOME=~/android-studio/jbr ./gradlew :rns-interfaces:test --no-daemon` (may have no TCP tests currently)
3. Check that default parameter means existing callers need no changes

Expected: All existing code continues to work with new optional parameter.
</verification>

<success_criteria>
- TCPClientInterface compiles with parentScope parameter
- Default null value preserves backward compatibility
- Child scope created when parent provided
- stop() method available for explicit cleanup
- Parent scope cancellation triggers interface cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/11-lifecycle-aware-scope-injection/11-01-SUMMARY.md`
</output>
