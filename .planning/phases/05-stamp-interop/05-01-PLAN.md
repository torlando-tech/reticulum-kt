---
phase: 05-stamp-interop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/StampInteropTest.kt
autonomous: true

must_haves:
  truths:
    - "Workblock bytes generated in Kotlin match Python byte-for-byte"
    - "Stamp generated in Kotlin validates in Python"
    - "Stamp generated in Python validates in Kotlin"
    - "Stamp value computation matches between implementations"
  artifacts:
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/StampInteropTest.kt"
      provides: "Core stamp interop tests"
      contains: "class StampInteropTest"
  key_links:
    - from: "StampInteropTest.kt"
      to: "LXStamper.generateWorkblock()"
      via: "workblock generation call"
      pattern: "LXStamper\\.generateWorkblock"
    - from: "StampInteropTest.kt"
      to: "lxmf_stamp_valid"
      via: "Python bridge command"
      pattern: 'python\\("lxmf_stamp_valid"'
    - from: "StampInteropTest.kt"
      to: "lxmf_stamp_generate"
      via: "Python bridge command"
      pattern: 'python\\("lxmf_stamp_generate"'
---

<objective>
Create core stamp interoperability tests verifying bidirectional stamp generation and validation between Kotlin and Python implementations.

Purpose: Establish that stamps are fully interoperable before tackling edge cases and error conditions
Output: StampInteropTest.kt with workblock, K->P, P->K, and difficulty level tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-stamp-interop/05-CONTEXT.md
@.planning/phases/05-stamp-interop/05-RESEARCH.md
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXStamper.kt
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/LXMFInteropTestBase.kt
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/MessageHashInteropTest.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StampInteropTest with workblock verification</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/StampInteropTest.kt</files>
  <action>
Create `StampInteropTest.kt` extending `LXMFInteropTestBase` with:

1. Class structure:
```kotlin
package network.reticulum.lxmf.interop

class StampInteropTest : LXMFInteropTestBase() {
    @Nested
    @DisplayName("WorkblockGeneration")
    inner class WorkblockGeneration { ... }

    @Nested
    @DisplayName("KotlinGeneratesPythonValidates")
    inner class KotlinGeneratesPythonValidates { ... }

    @Nested
    @DisplayName("PythonGeneratesKotlinValidates")
    inner class PythonGeneratesKotlinValidates { ... }

    @Nested
    @DisplayName("DifficultyLevels")
    inner class DifficultyLevels { ... }
}
```

2. WorkblockGeneration tests:
   - `workblock matches Python for small expand rounds` - Use expandRounds=2 for speed
   - `workblock size matches expected` - Verify size = expandRounds * 256

Use `python("lxmf_stamp_workblock", "message_id" to messageId.toHex(), "expand_rounds" to expandRounds)`
Compare bytes using `assertBytesEqual` or `shouldBe` on hex strings.

Use `SecureRandom().nextBytes()` for message IDs, or `crypto.randomBytes(32)` if available via InteropTestBase.
  </action>
  <verify>
```bash
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*.StampInteropTest\$WorkblockGeneration*" -i 2>&1 | tail -50
```
Tests compile and run. Workblock bytes match between implementations.
  </verify>
  <done>WorkblockGeneration nested class has tests passing with byte-exact workblock match</done>
</task>

<task type="auto">
  <name>Task 2: Add bidirectional stamp validation tests</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/StampInteropTest.kt</files>
  <action>
Add KotlinGeneratesPythonValidates and PythonGeneratesKotlinValidates nested classes:

1. KotlinGeneratesPythonValidates:
   - `Kotlin 4-bit stamp validates in Python` - Use stampCost=4, expandRounds=25 for speed
   - `Kotlin 8-bit stamp validates in Python` - Higher cost, still reasonably fast

Pattern:
```kotlin
val messageId = ByteArray(32).also { SecureRandom().nextBytes(it) }
val workblock = LXStamper.generateWorkblock(messageId, expandRounds)
val result = runBlocking { LXStamper.generateStamp(workblock, stampCost) }

assertNotNull(result.stamp)
assertTrue(result.value >= stampCost)

val pythonResult = python(
    "lxmf_stamp_valid",
    "stamp" to result.stamp!!.toHex(),
    "target_cost" to stampCost,
    "workblock" to workblock.toHex()
)
pythonResult.getBoolean("valid") shouldBe true
```

2. PythonGeneratesKotlinValidates:
   - `Python 4-bit stamp validates in Kotlin`
   - `Python 8-bit stamp validates in Kotlin`

Pattern:
```kotlin
val messageId = ByteArray(32).also { SecureRandom().nextBytes(it) }
val expandRounds = 25

val pythonResult = python(
    "lxmf_stamp_generate",
    "message_id" to messageId.toHex(),
    "stamp_cost" to stampCost,
    "expand_rounds" to expandRounds
)

val stamp = pythonResult.getBytes("stamp")
val workblock = LXStamper.generateWorkblock(messageId, expandRounds)

LXStamper.isStampValid(stamp, stampCost, workblock) shouldBe true
```

Import `kotlinx.coroutines.runBlocking` and `java.security.SecureRandom`.
  </action>
  <verify>
```bash
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*.StampInteropTest\$KotlinGeneratesPythonValidates*" --tests "*.StampInteropTest\$PythonGeneratesKotlinValidates*" -i 2>&1 | tail -80
```
All bidirectional validation tests pass.
  </verify>
  <done>Stamps generated in either implementation validate correctly in the other</done>
</task>

<task type="auto">
  <name>Task 3: Add difficulty level and value computation tests</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/StampInteropTest.kt</files>
  <action>
Add DifficultyLevels nested class with:

1. Parameterized fast tests (0, 1, 4, 8 bits):
```kotlin
@ParameterizedTest
@ValueSource(ints = [0, 1, 4, 8])
fun `stamp at difficulty N validates in Python`(cost: Int) {
    // Generate stamp, validate in Python
}
```

2. Slow high-difficulty tests with @Tag("slow") and @Timeout:
```kotlin
@Test
@Tag("slow")
@Timeout(60, unit = TimeUnit.SECONDS)
fun `12-bit stamp validates in Python`() { ... }

@Test
@Tag("slow")
@Timeout(300, unit = TimeUnit.SECONDS)
fun `16-bit stamp validates in Python`() { ... }
```

3. Stamp value computation test:
```kotlin
@Test
fun `stamp value matches Python computation`() {
    val messageId = ...
    val workblock = LXStamper.generateWorkblock(messageId, 25)
    val result = runBlocking { LXStamper.generateStamp(workblock, 4) }

    val kotlinValue = LXStamper.stampValue(workblock, result.stamp!!)

    val pythonResult = python(
        "lxmf_stamp_valid",
        "stamp" to result.stamp!!.toHex(),
        "target_cost" to 0,  // Any cost to get value back
        "workblock" to workblock.toHex()
    )

    val pythonValue = pythonResult.getInt("value")
    kotlinValue shouldBe pythonValue
}
```

Import `java.util.concurrent.TimeUnit`, `org.junit.jupiter.api.Tag`, `org.junit.jupiter.api.Timeout`.
  </action>
  <verify>
```bash
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*.StampInteropTest\$DifficultyLevels*" -PexcludeTags=slow -i 2>&1 | tail -80
```
Fast difficulty tests pass. Slow tests are excluded but compile.
  </verify>
  <done>DifficultyLevels tests cover 0-8 bit fast tests, 12-16 bit slow tests tagged, stamp value matches</done>
</task>

</tasks>

<verification>
```bash
# Run all StampInteropTest tests (excluding slow)
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*.StampInteropTest*" -PexcludeTags=slow -i 2>&1 | tail -100
```

Expected: All tests pass. Workblock generation byte-exact, stamps validate bidirectionally, stamp values match.
</verification>

<success_criteria>
- StampInteropTest.kt exists with WorkblockGeneration, KotlinGeneratesPythonValidates, PythonGeneratesKotlinValidates, DifficultyLevels nested classes
- Workblock bytes match between Kotlin and Python
- Kotlin stamps validate in Python
- Python stamps validate in Kotlin
- Stamp value computation matches
- Slow tests are tagged and have timeouts
- All non-slow tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-stamp-interop/05-01-SUMMARY.md`
</output>
