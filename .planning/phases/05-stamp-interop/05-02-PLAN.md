---
phase: 05-stamp-interop
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/StampInteropTest.kt
autonomous: true

must_haves:
  truths:
    - "Invalid stamps are rejected by both Kotlin and Python"
    - "Corrupted stamps fail validation in both implementations"
    - "Wrong workblock (message hash) causes stamp rejection"
    - "Over-qualified stamps (higher value than required) are accepted"
  artifacts:
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/StampInteropTest.kt"
      provides: "Invalid stamp rejection and edge case tests"
      contains: "inner class InvalidStampRejection"
  key_links:
    - from: "StampInteropTest.kt"
      to: "LXStamper.isStampValid()"
      via: "validation call with invalid stamp"
      pattern: "isStampValid.*shouldBe false"
    - from: "StampInteropTest.kt"
      to: "lxmf_stamp_valid"
      via: "Python validation of invalid stamps"
      pattern: 'python\\("lxmf_stamp_valid".*valid.*shouldBe false'
---

<objective>
Add edge case and invalid stamp rejection tests to StampInteropTest.

Purpose: Verify security-critical rejection behavior matches between implementations
Output: InvalidStampRejection and EdgeCases nested classes in StampInteropTest.kt
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-stamp-interop/05-CONTEXT.md
@.planning/phases/05-stamp-interop/05-RESEARCH.md
@.planning/phases/05-stamp-interop/05-01-SUMMARY.md
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXStamper.kt
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/StampInteropTest.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add InvalidStampRejection tests</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/StampInteropTest.kt</files>
  <action>
Add InvalidStampRejection nested class with comprehensive invalid stamp tests:

```kotlin
@Nested
@DisplayName("InvalidStampRejection")
inner class InvalidStampRejection {

    @Test
    fun `wrong difficulty rejected by both implementations`() {
        // Generate 4-bit stamp, try to validate as 8-bit
        val messageId = ByteArray(32).also { SecureRandom().nextBytes(it) }
        val workblock = LXStamper.generateWorkblock(messageId, 25)
        val stamp = runBlocking { LXStamper.generateStamp(workblock, 4) }.stamp!!

        // Kotlin rejects
        LXStamper.isStampValid(stamp, 8, workblock) shouldBe false

        // Python also rejects
        val pythonResult = python(
            "lxmf_stamp_valid",
            "stamp" to stamp.toHex(),
            "target_cost" to 8,
            "workblock" to workblock.toHex()
        )
        pythonResult.getBoolean("valid") shouldBe false
    }

    @Test
    fun `corrupted stamp rejected by both implementations`() {
        // Generate valid stamp, corrupt one byte
        val messageId = ByteArray(32).also { SecureRandom().nextBytes(it) }
        val workblock = LXStamper.generateWorkblock(messageId, 25)
        val validStamp = runBlocking { LXStamper.generateStamp(workblock, 4) }.stamp!!
        val corruptedStamp = validStamp.copyOf()
        corruptedStamp[0] = (corruptedStamp[0].toInt() xor 0xFF).toByte()

        // Kotlin rejects
        LXStamper.isStampValid(corruptedStamp, 4, workblock) shouldBe false

        // Python also rejects
        val pythonResult = python(
            "lxmf_stamp_valid",
            "stamp" to corruptedStamp.toHex(),
            "target_cost" to 4,
            "workblock" to workblock.toHex()
        )
        pythonResult.getBoolean("valid") shouldBe false
    }

    @Test
    fun `wrong workblock (message hash) rejected by both implementations`() {
        // Generate stamp for message A, validate against workblock for message B
        val messageIdA = ByteArray(32).also { SecureRandom().nextBytes(it) }
        val messageIdB = ByteArray(32).also { SecureRandom().nextBytes(it) }
        val workblockA = LXStamper.generateWorkblock(messageIdA, 25)
        val workblockB = LXStamper.generateWorkblock(messageIdB, 25)
        val stampForA = runBlocking { LXStamper.generateStamp(workblockA, 4) }.stamp!!

        // Kotlin rejects with wrong workblock
        LXStamper.isStampValid(stampForA, 4, workblockB) shouldBe false

        // Python also rejects with wrong workblock
        val pythonResult = python(
            "lxmf_stamp_valid",
            "stamp" to stampForA.toHex(),
            "target_cost" to 4,
            "workblock" to workblockB.toHex()
        )
        pythonResult.getBoolean("valid") shouldBe false
    }

    @Test
    fun `truncated stamp rejected by Kotlin`() {
        val messageId = ByteArray(32).also { SecureRandom().nextBytes(it) }
        val workblock = LXStamper.generateWorkblock(messageId, 25)
        val truncatedStamp = ByteArray(16) // Should be 32

        // validateStamp checks size first
        LXStamper.validateStamp(truncatedStamp, messageId, 4, 25) shouldBe false
    }

    @Test
    fun `empty stamp rejected by Kotlin`() {
        val messageId = ByteArray(32).also { SecureRandom().nextBytes(it) }
        val emptyStamp = ByteArray(0)

        LXStamper.validateStamp(emptyStamp, messageId, 4, 25) shouldBe false
    }

    @Test
    fun `random bytes rejected as stamp by both implementations`() {
        val messageId = ByteArray(32).also { SecureRandom().nextBytes(it) }
        val workblock = LXStamper.generateWorkblock(messageId, 25)
        val randomBytes = ByteArray(32).also { SecureRandom().nextBytes(it) }

        // Random bytes very unlikely to be valid at cost >= 1
        // (probability 2^-cost that random bytes pass)
        LXStamper.isStampValid(randomBytes, 8, workblock) shouldBe false

        val pythonResult = python(
            "lxmf_stamp_valid",
            "stamp" to randomBytes.toHex(),
            "target_cost" to 8,
            "workblock" to workblock.toHex()
        )
        pythonResult.getBoolean("valid") shouldBe false
    }
}
```

Print diagnostic messages for each test showing what's being validated.
  </action>
  <verify>
```bash
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*.StampInteropTest\$InvalidStampRejection*" -i 2>&1 | tail -80
```
All invalid stamp rejection tests pass.
  </verify>
  <done>InvalidStampRejection nested class tests pass - both implementations reject the same invalid stamps</done>
</task>

<task type="auto">
  <name>Task 2: Add EdgeCases tests including over-qualified stamps</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/StampInteropTest.kt</files>
  <action>
Add EdgeCases nested class:

```kotlin
@Nested
@DisplayName("EdgeCases")
inner class EdgeCases {

    @Test
    fun `over-qualified stamp (higher value than required) accepted by both`() {
        // Generate 8-bit stamp, validate at 4-bit cost (should pass)
        val messageId = ByteArray(32).also { SecureRandom().nextBytes(it) }
        val workblock = LXStamper.generateWorkblock(messageId, 25)
        val result = runBlocking { LXStamper.generateStamp(workblock, 8) }

        println("Generated stamp with value=${result.value}, testing at cost=4")
        assertTrue(result.value >= 8, "Stamp value should be at least 8")

        // Kotlin accepts at lower cost
        LXStamper.isStampValid(result.stamp!!, 4, workblock) shouldBe true

        // Python also accepts at lower cost
        val pythonResult = python(
            "lxmf_stamp_valid",
            "stamp" to result.stamp!!.toHex(),
            "target_cost" to 4,
            "workblock" to workblock.toHex()
        )
        pythonResult.getBoolean("valid") shouldBe true
    }

    @Test
    fun `difficulty 0 stamp is trivially valid`() {
        // Any stamp should be valid at cost 0
        val messageId = ByteArray(32).also { SecureRandom().nextBytes(it) }
        val workblock = LXStamper.generateWorkblock(messageId, 25)
        val randomStamp = ByteArray(32).also { SecureRandom().nextBytes(it) }

        // Kotlin accepts at cost 0
        LXStamper.isStampValid(randomStamp, 0, workblock) shouldBe true

        // Python also accepts at cost 0
        val pythonResult = python(
            "lxmf_stamp_valid",
            "stamp" to randomStamp.toHex(),
            "target_cost" to 0,
            "workblock" to workblock.toHex()
        )
        pythonResult.getBoolean("valid") shouldBe true
    }

    @Test
    fun `stamp value is consistent across multiple validations`() {
        val messageId = ByteArray(32).also { SecureRandom().nextBytes(it) }
        val workblock = LXStamper.generateWorkblock(messageId, 25)
        val result = runBlocking { LXStamper.generateStamp(workblock, 4) }

        // Multiple calls should return same value
        val value1 = LXStamper.stampValue(workblock, result.stamp!!)
        val value2 = LXStamper.stampValue(workblock, result.stamp!!)
        val value3 = LXStamper.stampValue(workblock, result.stamp!!)

        value1 shouldBe value2
        value2 shouldBe value3

        println("Stamp value consistently computed as $value1")
    }

    @Test
    fun `different expand rounds produce different workblocks`() {
        val messageId = ByteArray(32).also { SecureRandom().nextBytes(it) }

        val workblock25 = LXStamper.generateWorkblock(messageId, 25)
        val workblock50 = LXStamper.generateWorkblock(messageId, 50)

        workblock25.size shouldBe 25 * 256
        workblock50.size shouldBe 50 * 256

        // First 25*256 bytes should match (same material, same first 25 rounds)
        workblock25.toList() shouldBe workblock50.take(25 * 256)
    }
}
```

These tests verify edge cases from CONTEXT.md:
- Over-qualified stamps accepted
- Difficulty 0 edge case
- Value computation consistency
- Workblock size and composition
  </action>
  <verify>
```bash
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*.StampInteropTest\$EdgeCases*" -i 2>&1 | tail -80
```
All edge case tests pass.
  </verify>
  <done>EdgeCases tests pass - over-qualified stamps accepted, difficulty 0 works, value computation consistent</done>
</task>

</tasks>

<verification>
```bash
# Run all StampInteropTest tests (excluding slow)
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*.StampInteropTest*" -PexcludeTags=slow -i 2>&1 | tail -100

# Verify test count
cd ~/repos/public/reticulum-kt && ./gradlew :lxmf-core:test --tests "*.StampInteropTest*" -PexcludeTags=slow --info 2>&1 | grep -E "(PASSED|FAILED|tests)"
```

Expected: All tests pass. InvalidStampRejection tests confirm both implementations reject same invalid stamps. EdgeCases tests confirm over-qualified stamps work.
</verification>

<success_criteria>
- InvalidStampRejection nested class exists with: wrong difficulty, corrupted, wrong workblock, truncated, empty, random bytes tests
- EdgeCases nested class exists with: over-qualified, difficulty 0, value consistency, expand rounds tests
- All invalid stamps rejected by both Kotlin and Python
- Over-qualified stamps (8-bit tested as 4-bit) accepted by both
- Difficulty 0 accepts any stamp
- All non-slow tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-stamp-interop/05-02-SUMMARY.md`
</output>
