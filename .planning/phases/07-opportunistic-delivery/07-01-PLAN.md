---
phase: 07-opportunistic-delivery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt
autonomous: true

must_haves:
  truths:
    - "PATHLESS_DELIVERY_ATTEMPTS constant renamed to MAX_PATHLESS_TRIES with value 1"
    - "Opportunistic delivery requests path when no path exists after MAX_PATHLESS_TRIES attempts"
    - "Opportunistic delivery rediscovers path at MAX_PATHLESS_TRIES+1 attempt if path exists but delivery fails"
  artifacts:
    - path: "lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt"
      provides: "Aligned opportunistic delivery constants and logic"
      contains: "MAX_PATHLESS_TRIES = 1"
  key_links:
    - from: "processOpportunisticDelivery"
      to: "Transport.hasPath / Transport.requestPath"
      via: "path request logic matching Python"
      pattern: "MAX_PATHLESS_TRIES"
---

<objective>
Align Kotlin LXMRouter opportunistic delivery constants and logic with Python LXMF reference implementation.

Purpose: Ensure Kotlin opportunistic delivery behavior matches Python exactly - same retry timing, same path request logic, same failure semantics. This is required before testing can verify interoperability.

Output: LXMRouter.kt with corrected constants and enhanced processOpportunisticDelivery() matching Python's outbound processing logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-opportunistic-delivery/07-RESEARCH.md

# Python reference implementation
@~/repos/LXMF/LXMF/LXMRouter.py (lines 2554-2581 for opportunistic logic)

# Current Kotlin implementation
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Align constants with Python LXMF reference</name>
  <files>lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt</files>
  <action>
  Update the companion object constants to match Python LXMRouter exactly:

  1. Rename `PATHLESS_DELIVERY_ATTEMPTS = 3` to `MAX_PATHLESS_TRIES = 1`
     - Python uses: `MAX_PATHLESS_TRIES = 1`
     - This is the number of delivery attempts allowed WITHOUT a path before requesting one

  2. Verify existing constants match Python:
     - MAX_DELIVERY_ATTEMPTS = 5 (correct)
     - DELIVERY_RETRY_WAIT = 10000L (correct, Python uses 10 seconds)
     - PATH_REQUEST_WAIT = 7000L (correct, Python uses 7 seconds)

  3. Update any references to PATHLESS_DELIVERY_ATTEMPTS to use MAX_PATHLESS_TRIES

  Note: handleDeliveryAnnounce already correctly sets nextDeliveryAttempt to now and triggers processOutbound() - no changes needed there.
  </action>
  <verify>
  ```bash
  cd ~/repos/public/reticulum-kt && grep -n "MAX_PATHLESS_TRIES\|PATHLESS_DELIVERY" lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt
  ```
  Should show MAX_PATHLESS_TRIES = 1 and no PATHLESS_DELIVERY_ATTEMPTS references.
  </verify>
  <done>Constant renamed from PATHLESS_DELIVERY_ATTEMPTS to MAX_PATHLESS_TRIES with value 1, matching Python</done>
</task>

<task type="auto">
  <name>Task 2: Enhance processOpportunisticDelivery with Python path logic</name>
  <files>lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMRouter.kt</files>
  <action>
  Rewrite processOpportunisticDelivery() to match Python's opportunistic outbound handling (lines 2554-2581).

  Current simplified logic:
  ```kotlin
  private suspend fun processOpportunisticDelivery(message: LXMessage) {
      message.deliveryAttempts++
      if (message.deliveryAttempts > MAX_DELIVERY_ATTEMPTS) {
          message.state = MessageState.FAILED
          return
      }
      val sent = sendOpportunisticMessage(message)
      if (sent) {
          message.state = MessageState.SENT
      } else {
          message.nextDeliveryAttempt = System.currentTimeMillis() + DELIVERY_RETRY_WAIT
      }
  }
  ```

  Replace with Python-aligned logic:
  ```kotlin
  private suspend fun processOpportunisticDelivery(message: LXMessage) {
      if (message.deliveryAttempts > MAX_DELIVERY_ATTEMPTS) {
          // Max attempts reached - fail the message
          message.state = MessageState.FAILED
          message.failedCallback?.invoke(message)
          return
      }

      val dest = message.destination
      if (dest == null) {
          // No destination, can't check path
          message.nextDeliveryAttempt = System.currentTimeMillis() + DELIVERY_RETRY_WAIT
          return
      }

      val hasPath = Transport.hasPath(dest.hash)

      when {
          // After MAX_PATHLESS_TRIES attempts without path, request path
          message.deliveryAttempts >= MAX_PATHLESS_TRIES && !hasPath -> {
              message.deliveryAttempts++
              Transport.requestPath(dest.hash)
              message.nextDeliveryAttempt = System.currentTimeMillis() + PATH_REQUEST_WAIT
          }

          // At MAX_PATHLESS_TRIES+1 with path but still failing, rediscover path
          message.deliveryAttempts == MAX_PATHLESS_TRIES + 1 && hasPath -> {
              message.deliveryAttempts++
              // Drop existing path and re-request (Python does this via Reticulum.drop_path + request_path)
              Reticulum.instance?.dropPath(dest.hash)
              // Small delay then request new path (matching Python's 0.5s sleep in thread)
              processingScope?.launch {
                  delay(500)
                  Transport.requestPath(dest.hash)
              }
              message.nextDeliveryAttempt = System.currentTimeMillis() + PATH_REQUEST_WAIT
          }

          // Normal delivery attempt
          else -> {
              val now = System.currentTimeMillis()
              if (message.nextDeliveryAttempt == 0L || now > message.nextDeliveryAttempt) {
                  message.deliveryAttempts++
                  message.nextDeliveryAttempt = now + DELIVERY_RETRY_WAIT

                  val sent = sendOpportunisticMessage(message)
                  if (sent) {
                      message.state = MessageState.SENT
                      message.method = DeliveryMethod.OPPORTUNISTIC
                  }
              }
          }
      }
  }
  ```

  Key differences from current implementation:
  1. Check delivery attempts BEFORE incrementing (matching Python's `<=` check)
  2. Check Transport.hasPath() before sending
  3. Request path after MAX_PATHLESS_TRIES attempts with no path
  4. Rediscover path at attempt MAX_PATHLESS_TRIES+1 if path exists but delivery fails
  5. Only increment attempts when actually doing something (send, request path, or rediscover)
  6. Check nextDeliveryAttempt timing before sending

  Note: If Reticulum.dropPath doesn't exist, add a TODO comment - the main path request logic is more important.
  </action>
  <verify>
  ```bash
  cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:compileKotlin 2>&1 | tail -20
  ```
  Should compile without errors.
  </verify>
  <done>processOpportunisticDelivery enhanced with path request logic matching Python: request path after MAX_PATHLESS_TRIES, rediscover at MAX_PATHLESS_TRIES+1</done>
</task>

</tasks>

<verification>
1. Constant change verified:
   - `grep MAX_PATHLESS_TRIES LXMRouter.kt` shows value = 1
   - No references to old PATHLESS_DELIVERY_ATTEMPTS name

2. Logic paths verified in code:
   - Path request at deliveryAttempts >= MAX_PATHLESS_TRIES when !hasPath
   - Path rediscovery at deliveryAttempts == MAX_PATHLESS_TRIES+1 when hasPath
   - Normal send with nextDeliveryAttempt timing check

3. Project compiles:
   - `./gradlew :lxmf-core:compileKotlin` succeeds
</verification>

<success_criteria>
- MAX_PATHLESS_TRIES = 1 constant exists (renamed from PATHLESS_DELIVERY_ATTEMPTS = 3)
- processOpportunisticDelivery has path request logic matching Python
- Code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-opportunistic-delivery/07-01-SUMMARY.md`
</output>
