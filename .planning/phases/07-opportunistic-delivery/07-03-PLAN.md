---
phase: 07-opportunistic-delivery
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/KotlinToPythonOpportunisticTest.kt
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PythonToKotlinOpportunisticTest.kt
autonomous: true

must_haves:
  truths:
    - "Multiple messages to same destination delivered in order after announce"
    - "Failed delivery after max attempts triggers failure callback"
    - "Python can send opportunistic message to Kotlin"
    - "Message content and fields preserved after opportunistic delivery"
  artifacts:
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/KotlinToPythonOpportunisticTest.kt"
      provides: "Extended K->P opportunistic tests including batch and timeout"
      contains: "batch delivery"
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PythonToKotlinOpportunisticTest.kt"
      provides: "Python to Kotlin opportunistic delivery tests"
      contains: "Python.*opportunistic.*Kotlin"
  key_links:
    - from: "batch delivery test"
      to: "handleDeliveryAnnounce"
      via: "all queued messages delivered"
      pattern: "multiple.*messages.*announce"
    - from: "PythonToKotlinOpportunisticTest"
      to: "kotlinRouter.inboundCallback"
      via: "message reception"
      pattern: "receivedMessages"
---

<objective>
Complete opportunistic delivery test coverage with batch delivery, timeout failure, and bidirectional Python-to-Kotlin tests.

Purpose: Verify full opportunistic delivery behavior including edge cases (batch, timeout) and bidirectional interoperability (Python sending to Kotlin). This provides comprehensive coverage per CONTEXT.md requirements.

Output: Extended KotlinToPythonOpportunisticTest with batch/timeout tests, plus new PythonToKotlinOpportunisticTest.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-opportunistic-delivery/07-CONTEXT.md
@.planning/phases/07-opportunistic-delivery/07-02-SUMMARY.md

# Existing test files
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/OpportunisticDeliveryTestBase.kt
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/KotlinToPythonOpportunisticTest.kt
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PythonToKotlinDirectTest.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add batch delivery and timeout tests to KotlinToPythonOpportunisticTest</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/KotlinToPythonOpportunisticTest.kt</files>
  <action>
  Add two additional tests to KotlinToPythonOpportunisticTest:

  1. **Batch delivery test** - Multiple messages to same destination all delivered after announce:
  ```kotlin
  @Test
  @Timeout(60, unit = TimeUnit.SECONDS)
  fun `batch delivery - multiple messages delivered after single announce`() = runBlocking {
      clearPythonMessages()

      // Queue multiple messages BEFORE Python announces
      val messages = listOf(
          createOpportunisticMessage("Message 1", "Batch Test 1"),
          createOpportunisticMessage("Message 2", "Batch Test 2"),
          createOpportunisticMessage("Message 3", "Batch Test 3")
      )

      val deliveryCount = AtomicInteger(0)
      messages.forEach { msg ->
          msg.deliveryCallback = { deliveryCount.incrementAndGet() }
          kotlinRouter.handleOutbound(msg)
      }

      delay(2000) // Allow queue processing

      // Verify none delivered yet
      getPythonMessages().size shouldBe 0

      // Trigger announce - should deliver ALL queued messages
      triggerPythonAnnounce()

      // Wait for all messages
      val allDelivered = withTimeoutOrNull(30.seconds) {
          while (getPythonMessages().size < 3) {
              delay(200)
          }
          true
      } ?: false

      allDelivered shouldBe true

      val pythonMessages = getPythonMessages()
      pythonMessages.size shouldBe 3

      // Verify content (order may vary due to async processing)
      val contents = pythonMessages.map { it.content }.toSet()
      contents shouldContain "Message 1"
      contents shouldContain "Message 2"
      contents shouldContain "Message 3"
  }
  ```

  2. **Timeout failure test** - Message fails after max attempts to unreachable destination:
  ```kotlin
  @Test
  @Timeout(120, unit = TimeUnit.SECONDS)  // Long timeout for failure scenario
  fun `delivery failure after max attempts triggers callback`() = runBlocking {
      // Create message to a destination that will never respond
      // We'll create a fake identity/destination that doesn't exist
      val fakeIdentity = Identity.create()
      val fakeDest = Destination.create(
          identity = fakeIdentity,
          direction = DestinationDirection.OUT,
          type = DestinationType.SINGLE,
          appName = "lxmf",
          "delivery"
      )

      val message = LXMessage.create(
          destination = fakeDest,
          source = kotlinDestination,
          content = "This should fail",
          title = "Failure Test",
          desiredMethod = DeliveryMethod.OPPORTUNISTIC
      )

      val failedFired = AtomicBoolean(false)
      message.failedCallback = { failedFired.set(true) }

      kotlinRouter.handleOutbound(message)

      // Wait for failure (5 attempts * ~10s each + path request waits)
      // This could take up to 50+ seconds per CONTEXT.md
      val failed = withTimeoutOrNull(90.seconds) {
          while (!failedFired.get() && message.state != MessageState.FAILED) {
              delay(1000)
          }
          true
      } ?: false

      // Verify failure
      if (!failed) {
          println("[Test] Timeout waiting for failure, state=${message.state}, attempts=${message.deliveryAttempts}")
      }

      // Either callback fired or state is FAILED
      val failureDetected = failedFired.get() || message.state == MessageState.FAILED
      failureDetected shouldBe true
  }
  ```

  Add required import:
  ```kotlin
  import java.util.concurrent.atomic.AtomicInteger
  ```
  </action>
  <verify>
  ```bash
  cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "KotlinToPythonOpportunisticTest.batch*" 2>&1 | tail -20
  ```
  Batch test should pass.
  </verify>
  <done>Batch delivery test and timeout failure test added to KotlinToPythonOpportunisticTest</done>
</task>

<task type="auto">
  <name>Task 2: Create PythonToKotlinOpportunisticTest</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PythonToKotlinOpportunisticTest.kt</files>
  <action>
  Create test class for Python to Kotlin opportunistic delivery. This verifies bidirectional interoperability.

  Pattern from PythonToKotlinDirectTest but adapted for opportunistic:
  ```kotlin
  package network.reticulum.lxmf.interop

  import io.kotest.matchers.collections.shouldContain
  import io.kotest.matchers.shouldBe
  import io.kotest.matchers.shouldNotBe
  import kotlinx.coroutines.delay
  import kotlinx.coroutines.runBlocking
  import kotlinx.coroutines.withTimeoutOrNull
  import network.reticulum.lxmf.LXMFConstants
  import network.reticulum.lxmf.LXMessage
  import network.reticulum.lxmf.MessageState
  import org.junit.jupiter.api.Test
  import org.junit.jupiter.api.Timeout
  import java.util.concurrent.CopyOnWriteArrayList
  import java.util.concurrent.TimeUnit
  import kotlin.time.Duration.Companion.seconds

  /**
   * Tests for Python to Kotlin OPPORTUNISTIC delivery.
   *
   * These tests verify that Python LXMF can send opportunistic messages to Kotlin,
   * ensuring bidirectional interoperability.
   */
  class PythonToKotlinOpportunisticTest : OpportunisticDeliveryTestBase() {

      private val receivedMessages = CopyOnWriteArrayList<LXMessage>()

      override var skipInitialAnnounce = false  // Python CAN announce, we test Kotlin not announcing

      @Test
      @Timeout(60, unit = TimeUnit.SECONDS)
      fun `Python opportunistic message received by Kotlin after Kotlin announces`() = runBlocking {
          receivedMessages.clear()

          // Set up Kotlin to receive messages
          kotlinRouter.setMessageCallback { message ->
              println("[Test] Kotlin received message: ${message.content}")
              receivedMessages.add(message)
          }

          // Initially, Python doesn't know path to Kotlin (we haven't announced)
          // Note: We need to NOT announce Kotlin initially, then announce

          // Actually, for P2K we need different setup:
          // - Python sends to Kotlin destination
          // - Kotlin must announce for Python to know path
          // - Then Python can send opportunistic

          // Step 1: Kotlin announces so Python knows the path
          println("[Test] Kotlin announcing destination...")
          announceKotlinDestination()
          delay(2000)

          // Step 2: Tell Python to send opportunistic message to Kotlin
          val kotlinDestHashHex = kotlinDestination.hexHash
          println("[Test] Asking Python to send opportunistic to Kotlin dest: $kotlinDestHashHex")

          // Use bridge command for Python to send LXMF message
          // Need to add this to Python bridge if not exists
          val sendResult = python(
              "lxmf_send_opportunistic",
              "destination_hash" to kotlinDestHashHex,
              "content" to "Hello from Python opportunistic!",
              "title" to "P2K Opportunistic"
          )

          println("[Test] Python send result: $sendResult")

          // Wait for Kotlin to receive
          val received = withTimeoutOrNull(30.seconds) {
              while (receivedMessages.isEmpty()) {
                  delay(200)
              }
              true
          } ?: false

          if (!received) {
              println("[Test] Timeout waiting for message, received count: ${receivedMessages.size}")
          }

          received shouldBe true
          receivedMessages.size shouldBe 1
          receivedMessages[0].content shouldBe "Hello from Python opportunistic!"
      }

      @Test
      @Timeout(60, unit = TimeUnit.SECONDS)
      fun `Python opportunistic message with fields preserved`() = runBlocking {
          receivedMessages.clear()

          kotlinRouter.setMessageCallback { message ->
              receivedMessages.add(message)
          }

          // Kotlin announces
          announceKotlinDestination()
          delay(2000)

          val kotlinDestHashHex = kotlinDestination.hexHash

          // Python sends with custom fields
          val sendResult = python(
              "lxmf_send_opportunistic",
              "destination_hash" to kotlinDestHashHex,
              "content" to "Message with fields",
              "title" to "Fields Test",
              "fields" to mapOf(
                  LXMFConstants.FIELD_COMMANDS.toString() to "test_command"
              )
          )

          println("[Test] Python send result: $sendResult")

          // Wait for reception
          val received = withTimeoutOrNull(30.seconds) {
              while (receivedMessages.isEmpty()) {
                  delay(200)
              }
              true
          } ?: false

          received shouldBe true
          receivedMessages[0].content shouldBe "Message with fields"

          // Verify field if accessible
          val fields = receivedMessages[0].fields
          if (fields != null && fields.isNotEmpty()) {
              println("[Test] Received fields: $fields")
          }
      }
  }
  ```

  Note: This requires adding `lxmf_send_opportunistic` command to Python bridge.
  If the command doesn't exist, the test will fail with a clear error indicating we need to extend the bridge.

  Add to Python bridge (lxmf_bridge.py) the lxmf_send_opportunistic command if needed:
  ```python
  elif cmd == "lxmf_send_opportunistic":
      dest_hash = bytes.fromhex(params["destination_hash"])
      content = params.get("content", "")
      title = params.get("title", "")
      fields = params.get("fields", {})

      # Create destination from hash
      dest_identity = RNS.Identity.recall(dest_hash)
      if not dest_identity:
          return {"error": "Unknown destination identity"}

      dest = RNS.Destination(dest_identity, RNS.Destination.OUT, RNS.Destination.SINGLE, "lxmf", "delivery")

      # Create and send message
      lxm = LXMF.LXMessage(dest, lxmf_router.identity, content, title=title, desired_method=LXMF.LXMessage.OPPORTUNISTIC)
      if fields:
          for k, v in fields.items():
              lxm.fields[int(k)] = v

      lxmf_router.handle_outbound(lxm)
      return {"sent": True, "hash": lxm.hash.hex() if lxm.hash else None}
  ```
  </action>
  <verify>
  ```bash
  cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "PythonToKotlinOpportunisticTest" 2>&1 | tail -30
  ```
  Tests should run (may fail if bridge command missing - that's expected and indicates what to add).
  </verify>
  <done>PythonToKotlinOpportunisticTest created with bidirectional opportunistic delivery tests</done>
</task>

<task type="auto">
  <name>Task 3: Add lxmf_send_opportunistic to Python bridge if needed</name>
  <files>rns-core/src/test/resources/lxmf_bridge.py</files>
  <action>
  Check if lxmf_send_opportunistic command exists in lxmf_bridge.py. If not, add it:

  1. First check: `grep "lxmf_send_opportunistic" rns-core/src/test/resources/lxmf_bridge.py`

  2. If missing, add the command handler near other lxmf_* commands:

  ```python
  elif cmd == "lxmf_send_opportunistic":
      try:
          dest_hash_hex = params.get("destination_hash")
          if not dest_hash_hex:
              return {"error": "destination_hash required"}

          dest_hash = bytes.fromhex(dest_hash_hex)
          content = params.get("content", "")
          title = params.get("title", "")
          fields = params.get("fields", {})

          # Recall identity from destination hash
          dest_identity = RNS.Identity.recall(dest_hash)
          if not dest_identity:
              return {"error": f"Cannot recall identity for {dest_hash_hex}"}

          # Create outbound destination
          dest = RNS.Destination(
              dest_identity,
              RNS.Destination.OUT,
              RNS.Destination.SINGLE,
              "lxmf", "delivery"
          )

          # Create LXMF message with OPPORTUNISTIC method
          lxm = LXMF.LXMessage(
              dest,
              lxmf_router.identity,
              content,
              title=title,
              desired_method=LXMF.LXMessage.OPPORTUNISTIC
          )

          # Add fields if provided
          if fields:
              for k, v in fields.items():
                  field_key = int(k) if isinstance(k, str) else k
                  lxm.fields[field_key] = v

          # Handle outbound
          lxmf_router.handle_outbound(lxm)

          return {
              "sent": True,
              "message_hash": lxm.hash.hex() if lxm.hash else None,
              "method": "opportunistic"
          }
      except Exception as e:
          return {"error": str(e)}
  ```

  This command:
  - Takes destination_hash (hex), content, title, and optional fields
  - Recalls the identity for the destination
  - Creates an OPPORTUNISTIC LXMessage
  - Calls handle_outbound to queue/send it
  </action>
  <verify>
  ```bash
  cd ~/repos/public/reticulum-kt && grep -A 30 "lxmf_send_opportunistic" rns-core/src/test/resources/lxmf_bridge.py | head -35
  ```
  Should show the command handler.
  </verify>
  <done>lxmf_send_opportunistic command added to Python bridge for P2K opportunistic testing</done>
</task>

</tasks>

<verification>
1. Batch delivery test passes:
   - Multiple messages queued
   - Single announce delivers all
   - All message contents received

2. Timeout failure test:
   - Message to unreachable destination fails after max attempts
   - Failure callback fires or state becomes FAILED

3. Python to Kotlin tests:
   - Python can send opportunistic message to Kotlin
   - Kotlin receives message with content preserved
   - Fields preserved (if applicable)
</verification>

<success_criteria>
- KotlinToPythonOpportunisticTest has batch and timeout tests
- PythonToKotlinOpportunisticTest exists with bidirectional tests
- Python bridge has lxmf_send_opportunistic command
- Tests pass or fail with clear issues (not compilation errors)
</success_criteria>

<output>
After completion, create `.planning/phases/07-opportunistic-delivery/07-03-SUMMARY.md`
</output>
