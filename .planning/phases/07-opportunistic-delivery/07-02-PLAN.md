---
phase: 07-opportunistic-delivery
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/OpportunisticDeliveryTestBase.kt
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/KotlinToPythonOpportunisticTest.kt
autonomous: true

must_haves:
  truths:
    - "Test base can delay Python announce until test triggers it"
    - "Kotlin message queued when Python destination path is unknown"
    - "Message automatically delivered when Python announces"
    - "Delivery callback fires after announce-triggered delivery"
  artifacts:
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/OpportunisticDeliveryTestBase.kt"
      provides: "Test infrastructure for opportunistic delivery scenarios"
      contains: "triggerPythonAnnounce"
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/KotlinToPythonOpportunisticTest.kt"
      provides: "Kotlin to Python opportunistic delivery tests"
      contains: "message queued then delivered after announce"
  key_links:
    - from: "KotlinToPythonOpportunisticTest"
      to: "OpportunisticDeliveryTestBase.triggerPythonAnnounce"
      via: "test controls announce timing"
      pattern: "triggerPythonAnnounce"
    - from: "kotlinRouter.handleOutbound"
      to: "handleDeliveryAnnounce"
      via: "announce triggers delivery"
      pattern: "AtomicBoolean.*deliveryFired"
---

<objective>
Create test infrastructure for opportunistic delivery and verify basic Kotlin-to-Python opportunistic delivery.

Purpose: Test the core opportunistic delivery behavior - message queued when destination unknown, delivered automatically when destination announces. This verifies the handleDeliveryAnnounce trigger mechanism works correctly.

Output: OpportunisticDeliveryTestBase extending DirectDeliveryTestBase with announce control, plus basic K->P opportunistic test.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/07-opportunistic-delivery/07-CONTEXT.md
@.planning/phases/06-direct-delivery/06-01-SUMMARY.md

# Existing test infrastructure
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/DirectDeliveryTestBase.kt
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/LiveDeliveryTest.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OpportunisticDeliveryTestBase</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/OpportunisticDeliveryTestBase.kt</files>
  <action>
  Create OpportunisticDeliveryTestBase that extends DirectDeliveryTestBase with modifications for opportunistic delivery testing:

  1. Override setup to NOT announce Python destination automatically:
     - DirectDeliveryTestBase.setupDirectDelivery() announces Python at the end (step 9)
     - We need the same infrastructure but without the announce
     - Option A: Add a flag to control announce behavior
     - Option B: Create new setup that calls parent setup steps manually
     - Preferred: Option A - add `protected var skipInitialAnnounce = false` flag

  2. Add announce control methods:
     ```kotlin
     protected fun triggerPythonAnnounce() {
         val result = python("lxmf_announce")
         println("[Test] Python announced: ${result.getString("announced")}")
     }

     protected fun waitForKotlinToReceiveAnnounce(destHash: ByteArray, timeoutMs: Long = 5000): Boolean {
         val deadline = System.currentTimeMillis() + timeoutMs
         while (System.currentTimeMillis() < deadline) {
             if (Transport.hasPath(destHash)) {
                 return true
             }
             Thread.sleep(100)
         }
         return false
     }
     ```

  3. Add helper for creating messages with OPPORTUNISTIC method:
     ```kotlin
     protected fun createOpportunisticMessage(
         content: String,
         title: String = "Opportunistic Test"
     ): LXMessage {
         val pythonIdentity = Identity.recall(pythonDestHash!!)
             ?: error("Cannot recall Python identity")

         val dest = Destination.create(
             identity = pythonIdentity,
             direction = DestinationDirection.OUT,
             type = DestinationType.SINGLE,
             appName = "lxmf",
             "delivery"
         )

         return LXMessage.create(
             destination = dest,
             source = kotlinDestination,
             content = content,
             title = title,
             desiredMethod = DeliveryMethod.OPPORTUNISTIC
         )
     }
     ```

  4. Modify DirectDeliveryTestBase to support the flag:
     - Add `protected open var skipInitialAnnounce = false`
     - In setupDirectDelivery(), wrap step 9 (announce) with: `if (!skipInitialAnnounce) { ... }`

  File structure:
  ```kotlin
  package network.reticulum.lxmf.interop

  import ...

  @TestInstance(TestInstance.Lifecycle.PER_CLASS)
  abstract class OpportunisticDeliveryTestBase : DirectDeliveryTestBase() {

      // Skip the automatic Python announce in parent setup
      override var skipInitialAnnounce = true

      protected fun triggerPythonAnnounce() { ... }

      protected fun waitForKotlinToReceiveAnnounce(...) { ... }

      protected fun createOpportunisticMessage(...) { ... }
  }
  ```
  </action>
  <verify>
  ```bash
  cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:compileTestKotlin 2>&1 | tail -10
  ```
  Should compile without errors.
  </verify>
  <done>OpportunisticDeliveryTestBase created with announce control methods and skipInitialAnnounce flag</done>
</task>

<task type="auto">
  <name>Task 2: Create KotlinToPythonOpportunisticTest with delayed announce test</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/KotlinToPythonOpportunisticTest.kt</files>
  <action>
  Create test class for Kotlin to Python opportunistic delivery with the core "delayed announce" test:

  ```kotlin
  package network.reticulum.lxmf.interop

  import io.kotest.matchers.collections.shouldContain
  import io.kotest.matchers.shouldBe
  import io.kotest.matchers.shouldNotBe
  import kotlinx.coroutines.delay
  import kotlinx.coroutines.runBlocking
  import kotlinx.coroutines.withTimeoutOrNull
  import network.reticulum.lxmf.MessageState
  import org.junit.jupiter.api.Test
  import org.junit.jupiter.api.Timeout
  import java.util.concurrent.TimeUnit
  import java.util.concurrent.atomic.AtomicBoolean
  import kotlin.time.Duration.Companion.seconds

  /**
   * Tests for Kotlin to Python OPPORTUNISTIC delivery.
   *
   * Opportunistic delivery sends messages as single encrypted packets when the
   * destination path is available. Messages are queued when path is unknown and
   * delivered automatically when the destination announces.
   */
  class KotlinToPythonOpportunisticTest : OpportunisticDeliveryTestBase() {

      @Test
      @Timeout(60, unit = TimeUnit.SECONDS)
      fun `message queued when path unknown then delivered after announce`() = runBlocking {
          // Clear any existing messages
          clearPythonMessages()

          // 1. Create opportunistic message BEFORE Python has announced
          val message = createOpportunisticMessage(
              content = "Hello from Kotlin via opportunistic delivery!",
              title = "Opportunistic Test"
          )

          // 2. Track delivery callback
          val deliveryFired = AtomicBoolean(false)
          message.deliveryCallback = { deliveryFired.set(true) }

          // 3. Queue message - should NOT deliver yet (no path)
          kotlinRouter.handleOutbound(message)
          delay(2000) // Allow queue processing

          // 4. Verify message is queued, not delivered
          // It should be in OUTBOUND or still processing, not DELIVERED
          message.state shouldNotBe MessageState.DELIVERED
          getPythonMessages().size shouldBe 0

          println("[Test] Message queued, state=${message.state}, triggering Python announce...")

          // 5. NOW trigger Python to announce
          triggerPythonAnnounce()

          // 6. Wait for announce to propagate and trigger delivery
          delay(1000) // Allow announce propagation

          // 7. Wait for delivery
          val delivered = withTimeoutOrNull(30.seconds) {
              while (!deliveryFired.get()) {
                  delay(200)
              }
              true
          } ?: false

          println("[Test] After waiting: deliveryFired=${deliveryFired.get()}, state=${message.state}")

          // 8. Verify delivery
          if (!delivered) {
              // Check if message was received even without callback
              val pythonMessages = getPythonMessages()
              println("[Test] Python received ${pythonMessages.size} messages")
              if (pythonMessages.isNotEmpty()) {
                  println("[Test] Message delivered but callback may not have fired")
              }
          }

          // Accept SENT or DELIVERED as success (delivery confirmation timing varies)
          listOf(MessageState.SENT, MessageState.DELIVERED) shouldContain message.state

          // Verify Python received the message
          val pythonMessages = getPythonMessages()
          pythonMessages.size shouldBe 1
          pythonMessages[0].content shouldBe "Hello from Kotlin via opportunistic delivery!"
      }

      @Test
      @Timeout(30, unit = TimeUnit.SECONDS)
      fun `opportunistic message delivers when path already known`() = runBlocking {
          // First trigger announce so path is known
          triggerPythonAnnounce()
          delay(2000) // Allow announce to propagate

          clearPythonMessages()

          // Create and send message - should deliver immediately
          val message = createOpportunisticMessage(
              content = "Quick opportunistic message",
              title = "Quick Test"
          )

          val deliveryFired = AtomicBoolean(false)
          message.deliveryCallback = { deliveryFired.set(true) }

          kotlinRouter.handleOutbound(message)

          // Wait for delivery (should be fast since path is known)
          val delivered = withTimeoutOrNull(15.seconds) {
              while (getPythonMessages().isEmpty()) {
                  delay(200)
              }
              true
          } ?: false

          delivered shouldBe true
          listOf(MessageState.SENT, MessageState.DELIVERED) shouldContain message.state
          getPythonMessages()[0].content shouldBe "Quick opportunistic message"
      }
  }
  ```

  Key aspects:
  - Uses OpportunisticDeliveryTestBase which skips initial announce
  - First test: message queued, then announce triggers delivery
  - Second test: path already known, immediate delivery
  - Uses AtomicBoolean for callback tracking (proven pattern from Phase 6)
  - Accepts SENT or DELIVERED as valid final states
  - 60 second timeout for delayed announce test (queue + announce + delivery)
  </action>
  <verify>
  ```bash
  cd ~/repos/public/reticulum-kt && JAVA_HOME=~/android-studio/jbr ./gradlew :lxmf-core:test --tests "KotlinToPythonOpportunisticTest" 2>&1 | tail -30
  ```
  Tests should pass (or show meaningful failure related to networking, not compilation).
  </verify>
  <done>KotlinToPythonOpportunisticTest created with delayed announce test verifying queue-then-deliver behavior</done>
</task>

</tasks>

<verification>
1. Test infrastructure compiles:
   - `./gradlew :lxmf-core:compileTestKotlin` succeeds

2. Tests execute:
   - `./gradlew :lxmf-core:test --tests "KotlinToPythonOpportunisticTest"` runs
   - Tests verify queue-then-announce behavior

3. Key behaviors verified:
   - Message not delivered when no path exists
   - Message delivered after Python announces
   - Callback fires on delivery
</verification>

<success_criteria>
- OpportunisticDeliveryTestBase exists with triggerPythonAnnounce method
- DirectDeliveryTestBase has skipInitialAnnounce flag
- KotlinToPythonOpportunisticTest has "delayed announce" test
- Tests pass or fail with clear networking issues (not compilation errors)
</success_criteria>

<output>
After completion, create `.planning/phases/07-opportunistic-delivery/07-02-SUMMARY.md`
</output>
