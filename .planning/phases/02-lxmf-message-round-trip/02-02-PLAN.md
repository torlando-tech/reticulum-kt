---
phase: 02-lxmf-message-round-trip
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PythonToKotlinMessageTest.kt
autonomous: true

must_haves:
  truths:
    - "Python-created LXMessage unpacks in Kotlin with all base fields preserved"
    - "Message destination/source hashes match after round-trip"
    - "Timestamp survives round-trip intact"
    - "Title and content survive round-trip intact"
    - "Signature validates when source identity is remembered"
  artifacts:
    - path: "lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PythonToKotlinMessageTest.kt"
      provides: "Python-to-Kotlin round-trip tests"
      contains: "class PythonToKotlinMessageTest"
  key_links:
    - from: "PythonToKotlinMessageTest.kt"
      to: "python-bridge/bridge_server.py"
      via: "PythonBridge lxmf_pack command"
      pattern: "python.*lxmf_pack"
    - from: "PythonToKotlinMessageTest.kt"
      to: "LXMessage.unpackFromBytes"
      via: "Kotlin unpacking"
      pattern: "LXMessage\\.unpackFromBytes"
---

<objective>
Verify Python-created LXMessages unpack correctly in Kotlin.

Purpose: Proves LXMF-02 requirement - Python-packed messages unpack correctly in Kotlin. This completes the bidirectional round-trip verification for full interoperability.

Output: PythonToKotlinMessageTest test suite.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-lxmf-message-round-trip/02-CONTEXT.md
@.planning/phases/02-lxmf-message-round-trip/02-RESEARCH.md
@.planning/phases/02-lxmf-message-round-trip/02-01-SUMMARY.md

# Key source files - use patterns from 02-01
@lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/LXMFInteropTestBase.kt
@lxmf-core/src/main/kotlin/network/reticulum/lxmf/LXMessage.kt
@python-bridge/bridge_server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PythonToKotlinMessageTest</name>
  <files>lxmf-core/src/test/kotlin/network/reticulum/lxmf/interop/PythonToKotlinMessageTest.kt</files>
  <action>
Create PythonToKotlinMessageTest.kt that extends LXMFInteropTestBase:

1. Helper method to create message in Python:
   ```kotlin
   private fun createMessageInPython(
       destinationHash: ByteArray,
       sourceHash: ByteArray,
       timestamp: Double,
       title: String,
       content: String,
       fields: Map<String, Any> = emptyMap()
   ): ByteArray
   ```
   - Calls python("lxmf_pack", ...) with all parameters
   - Returns the packed bytes (hex-decoded from result)
   - Note: lxmf_pack returns unsigned message bytes (no signature)
   - For signature, need to sign with ed25519_sign command

2. Test: `python message unpacks in Kotlin with all fields preserved`
   - Create message in Python with title, content, timestamp
   - Get packed bytes from bridge
   - Unpack in Kotlin with LXMessage.unpackFromBytes()
   - Use assertSoftly to compare all fields
   - Note: Python lxmf_pack does NOT sign - tests unsigned message unpacking

3. Test: `empty message from Python unpacks correctly`
   - Create message in Python with empty title and content
   - Unpack in Kotlin
   - Verify empty strings preserved

4. Test: `unicode content from Python unpacks correctly`
   - Create message in Python with unicode content
   - Unpack in Kotlin
   - Verify UTF-8 encoding preserved

5. Test: `message with fields from Python unpacks correctly`
   - Create message in Python with fields dict (e.g., {"3": 0} for FIELD_RENDERER)
   - Unpack in Kotlin
   - Verify fields map populated with integer keys

6. Test: `message hash computed identically`
   - Create same message in both Kotlin and Python (same dest/src hashes, timestamp, content)
   - Compare message hashes
   - Both should produce identical SHA256

Key implementation notes:
- The bridge lxmf_pack command returns unsigned bytes (just dest_hash + source_hash + packed_payload)
- For signature testing, use the existing LXMessageInteropTest approach (static test vectors with signatures)
- Focus on payload unpacking correctness, not signature validation (that's Phase 4)

Each test should:
- Log timing for pack/unpack operations
- Use assertSoftly for field-by-field comparison
- Handle JSON field key conversion (string "3" -> int 3)
  </action>
  <verify>
Tests pass: `cd ~/repos/public/reticulum-kt && PYTHON_RNS_PATH=~/repos/Reticulum PYTHON_LXMF_PATH=~/repos/LXMF ./gradlew :lxmf-core:test --tests "network.reticulum.lxmf.interop.PythonToKotlinMessageTest" --info`
  </verify>
  <done>
All PythonToKotlinMessageTest tests pass, proving Python messages unpack correctly in Kotlin.
  </done>
</task>

<task type="auto">
  <name>Task 2: Run full interop test suite and verify both directions</name>
  <files>N/A (verification task)</files>
  <action>
Run the complete LXMF interop test suite to verify both directions work:

1. Run all tests in the interop package:
   ```bash
   cd ~/repos/public/reticulum-kt
   PYTHON_RNS_PATH=~/repos/Reticulum PYTHON_LXMF_PATH=~/repos/LXMF \
   ./gradlew :lxmf-core:test --tests "network.reticulum.lxmf.interop.*" --info
   ```

2. Verify test output shows:
   - All KotlinToPythonMessageTest tests pass
   - All PythonToKotlinMessageTest tests pass
   - Timing logs appear for pack/unpack operations

3. If any tests fail:
   - Analyze failure message
   - Check for timestamp precision issues (use tolerance if needed)
   - Check for field key type conversion issues
   - Fix and re-run

4. Document any edge cases discovered in test output analysis
  </action>
  <verify>
Full test suite passes: `cd ~/repos/public/reticulum-kt && PYTHON_RNS_PATH=~/repos/Reticulum PYTHON_LXMF_PATH=~/repos/LXMF ./gradlew :lxmf-core:test --tests "network.reticulum.lxmf.interop.*"`
  </verify>
  <done>
Complete bidirectional LXMF message round-trip verified working.
  </done>
</task>

</tasks>

<verification>
1. PythonToKotlinMessageTest compiles and passes
2. Full interop suite runs successfully
3. Both directions verified (Kotlin->Python and Python->Kotlin)
4. Message hashes match between implementations
5. All base fields survive round-trip in both directions
</verification>

<success_criteria>
- [ ] PythonToKotlinMessageTest.kt has 5-6 test cases
- [ ] All tests pass with Python bridge
- [ ] Message hash comparison test proves identical computation
- [ ] Full interop suite passes
- [ ] Phase 2 success criteria satisfied:
  - [ ] LXMessage created in Kotlin unpacks in Python (verified in 02-01)
  - [ ] LXMessage created in Python unpacks in Kotlin (verified here)
  - [ ] Source/destination hashes match
  - [ ] Timestamp and content survive round-trip
</success_criteria>

<output>
After completion, create `.planning/phases/02-lxmf-message-round-trip/02-02-SUMMARY.md`
</output>
