package network.reticulum.lxmf.interop

import io.kotest.matchers.shouldBe
import network.reticulum.common.DestinationDirection
import network.reticulum.common.DestinationType
import network.reticulum.destination.Destination
import network.reticulum.identity.Identity
import network.reticulum.interop.getBoolean
import network.reticulum.interop.getBytes
import network.reticulum.interop.toHex
import network.reticulum.lxmf.LXMFConstants
import network.reticulum.lxmf.LXMessage
import network.reticulum.lxmf.UnverifiedReason
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

/**
 * Interoperability tests for LXMF message signatures.
 *
 * Verifies that LXMF message signatures generated by one implementation
 * validate in the other, proving cross-implementation signature compatibility.
 *
 * This covers:
 * - LXMF-07: Signature validation across implementations
 * - Kotlin-signed messages validated by Python
 * - Python-signed messages validated by Kotlin
 * - Invalid signature rejection
 */
@DisplayName("Message Signature Interop")
class MessageSignatureInteropTest : LXMFInteropTestBase() {

    @Nested
    @DisplayName("Kotlin Signs, Python Verifies")
    inner class KotlinSignsPythonVerifies {

        @Test
        @DisplayName("Kotlin signed message signature validates in Python")
        fun `Kotlin signed message signature validates in Python`() {
            println("\n=== Test: Kotlin signed message signature validates in Python ===")

            // Create and pack message (pack() signs the message)
            val message = createTestMessage(content = "Signature test message")
            val packed = message.pack()

            println("  [Kotlin] Message packed, size=${packed.size} bytes")
            println("  [Kotlin] Signature: ${message.signature?.toHex()?.take(32)}...")
            println("  [Kotlin] Hash: ${message.hash?.toHex()}")

            // The signature covers: hashedPart + hash
            // where hashedPart = destHash + sourceHash + payloadWithoutStamp
            // We need to reconstruct the signed_part to verify in Python

            // Extract payload from packed message (after dest + source + signature)
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)

            // hashedPart = destHash + sourceHash + payloadWithoutStamp
            // For messages without stamp, payload == payloadWithoutStamp
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify signature in Python
            val pyResult = python(
                "identity_verify",
                "public_key" to testSourceIdentity.getPublicKey(),
                "message" to signedPart,
                "signature" to message.signature!!
            )

            pyResult.getBoolean("valid") shouldBe true
            println("  SUCCESS: Python validated Kotlin signature")
        }

        @Test
        @DisplayName("Kotlin signed message with fields validates in Python")
        fun `Kotlin signed message with fields validates in Python`() {
            println("\n=== Test: Kotlin signed message with fields validates in Python ===")

            // Create message with FIELD_RENDERER
            val message = createTestMessage(
                content = "Message with fields for signature test",
                title = "Signature Fields Test",
                fields = mutableMapOf(
                    LXMFConstants.FIELD_RENDERER to LXMFConstants.RENDERER_MARKDOWN
                )
            )
            val packed = message.pack()

            println("  [Kotlin] Message with fields packed, size=${packed.size} bytes")

            // Reconstruct signed_part
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify signature in Python
            val pyResult = python(
                "identity_verify",
                "public_key" to testSourceIdentity.getPublicKey(),
                "message" to signedPart,
                "signature" to message.signature!!
            )

            pyResult.getBoolean("valid") shouldBe true
            println("  SUCCESS: Python validated Kotlin signature with fields")
        }
    }

    @Nested
    @DisplayName("Invalid Signatures")
    inner class InvalidSignatures {

        @Test
        @DisplayName("Tampered signature fails validation in Python")
        fun `tampered signature fails validation in Python`() {
            println("\n=== Test: Tampered signature fails validation in Python ===")

            val message = createTestMessage(content = "Tamper test message")
            val packed = message.pack()

            // Get original signature and tamper it
            val originalSignature = message.signature!!
            val tamperedSignature = originalSignature.copyOf()
            tamperedSignature[0] = (tamperedSignature[0].toInt() xor 0x01).toByte()

            println("  [Kotlin] Original signature[0]: ${originalSignature[0].toInt() and 0xFF}")
            println("  [Kotlin] Tampered signature[0]: ${tamperedSignature[0].toInt() and 0xFF}")

            // Reconstruct signed_part
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify tampered signature in Python - should fail
            val pyResult = python(
                "identity_verify",
                "public_key" to testSourceIdentity.getPublicKey(),
                "message" to signedPart,
                "signature" to tamperedSignature
            )

            pyResult.getBoolean("valid") shouldBe false
            println("  SUCCESS: Python correctly rejected tampered signature")
        }

        @Test
        @DisplayName("Wrong key fails validation in Python")
        fun `wrong key fails validation in Python`() {
            println("\n=== Test: Wrong key fails validation in Python ===")

            val message = createTestMessage(content = "Wrong key test message")
            val packed = message.pack()

            // Reconstruct signed_part
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify with WRONG public key (destination identity instead of source)
            val pyResult = python(
                "identity_verify",
                "public_key" to testDestIdentity.getPublicKey(),  // Wrong key!
                "message" to signedPart,
                "signature" to message.signature!!
            )

            pyResult.getBoolean("valid") shouldBe false
            println("  SUCCESS: Python correctly rejected signature with wrong key")
        }
    }

    @Nested
    @DisplayName("Python Signs, Kotlin Verifies")
    inner class PythonSignsKotlinVerifies {

        @Test
        @DisplayName("Python signed message validates in Kotlin")
        fun `Python signed message validates in Kotlin`() {
            println("\n=== Test: Python signed message validates in Kotlin ===")

            // Create message components
            val content = "Python signed message"
            val title = ""
            val timestamp = System.currentTimeMillis() / 1000.0

            // Get Python to compute signed_part via lxmf_pack
            val packResult = python(
                "lxmf_pack",
                "destination_hash" to destDestination.hash.toHex(),
                "source_hash" to sourceDestination.hash.toHex(),
                "timestamp" to timestamp,
                "title" to title,
                "content" to content
            )
            val signedPart = packResult.getBytes("signed_part")

            println("  [Python] signed_part size: ${signedPart.size} bytes")

            // Sign with Python using identity_sign
            val signResult = python(
                "identity_sign",
                "private_key" to testSourceIdentity.getPrivateKey(),
                "message" to signedPart
            )
            val signature = signResult.getBytes("signature")

            println("  [Python] signature: ${signature.toHex().take(32)}...")

            // Verify in Kotlin
            val valid = testSourceIdentity.validate(signature, signedPart)
            valid shouldBe true
            println("  SUCCESS: Kotlin validated Python signature")
        }

        @Test
        @DisplayName("Tampered Python signature rejected by Kotlin")
        fun `tampered Python signature rejected by Kotlin`() {
            println("\n=== Test: Tampered Python signature rejected by Kotlin ===")

            val timestamp = System.currentTimeMillis() / 1000.0
            val packResult = python(
                "lxmf_pack",
                "destination_hash" to destDestination.hash.toHex(),
                "source_hash" to sourceDestination.hash.toHex(),
                "timestamp" to timestamp,
                "title" to "",
                "content" to "Test content for tamper detection"
            )
            val signedPart = packResult.getBytes("signed_part")

            val signResult = python(
                "identity_sign",
                "private_key" to testSourceIdentity.getPrivateKey(),
                "message" to signedPart
            )
            val signature = signResult.getBytes("signature")

            // Tamper with signature (flip first bit)
            val tamperedSignature = signature.copyOf()
            tamperedSignature[0] = (tamperedSignature[0].toInt() xor 0x01).toByte()

            println("  [Python] Original signature[0]: ${signature[0].toInt() and 0xFF}")
            println("  [Kotlin] Tampered signature[0]: ${tamperedSignature[0].toInt() and 0xFF}")

            // Kotlin should reject tampered signature
            val valid = testSourceIdentity.validate(tamperedSignature, signedPart)
            valid shouldBe false
            println("  SUCCESS: Kotlin correctly rejected tampered Python signature")
        }

        @Test
        @DisplayName("Python signed message with fields validates in Kotlin")
        fun `Python signed message with fields validates in Kotlin`() {
            println("\n=== Test: Python signed message with fields validates in Kotlin ===")

            val timestamp = System.currentTimeMillis() / 1000.0

            // Create fields map with FIELD_RENDERER
            val fields = mapOf(
                LXMFConstants.FIELD_RENDERER.toString() to LXMFConstants.RENDERER_PLAIN
            )

            val packResult = python(
                "lxmf_pack",
                "destination_hash" to destDestination.hash.toHex(),
                "source_hash" to sourceDestination.hash.toHex(),
                "timestamp" to timestamp,
                "title" to "Field Test Title",
                "content" to "Message with fields for Python-to-Kotlin signature test",
                "fields" to fields
            )
            val signedPart = packResult.getBytes("signed_part")

            println("  [Python] signed_part with fields size: ${signedPart.size} bytes")

            val signResult = python(
                "identity_sign",
                "private_key" to testSourceIdentity.getPrivateKey(),
                "message" to signedPart
            )
            val signature = signResult.getBytes("signature")

            // Verify in Kotlin
            val valid = testSourceIdentity.validate(signature, signedPart)
            valid shouldBe true
            println("  SUCCESS: Kotlin validated Python signature with fields")
        }
    }

    @Nested
    @DisplayName("Edge Cases")
    inner class EdgeCases {

        @Test
        @DisplayName("Empty content message signature validates")
        fun `empty content message signature validates`() {
            println("\n=== Test: Empty content message signature validates ===")

            // Create message with empty content
            val message = createTestMessage(content = "", title = "")
            val packed = message.pack()

            println("  [Kotlin] Empty message packed, size=${packed.size} bytes")

            // Reconstruct signed_part
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify in Python
            val pyResult = python(
                "identity_verify",
                "public_key" to testSourceIdentity.getPublicKey(),
                "message" to signedPart,
                "signature" to message.signature!!
            )

            pyResult.getBoolean("valid") shouldBe true
            println("  SUCCESS: Empty content message signature validates in Python")
        }

        @Test
        @DisplayName("Unicode content message signature validates")
        fun `Unicode content message signature validates`() {
            println("\n=== Test: Unicode content message signature validates ===")

            // Create message with emoji and CJK characters
            val unicodeContent = "Hello \uD83D\uDE80 World \u4E2D\u6587 \u0420\u0443\u0441\u0441\u043A\u0438\u0439"
            val unicodeTitle = "\u2764\uFE0F \uD83D\uDC99 \uD83D\uDC9A"

            val message = createTestMessage(content = unicodeContent, title = unicodeTitle)
            val packed = message.pack()

            println("  [Kotlin] Unicode message packed, size=${packed.size} bytes")
            println("  [Kotlin] Content: $unicodeContent")
            println("  [Kotlin] Title: $unicodeTitle")

            // Reconstruct signed_part
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify in Python
            val pyResult = python(
                "identity_verify",
                "public_key" to testSourceIdentity.getPublicKey(),
                "message" to signedPart,
                "signature" to message.signature!!
            )

            pyResult.getBoolean("valid") shouldBe true
            println("  SUCCESS: Unicode content message signature validates in Python")
        }

        @Test
        @DisplayName("Signature length is always 64 bytes")
        fun `signature length is always 64 bytes`() {
            println("\n=== Test: Signature length is always 64 bytes ===")

            // Test multiple messages to ensure consistent signature length
            val messages = listOf(
                createTestMessage(content = ""),
                createTestMessage(content = "Short"),
                createTestMessage(content = "A".repeat(1000)),
                createTestMessage(content = "Unicode \uD83D\uDE00", title = "\u4E2D\u6587")
            )

            for ((index, message) in messages.withIndex()) {
                message.pack()
                val signatureLength = message.signature?.size ?: 0
                println("  [Message $index] Signature length: $signatureLength bytes")
                signatureLength shouldBe 64
            }

            println("  SUCCESS: All signatures are exactly 64 bytes (Ed25519)")
        }
    }

    @Nested
    @DisplayName("Error Handling")
    inner class ErrorHandling {

        @Test
        @DisplayName("Missing source identity causes SOURCE_UNKNOWN")
        fun `missing source identity causes SOURCE_UNKNOWN`() {
            println("\n=== Test: Missing source identity causes SOURCE_UNKNOWN ===")

            // Create a fresh identity that is NOT remembered in the cache
            val freshSourceIdentity = Identity.create()
            val freshSourceDest = Destination.create(
                identity = freshSourceIdentity,
                direction = DestinationDirection.IN,
                type = DestinationType.SINGLE,
                appName = LXMFConstants.APP_NAME,
                "delivery"
            )

            // Create message with fresh source (not remembered)
            val unrememberedMessage = LXMessage.create(
                destination = destDestination,
                source = freshSourceDest,
                content = "Message from unremembered source"
            )
            val unrememberedPacked = unrememberedMessage.pack()

            println("  [Kotlin] Packed message with fresh source, size=${unrememberedPacked.size} bytes")
            println("  [Kotlin] Fresh source hash: ${freshSourceDest.hash.toHex()}")

            // Clear the fresh identity from cache if it was accidentally added
            // (The Identity.create() doesn't add to cache, but let's be explicit)

            // Attempt to unpack - should have SOURCE_UNKNOWN because we didn't remember the source
            val unpacked = LXMessage.unpackFromBytes(unrememberedPacked)

            if (unpacked != null) {
                println("  [Kotlin] Unpacked message: signatureValidated=${unpacked.signatureValidated}")
                println("  [Kotlin] Unverified reason: ${unpacked.unverifiedReason}")

                unpacked.signatureValidated shouldBe false
                unpacked.unverifiedReason shouldBe UnverifiedReason.SOURCE_UNKNOWN
                println("  SUCCESS: Missing source identity correctly causes SOURCE_UNKNOWN")
            } else {
                throw AssertionError("Message unpacking returned null (unexpected)")
            }
        }

        @Test
        @DisplayName("Known source identity validates signature on unpack")
        fun `known source identity validates signature on unpack`() {
            println("\n=== Test: Known source identity validates signature on unpack ===")

            // Create and pack a message using remembered source identity
            // (testSourceIdentity is remembered in LXMFInteropTestBase.setupLXMFFixtures)
            val message = createTestMessage(content = "Message for unpack validation test")
            val packed = message.pack()

            println("  [Kotlin] Packed message, size=${packed.size} bytes")
            println("  [Kotlin] Source hash: ${sourceDestination.hash.toHex()}")

            // Unpack the message - should validate signature because source is known
            val unpacked = LXMessage.unpackFromBytes(packed)

            if (unpacked != null) {
                println("  [Kotlin] Unpacked message: signatureValidated=${unpacked.signatureValidated}")
                println("  [Kotlin] Unverified reason: ${unpacked.unverifiedReason}")

                unpacked.signatureValidated shouldBe true
                unpacked.unverifiedReason shouldBe null
                println("  SUCCESS: Known source identity correctly validates signature on unpack")
            } else {
                throw AssertionError("Message unpacking returned null (unexpected)")
            }
        }
    }
}
