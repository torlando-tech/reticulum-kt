package network.reticulum.lxmf.interop

import io.kotest.matchers.shouldBe
import network.reticulum.interop.getBoolean
import network.reticulum.interop.toHex
import network.reticulum.lxmf.LXMFConstants
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

/**
 * Interoperability tests for LXMF message signatures.
 *
 * Verifies that LXMF message signatures generated by one implementation
 * validate in the other, proving cross-implementation signature compatibility.
 *
 * This covers:
 * - LXMF-07: Signature validation across implementations
 * - Kotlin-signed messages validated by Python
 * - Python-signed messages validated by Kotlin
 * - Invalid signature rejection
 */
@DisplayName("Message Signature Interop")
class MessageSignatureInteropTest : LXMFInteropTestBase() {

    @Nested
    @DisplayName("Kotlin Signs, Python Verifies")
    inner class KotlinSignsPythonVerifies {

        @Test
        @DisplayName("Kotlin signed message signature validates in Python")
        fun `Kotlin signed message signature validates in Python`() {
            println("\n=== Test: Kotlin signed message signature validates in Python ===")

            // Create and pack message (pack() signs the message)
            val message = createTestMessage(content = "Signature test message")
            val packed = message.pack()

            println("  [Kotlin] Message packed, size=${packed.size} bytes")
            println("  [Kotlin] Signature: ${message.signature?.toHex()?.take(32)}...")
            println("  [Kotlin] Hash: ${message.hash?.toHex()}")

            // The signature covers: hashedPart + hash
            // where hashedPart = destHash + sourceHash + payloadWithoutStamp
            // We need to reconstruct the signed_part to verify in Python

            // Extract payload from packed message (after dest + source + signature)
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)

            // hashedPart = destHash + sourceHash + payloadWithoutStamp
            // For messages without stamp, payload == payloadWithoutStamp
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify signature in Python
            val pyResult = python(
                "identity_verify",
                "public_key" to testSourceIdentity.getPublicKey(),
                "message" to signedPart,
                "signature" to message.signature!!
            )

            pyResult.getBoolean("valid") shouldBe true
            println("  SUCCESS: Python validated Kotlin signature")
        }

        @Test
        @DisplayName("Kotlin signed message with fields validates in Python")
        fun `Kotlin signed message with fields validates in Python`() {
            println("\n=== Test: Kotlin signed message with fields validates in Python ===")

            // Create message with FIELD_RENDERER
            val message = createTestMessage(
                content = "Message with fields for signature test",
                title = "Signature Fields Test",
                fields = mutableMapOf(
                    LXMFConstants.FIELD_RENDERER to LXMFConstants.RENDERER_MARKDOWN
                )
            )
            val packed = message.pack()

            println("  [Kotlin] Message with fields packed, size=${packed.size} bytes")

            // Reconstruct signed_part
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify signature in Python
            val pyResult = python(
                "identity_verify",
                "public_key" to testSourceIdentity.getPublicKey(),
                "message" to signedPart,
                "signature" to message.signature!!
            )

            pyResult.getBoolean("valid") shouldBe true
            println("  SUCCESS: Python validated Kotlin signature with fields")
        }
    }

    @Nested
    @DisplayName("Invalid Signatures")
    inner class InvalidSignatures {

        @Test
        @DisplayName("Tampered signature fails validation in Python")
        fun `tampered signature fails validation in Python`() {
            println("\n=== Test: Tampered signature fails validation in Python ===")

            val message = createTestMessage(content = "Tamper test message")
            val packed = message.pack()

            // Get original signature and tamper it
            val originalSignature = message.signature!!
            val tamperedSignature = originalSignature.copyOf()
            tamperedSignature[0] = (tamperedSignature[0].toInt() xor 0x01).toByte()

            println("  [Kotlin] Original signature[0]: ${originalSignature[0].toInt() and 0xFF}")
            println("  [Kotlin] Tampered signature[0]: ${tamperedSignature[0].toInt() and 0xFF}")

            // Reconstruct signed_part
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify tampered signature in Python - should fail
            val pyResult = python(
                "identity_verify",
                "public_key" to testSourceIdentity.getPublicKey(),
                "message" to signedPart,
                "signature" to tamperedSignature
            )

            pyResult.getBoolean("valid") shouldBe false
            println("  SUCCESS: Python correctly rejected tampered signature")
        }

        @Test
        @DisplayName("Wrong key fails validation in Python")
        fun `wrong key fails validation in Python`() {
            println("\n=== Test: Wrong key fails validation in Python ===")

            val message = createTestMessage(content = "Wrong key test message")
            val packed = message.pack()

            // Reconstruct signed_part
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify with WRONG public key (destination identity instead of source)
            val pyResult = python(
                "identity_verify",
                "public_key" to testDestIdentity.getPublicKey(),  // Wrong key!
                "message" to signedPart,
                "signature" to message.signature!!
            )

            pyResult.getBoolean("valid") shouldBe false
            println("  SUCCESS: Python correctly rejected signature with wrong key")
        }
    }
}
