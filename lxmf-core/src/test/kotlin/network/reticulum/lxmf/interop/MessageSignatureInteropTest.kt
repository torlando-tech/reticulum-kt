package network.reticulum.lxmf.interop

import io.kotest.matchers.shouldBe
import network.reticulum.interop.getBoolean
import network.reticulum.interop.getBytes
import network.reticulum.interop.toHex
import network.reticulum.lxmf.LXMFConstants
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

/**
 * Interoperability tests for LXMF message signatures.
 *
 * Verifies that LXMF message signatures generated by one implementation
 * validate in the other, proving cross-implementation signature compatibility.
 *
 * This covers:
 * - LXMF-07: Signature validation across implementations
 * - Kotlin-signed messages validated by Python
 * - Python-signed messages validated by Kotlin
 * - Invalid signature rejection
 */
@DisplayName("Message Signature Interop")
class MessageSignatureInteropTest : LXMFInteropTestBase() {

    @Nested
    @DisplayName("Kotlin Signs, Python Verifies")
    inner class KotlinSignsPythonVerifies {

        @Test
        @DisplayName("Kotlin signed message signature validates in Python")
        fun `Kotlin signed message signature validates in Python`() {
            println("\n=== Test: Kotlin signed message signature validates in Python ===")

            // Create and pack message (pack() signs the message)
            val message = createTestMessage(content = "Signature test message")
            val packed = message.pack()

            println("  [Kotlin] Message packed, size=${packed.size} bytes")
            println("  [Kotlin] Signature: ${message.signature?.toHex()?.take(32)}...")
            println("  [Kotlin] Hash: ${message.hash?.toHex()}")

            // The signature covers: hashedPart + hash
            // where hashedPart = destHash + sourceHash + payloadWithoutStamp
            // We need to reconstruct the signed_part to verify in Python

            // Extract payload from packed message (after dest + source + signature)
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)

            // hashedPart = destHash + sourceHash + payloadWithoutStamp
            // For messages without stamp, payload == payloadWithoutStamp
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify signature in Python
            val pyResult = python(
                "identity_verify",
                "public_key" to testSourceIdentity.getPublicKey(),
                "message" to signedPart,
                "signature" to message.signature!!
            )

            pyResult.getBoolean("valid") shouldBe true
            println("  SUCCESS: Python validated Kotlin signature")
        }

        @Test
        @DisplayName("Kotlin signed message with fields validates in Python")
        fun `Kotlin signed message with fields validates in Python`() {
            println("\n=== Test: Kotlin signed message with fields validates in Python ===")

            // Create message with FIELD_RENDERER
            val message = createTestMessage(
                content = "Message with fields for signature test",
                title = "Signature Fields Test",
                fields = mutableMapOf(
                    LXMFConstants.FIELD_RENDERER to LXMFConstants.RENDERER_MARKDOWN
                )
            )
            val packed = message.pack()

            println("  [Kotlin] Message with fields packed, size=${packed.size} bytes")

            // Reconstruct signed_part
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify signature in Python
            val pyResult = python(
                "identity_verify",
                "public_key" to testSourceIdentity.getPublicKey(),
                "message" to signedPart,
                "signature" to message.signature!!
            )

            pyResult.getBoolean("valid") shouldBe true
            println("  SUCCESS: Python validated Kotlin signature with fields")
        }
    }

    @Nested
    @DisplayName("Invalid Signatures")
    inner class InvalidSignatures {

        @Test
        @DisplayName("Tampered signature fails validation in Python")
        fun `tampered signature fails validation in Python`() {
            println("\n=== Test: Tampered signature fails validation in Python ===")

            val message = createTestMessage(content = "Tamper test message")
            val packed = message.pack()

            // Get original signature and tamper it
            val originalSignature = message.signature!!
            val tamperedSignature = originalSignature.copyOf()
            tamperedSignature[0] = (tamperedSignature[0].toInt() xor 0x01).toByte()

            println("  [Kotlin] Original signature[0]: ${originalSignature[0].toInt() and 0xFF}")
            println("  [Kotlin] Tampered signature[0]: ${tamperedSignature[0].toInt() and 0xFF}")

            // Reconstruct signed_part
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify tampered signature in Python - should fail
            val pyResult = python(
                "identity_verify",
                "public_key" to testSourceIdentity.getPublicKey(),
                "message" to signedPart,
                "signature" to tamperedSignature
            )

            pyResult.getBoolean("valid") shouldBe false
            println("  SUCCESS: Python correctly rejected tampered signature")
        }

        @Test
        @DisplayName("Wrong key fails validation in Python")
        fun `wrong key fails validation in Python`() {
            println("\n=== Test: Wrong key fails validation in Python ===")

            val message = createTestMessage(content = "Wrong key test message")
            val packed = message.pack()

            // Reconstruct signed_part
            val headerSize = 2 * LXMFConstants.DESTINATION_LENGTH + LXMFConstants.SIGNATURE_LENGTH
            val payloadBytes = packed.copyOfRange(headerSize, packed.size)
            val hashedPart = message.destinationHash + message.sourceHash + payloadBytes
            val signedPart = hashedPart + message.hash!!

            // Verify with WRONG public key (destination identity instead of source)
            val pyResult = python(
                "identity_verify",
                "public_key" to testDestIdentity.getPublicKey(),  // Wrong key!
                "message" to signedPart,
                "signature" to message.signature!!
            )

            pyResult.getBoolean("valid") shouldBe false
            println("  SUCCESS: Python correctly rejected signature with wrong key")
        }
    }

    @Nested
    @DisplayName("Python Signs, Kotlin Verifies")
    inner class PythonSignsKotlinVerifies {

        @Test
        @DisplayName("Python signed message validates in Kotlin")
        fun `Python signed message validates in Kotlin`() {
            println("\n=== Test: Python signed message validates in Kotlin ===")

            // Create message components
            val content = "Python signed message"
            val title = ""
            val timestamp = System.currentTimeMillis() / 1000.0

            // Get Python to compute signed_part via lxmf_pack
            val packResult = python(
                "lxmf_pack",
                "destination_hash" to destDestination.hash.toHex(),
                "source_hash" to sourceDestination.hash.toHex(),
                "timestamp" to timestamp,
                "title" to title,
                "content" to content
            )
            val signedPart = packResult.getBytes("signed_part")

            println("  [Python] signed_part size: ${signedPart.size} bytes")

            // Sign with Python using identity_sign
            val signResult = python(
                "identity_sign",
                "private_key" to testSourceIdentity.getPrivateKey(),
                "message" to signedPart
            )
            val signature = signResult.getBytes("signature")

            println("  [Python] signature: ${signature.toHex().take(32)}...")

            // Verify in Kotlin
            val valid = testSourceIdentity.validate(signature, signedPart)
            valid shouldBe true
            println("  SUCCESS: Kotlin validated Python signature")
        }

        @Test
        @DisplayName("Tampered Python signature rejected by Kotlin")
        fun `tampered Python signature rejected by Kotlin`() {
            println("\n=== Test: Tampered Python signature rejected by Kotlin ===")

            val timestamp = System.currentTimeMillis() / 1000.0
            val packResult = python(
                "lxmf_pack",
                "destination_hash" to destDestination.hash.toHex(),
                "source_hash" to sourceDestination.hash.toHex(),
                "timestamp" to timestamp,
                "title" to "",
                "content" to "Test content for tamper detection"
            )
            val signedPart = packResult.getBytes("signed_part")

            val signResult = python(
                "identity_sign",
                "private_key" to testSourceIdentity.getPrivateKey(),
                "message" to signedPart
            )
            val signature = signResult.getBytes("signature")

            // Tamper with signature (flip first bit)
            val tamperedSignature = signature.copyOf()
            tamperedSignature[0] = (tamperedSignature[0].toInt() xor 0x01).toByte()

            println("  [Python] Original signature[0]: ${signature[0].toInt() and 0xFF}")
            println("  [Kotlin] Tampered signature[0]: ${tamperedSignature[0].toInt() and 0xFF}")

            // Kotlin should reject tampered signature
            val valid = testSourceIdentity.validate(tamperedSignature, signedPart)
            valid shouldBe false
            println("  SUCCESS: Kotlin correctly rejected tampered Python signature")
        }

        @Test
        @DisplayName("Python signed message with fields validates in Kotlin")
        fun `Python signed message with fields validates in Kotlin`() {
            println("\n=== Test: Python signed message with fields validates in Kotlin ===")

            val timestamp = System.currentTimeMillis() / 1000.0

            // Create fields map with FIELD_RENDERER
            val fields = mapOf(
                LXMFConstants.FIELD_RENDERER.toString() to LXMFConstants.RENDERER_PLAIN
            )

            val packResult = python(
                "lxmf_pack",
                "destination_hash" to destDestination.hash.toHex(),
                "source_hash" to sourceDestination.hash.toHex(),
                "timestamp" to timestamp,
                "title" to "Field Test Title",
                "content" to "Message with fields for Python-to-Kotlin signature test",
                "fields" to fields
            )
            val signedPart = packResult.getBytes("signed_part")

            println("  [Python] signed_part with fields size: ${signedPart.size} bytes")

            val signResult = python(
                "identity_sign",
                "private_key" to testSourceIdentity.getPrivateKey(),
                "message" to signedPart
            )
            val signature = signResult.getBytes("signature")

            // Verify in Kotlin
            val valid = testSourceIdentity.validate(signature, signedPart)
            valid shouldBe true
            println("  SUCCESS: Kotlin validated Python signature with fields")
        }
    }
}
