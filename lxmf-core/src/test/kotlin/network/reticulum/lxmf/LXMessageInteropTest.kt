package network.reticulum.lxmf

import network.reticulum.identity.Identity
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.io.InputStreamReader
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

/**
 * Interoperability tests for LXMF messages.
 *
 * These tests verify that Kotlin can correctly unpack messages generated by the
 * Python LXMF reference implementation, ensuring byte-perfect compatibility.
 *
 * Test vectors are generated by running:
 *   python3 test-scripts/lxmf_message_test.py > lxmf-core/src/test/resources/lxmf_test_vectors.json
 */
class LXMessageInteropTest {

    private data class TestCase(
        val name: String,
        val sourceHash: ByteArray,
        val sourcePublicKey: ByteArray,
        val destinationHash: ByteArray,
        val title: String,
        val content: String,
        val timestamp: Double,
        val messageHash: ByteArray,
        val signature: ByteArray,
        val packed: ByteArray,
        val representation: String,
        val fields: Map<Int, Any>? = null
    )

    private val testCases = mutableListOf<TestCase>()

    @BeforeEach
    fun loadTestVectors() {
        testCases.clear()

        // Load test vectors from resource file
        val resource = javaClass.classLoader.getResourceAsStream("lxmf_test_vectors.json")
        if (resource == null) {
            println("Warning: lxmf_test_vectors.json not found - skipping interop tests")
            return
        }

        val json = InputStreamReader(resource).readText()

        // Simple JSON parsing (avoid adding a JSON library dependency)
        parseTestCases(json)
    }

    private fun parseTestCases(json: String) {
        // Find test_cases array
        val testCasesStart = json.indexOf("\"test_cases\":")
        if (testCasesStart == -1) return

        // Very basic JSON parsing for our known structure
        val lines = json.lines()
        var currentName = ""
        var currentData: MutableMap<String, Any> = mutableMapOf()
        var inTestCase = false
        var inData = false
        var braceCount = 0

        for (line in lines) {
            val trimmed = line.trim()

            if (trimmed.contains("\"name\":")) {
                currentName = extractStringValue(trimmed)
            }

            if (trimmed.contains("\"data\":")) {
                inData = true
                braceCount = 0
                currentData = mutableMapOf()
            }

            if (inData) {
                if (trimmed.contains("{")) braceCount++
                if (trimmed.contains("}")) braceCount--

                // Parse data fields
                when {
                    trimmed.contains("\"source_hash\":") ->
                        currentData["source_hash"] = extractStringValue(trimmed)
                    trimmed.contains("\"source_public_key\":") ->
                        currentData["source_public_key"] = extractStringValue(trimmed)
                    trimmed.contains("\"destination_hash\":") ->
                        currentData["destination_hash"] = extractStringValue(trimmed)
                    trimmed.contains("\"title\":") ->
                        currentData["title"] = extractStringValue(trimmed)
                    trimmed.contains("\"content\":") && !trimmed.contains("Test content") ->
                        currentData["content"] = extractStringValue(trimmed)
                    trimmed.contains("\"timestamp\":") ->
                        currentData["timestamp"] = extractDoubleValue(trimmed)
                    trimmed.contains("\"message_hash\":") ->
                        currentData["message_hash"] = extractStringValue(trimmed)
                    trimmed.contains("\"signature\":") ->
                        currentData["signature"] = extractStringValue(trimmed)
                    trimmed.contains("\"packed\":") ->
                        currentData["packed"] = extractStringValue(trimmed)
                    trimmed.contains("\"representation\":") ->
                        currentData["representation"] = extractStringValue(trimmed)
                }

                // Handle special case for "content": "Test content" on message_with_fields
                if (trimmed.contains("\"content\": \"Test content\"")) {
                    currentData["content"] = "Test content"
                }

                if (braceCount == 0 && currentData.isNotEmpty()) {
                    inData = false
                    if (currentData["packed"] != null) {
                        try {
                            testCases.add(
                                TestCase(
                                    name = currentName,
                                    sourceHash = hexToBytes(currentData["source_hash"] as String),
                                    sourcePublicKey = hexToBytes(currentData["source_public_key"] as String),
                                    destinationHash = hexToBytes(currentData["destination_hash"] as String),
                                    title = currentData["title"] as? String ?: "",
                                    content = currentData["content"] as? String ?: "",
                                    timestamp = currentData["timestamp"] as? Double ?: 0.0,
                                    messageHash = hexToBytes(currentData["message_hash"] as String),
                                    signature = hexToBytes(currentData["signature"] as String),
                                    packed = hexToBytes(currentData["packed"] as String),
                                    representation = currentData["representation"] as? String ?: "PACKET"
                                )
                            )
                        } catch (e: Exception) {
                            println("Failed to parse test case $currentName: ${e.message}")
                        }
                    }
                    currentData = mutableMapOf()
                }
            }
        }
    }

    private fun extractStringValue(line: String): String {
        val colonIndex = line.indexOf(":")
        if (colonIndex == -1) return ""
        val valueStart = line.indexOf("\"", colonIndex + 1) + 1
        val valueEnd = line.indexOf("\"", valueStart)
        return if (valueStart > 0 && valueEnd > valueStart) {
            line.substring(valueStart, valueEnd)
        } else ""
    }

    private fun extractDoubleValue(line: String): Double {
        val colonIndex = line.indexOf(":")
        if (colonIndex == -1) return 0.0
        val valueStr = line.substring(colonIndex + 1).trim().removeSuffix(",")
        return try {
            valueStr.toDouble()
        } catch (e: NumberFormatException) {
            0.0
        }
    }

    private fun hexToBytes(hex: String): ByteArray {
        val result = ByteArray(hex.length / 2)
        for (i in result.indices) {
            result[i] = hex.substring(i * 2, i * 2 + 2).toInt(16).toByte()
        }
        return result
    }

    @Test
    fun `test unpack Python-generated simple message`() {
        val testCase = testCases.find { it.name == "simple_message" }
        if (testCase == null) {
            println("Skipping: simple_message test case not found")
            return
        }

        // Remember the source identity so signature validation works
        val dummyPacketHash = ByteArray(32) { 0 }
        Identity.remember(
            packetHash = dummyPacketHash,
            destHash = testCase.sourceHash,
            publicKey = testCase.sourcePublicKey
        )

        val unpacked = LXMessage.unpackFromBytes(testCase.packed)
        assertNotNull(unpacked, "Failed to unpack simple message")

        assertEquals("Hello", unpacked.title)
        assertEquals("Hello, World!", unpacked.content)
        assertNotNull(unpacked.timestamp)

        // Verify hashes match
        assertTrue(testCase.destinationHash.contentEquals(unpacked.destinationHash))
        assertTrue(testCase.sourceHash.contentEquals(unpacked.sourceHash))

        // Verify message hash
        assertTrue(testCase.messageHash.contentEquals(unpacked.hash!!))

        // Verify signature was validated
        assertTrue(unpacked.signatureValidated, "Signature validation should succeed")
    }

    @Test
    fun `test unpack Python-generated empty content`() {
        val testCase = testCases.find { it.name == "empty_content" }
        if (testCase == null) {
            println("Skipping: empty_content test case not found")
            return
        }

        // Remember the source identity
        val dummyPacketHash = ByteArray(32) { 0 }
        Identity.remember(
            packetHash = dummyPacketHash,
            destHash = testCase.sourceHash,
            publicKey = testCase.sourcePublicKey
        )

        val unpacked = LXMessage.unpackFromBytes(testCase.packed)
        assertNotNull(unpacked, "Failed to unpack empty content message")

        assertEquals("", unpacked.title)
        assertEquals("", unpacked.content)
        assertTrue(testCase.messageHash.contentEquals(unpacked.hash!!))
        assertTrue(unpacked.signatureValidated)
    }

    @Test
    fun `test unpack Python-generated large message`() {
        val testCase = testCases.find { it.name == "large_message" }
        if (testCase == null) {
            println("Skipping: large_message test case not found")
            return
        }

        // Remember the source identity
        val dummyPacketHash = ByteArray(32) { 0 }
        Identity.remember(
            packetHash = dummyPacketHash,
            destHash = testCase.sourceHash,
            publicKey = testCase.sourcePublicKey
        )

        val unpacked = LXMessage.unpackFromBytes(testCase.packed)
        assertNotNull(unpacked, "Failed to unpack large message")

        assertEquals("Large", unpacked.title)
        assertEquals(500, unpacked.content.length)
        assertEquals("X".repeat(500), unpacked.content)
        assertTrue(testCase.messageHash.contentEquals(unpacked.hash!!))
        assertTrue(unpacked.signatureValidated)
    }

    @Test
    fun `test unpack Python-generated message with fields`() {
        val testCase = testCases.find { it.name == "message_with_fields" }
        if (testCase == null) {
            println("Skipping: message_with_fields test case not found")
            return
        }

        // Remember the source identity
        val dummyPacketHash = ByteArray(32) { 0 }
        Identity.remember(
            packetHash = dummyPacketHash,
            destHash = testCase.sourceHash,
            publicKey = testCase.sourcePublicKey
        )

        val unpacked = LXMessage.unpackFromBytes(testCase.packed)
        assertNotNull(unpacked, "Failed to unpack message with fields")

        assertEquals("With Fields", unpacked.title)
        assertEquals("Test content", unpacked.content)
        assertTrue(testCase.messageHash.contentEquals(unpacked.hash!!))
        assertTrue(unpacked.signatureValidated)

        // Verify fields
        assertTrue(unpacked.fields.isNotEmpty(), "Fields should not be empty")
        assertTrue(LXMFConstants.FIELD_RENDERER in unpacked.fields, "FIELD_RENDERER should be present")
        assertEquals(LXMFConstants.RENDERER_MARKDOWN.toLong(), unpacked.fields[LXMFConstants.FIELD_RENDERER])
    }

    @Test
    fun `test all Python test vectors can be unpacked`() {
        if (testCases.isEmpty()) {
            println("Skipping: no test cases loaded")
            return
        }

        var successCount = 0
        var failCount = 0

        for (testCase in testCases) {
            // Remember the source identity
            val dummyPacketHash = ByteArray(32) { 0 }
            Identity.remember(
                packetHash = dummyPacketHash,
                destHash = testCase.sourceHash,
                publicKey = testCase.sourcePublicKey
            )

            val unpacked = LXMessage.unpackFromBytes(testCase.packed)
            if (unpacked != null) {
                successCount++
                // Verify hash matches
                if (!testCase.messageHash.contentEquals(unpacked.hash!!)) {
                    println("WARNING: Hash mismatch for ${testCase.name}")
                }
                if (!unpacked.signatureValidated) {
                    println("WARNING: Signature validation failed for ${testCase.name}")
                }
            } else {
                failCount++
                println("FAILED to unpack: ${testCase.name}")
            }
        }

        println("Python interop test results: $successCount success, $failCount failed")
        assertEquals(0, failCount, "All Python-generated messages should unpack successfully")
    }
}
